{"0.4.10":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.4.10/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.4.10","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"732fd2b36ea11caca5b0edce0786aa6cc09b3b42beacebb8adee3f6db905093d","md5":"948611c37024103ae3fece6fb2320701","sha256":"654d0f3a2c099f9d81a4dc64af62a7d0f2e63b642b9af526bd1ef74687853418"},"downloads":-1,"filename":"jcvi-0.4.10.tar.gz","has_sig":false,"md5_digest":"948611c37024103ae3fece6fb2320701","packagetype":"sdist","python_version":"source","requires_python":null,"size":576527,"upload_time":"2014-10-11T09:32:18","upload_time_iso_8601":"2014-10-11T09:32:18.320678Z","url":"https://files.pythonhosted.org/packages/73/2f/d2b36ea11caca5b0edce0786aa6cc09b3b42beacebb8adee3f6db905093d/jcvi-0.4.10.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.4.12":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.4.12/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.4.12","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"0d79f86d87cb9f3a987a497a022422ec858d2788988f42067f773f3ca078c089","md5":"2cfc242ca67eb80be112f62805c1c5c6","sha256":"93425f1fae03c8df20d71b3d5ceb3e8a24d979d5204b77823da54f50aeca05c4"},"downloads":-1,"filename":"jcvi-0.4.12.tar.gz","has_sig":false,"md5_digest":"2cfc242ca67eb80be112f62805c1c5c6","packagetype":"sdist","python_version":"source","requires_python":null,"size":585185,"upload_time":"2014-12-22T19:49:54","upload_time_iso_8601":"2014-12-22T19:49:54.612428Z","url":"https://files.pythonhosted.org/packages/0d/79/f86d87cb9f3a987a497a022422ec858d2788988f42067f773f3ca078c089/jcvi-0.4.12.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.4.7":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.4.7/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.4.7","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"9a4fc53e7eb012d5a42fca39fa8669a7d58f14673abbbe328b8c7e775cbf92cb","md5":"792e14ea0915bbbf2c2b9e207eccde27","sha256":"9181ce8cf9768c1829f72c542aa801ba7d21f218e50c0776da5e1d110479d96d"},"downloads":-1,"filename":"jcvi-0.4.7.tar.gz","has_sig":false,"md5_digest":"792e14ea0915bbbf2c2b9e207eccde27","packagetype":"sdist","python_version":"source","requires_python":null,"size":559294,"upload_time":"2014-07-18T23:55:18","upload_time_iso_8601":"2014-07-18T23:55:18.729328Z","url":"https://files.pythonhosted.org/packages/9a/4f/c53e7eb012d5a42fca39fa8669a7d58f14673abbbe328b8c7e775cbf92cb/jcvi-0.4.7.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.4.8":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.4.8/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.4.8","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"4a9da6b537b0be8725d94c92546c4ba8de4d6fb97df654d7c12b6fe000049491","md5":"90ffd917018d2f3f4f20ed24e923d3d6","sha256":"8465dc624ecbb82c89ee6872ce6779634b877443ffe836124ef307cf76c6378a"},"downloads":-1,"filename":"jcvi-0.4.8.tar.gz","has_sig":false,"md5_digest":"90ffd917018d2f3f4f20ed24e923d3d6","packagetype":"sdist","python_version":"source","requires_python":null,"size":565401,"upload_time":"2014-08-26T20:24:47","upload_time_iso_8601":"2014-08-26T20:24:47.079827Z","url":"https://files.pythonhosted.org/packages/4a/9d/a6b537b0be8725d94c92546c4ba8de4d6fb97df654d7c12b6fe000049491/jcvi-0.4.8.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.4.9":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.4.9/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.4.9","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"ac53ef3eaa2c0473a0553c6b5f2446885b3af401e53174e33d682d82e15d3795","md5":"7732401ef788e7dc0a4eccf44e2056c5","sha256":"10a4d30f2148aa580e8e672a5aaba10e153a578b35e951ec69f2b4b679d90420"},"downloads":-1,"filename":"jcvi-0.4.9.tar.gz","has_sig":false,"md5_digest":"7732401ef788e7dc0a4eccf44e2056c5","packagetype":"sdist","python_version":"source","requires_python":null,"size":569550,"upload_time":"2014-09-19T07:35:28","upload_time_iso_8601":"2014-09-19T07:35:28.675018Z","url":"https://files.pythonhosted.org/packages/ac/53/ef3eaa2c0473a0553c6b5f2446885b3af401e53174e33d682d82e15d3795/jcvi-0.4.9.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.5.1":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.5.1/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.5.1","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"956896c4e56778504252a4a498c1b2f50561b73938812dd4e280a931bb3d1ecc","md5":"6e34ac3be68011f6656a2aad75ed5614","sha256":"2adb070783a773889a88e55724d823b0856ab490523f0a12b6d3a235fd6bac4c"},"downloads":-1,"filename":"jcvi-0.5.1.tar.gz","has_sig":false,"md5_digest":"6e34ac3be68011f6656a2aad75ed5614","packagetype":"sdist","python_version":"source","requires_python":null,"size":586259,"upload_time":"2015-01-03T17:11:35","upload_time_iso_8601":"2015-01-03T17:11:35.993129Z","url":"https://files.pythonhosted.org/packages/95/68/96c4e56778504252a4a498c1b2f50561b73938812dd4e280a931bb3d1ecc/jcvi-0.5.1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.5.3":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.5.3/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.5.3","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"21d62f7d7a1ed2df03a36839a7556a663bfdc96755dc60907faa67ad03af0730","md5":"30ce7f7eedf5d0508aabf23cd3a17ee2","sha256":"589cc5edc564b3b6019a86422dfcb2cd44c4f59606bcf1ce310b5911d15ba21c"},"downloads":-1,"filename":"jcvi-0.5.3.tar.gz","has_sig":false,"md5_digest":"30ce7f7eedf5d0508aabf23cd3a17ee2","packagetype":"sdist","python_version":"source","requires_python":null,"size":592579,"upload_time":"2015-02-16T20:20:07","upload_time_iso_8601":"2015-02-16T20:20:07.558369Z","url":"https://files.pythonhosted.org/packages/21/d6/2f7d7a1ed2df03a36839a7556a663bfdc96755dc60907faa67ad03af0730/jcvi-0.5.3.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.5.5":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.5.5/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.5.5","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"fba1ae58b6664ceaf79e0aa367e371e5c76e0699c0b9d7baec999e3d3a2e7052","md5":"f248dca9dcae1b10ee9c2e1c4b6885cf","sha256":"82e55a04126695d7c88d0d2516fcff9c8e69272bb733ce05ff0c55173253bc20"},"downloads":-1,"filename":"jcvi-0.5.5.tar.gz","has_sig":false,"md5_digest":"f248dca9dcae1b10ee9c2e1c4b6885cf","packagetype":"sdist","python_version":"source","requires_python":null,"size":606881,"upload_time":"2015-03-31T20:31:48","upload_time_iso_8601":"2015-03-31T20:31:48.058483Z","url":"https://files.pythonhosted.org/packages/fb/a1/ae58b6664ceaf79e0aa367e371e5c76e0699c0b9d7baec999e3d3a2e7052/jcvi-0.5.5.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.5.7":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.5.7/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.5.7","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"fdd72739abb3779ccef74fd9f41062fa0a357b0434d3c261faa5bef044853292","md5":"8b066d3f62c323528c52db452922f2ac","sha256":"39e42dacd6bedeb4cb66d11198fc5eb67fef68ec19c0906f6ce9eae5f853b758"},"downloads":-1,"filename":"jcvi-0.5.7.tar.gz","has_sig":false,"md5_digest":"8b066d3f62c323528c52db452922f2ac","packagetype":"sdist","python_version":"source","requires_python":null,"size":626165,"upload_time":"2015-07-29T20:07:37","upload_time_iso_8601":"2015-07-29T20:07:37.669420Z","url":"https://files.pythonhosted.org/packages/fd/d7/2739abb3779ccef74fd9f41062fa0a357b0434d3c261faa5bef044853292/jcvi-0.5.7.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.5.8":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.5.8/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.5.8","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"b5e714df7241963f68cfef3fccd5b907c217f397cd90e83f73f4dfceedd9a4d2","md5":"f0ec5f0fdc0c436cb8944eab8ea9aef1","sha256":"fbab5cb7b19f1c069386adb29c5e93e2422107b8fbf527fcb885f65d7559a6af"},"downloads":-1,"filename":"jcvi-0.5.8.tar.gz","has_sig":false,"md5_digest":"f0ec5f0fdc0c436cb8944eab8ea9aef1","packagetype":"sdist","python_version":"source","requires_python":null,"size":647717,"upload_time":"2015-10-14T06:31:36","upload_time_iso_8601":"2015-10-14T06:31:36.540669Z","url":"https://files.pythonhosted.org/packages/b5/e7/14df7241963f68cfef3fccd5b907c217f397cd90e83f73f4dfceedd9a4d2/jcvi-0.5.8.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.5.9":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.5.9/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.5.9","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"6f6b65638dc603fa922672380f32d5d7e8b263cc4d0a5f2a166701b50e3a1d88","md5":"a28df9a65fcf15e12d95aeed2bf2f0c8","sha256":"0dd9d09881170008d4c7adaf0f8bbe2c762e353cfddc060786e5ac4b3328d9f4"},"downloads":-1,"filename":"jcvi-0.5.9.tar.gz","has_sig":false,"md5_digest":"a28df9a65fcf15e12d95aeed2bf2f0c8","packagetype":"sdist","python_version":"source","requires_python":null,"size":652860,"upload_time":"2015-11-14T12:22:10","upload_time_iso_8601":"2015-11-14T12:22:10.303675Z","url":"https://files.pythonhosted.org/packages/6f/6b/65638dc603fa922672380f32d5d7e8b263cc4d0a5f2a166701b50e3a1d88/jcvi-0.5.9.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.6.1":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.6.1/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.6.1","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"4db277a3e0bba015cd3d3edb3bd4e7065b0090c0cf77560c24681464ab73042e","md5":"46145a6f5261704c57e9bd4b15b3e0ad","sha256":"4fb330c23d5c78c375ab7233c62c6392db439b97a9e1745912f547c8310660a9"},"downloads":-1,"filename":"jcvi-0.6.1.tar.gz","has_sig":false,"md5_digest":"46145a6f5261704c57e9bd4b15b3e0ad","packagetype":"sdist","python_version":"source","requires_python":null,"size":672087,"upload_time":"2016-01-26T17:11:12","upload_time_iso_8601":"2016-01-26T17:11:12.308485Z","url":"https://files.pythonhosted.org/packages/4d/b2/77a3e0bba015cd3d3edb3bd4e7065b0090c0cf77560c24681464ab73042e/jcvi-0.6.1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.6.2":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.6.2/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.6.2","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"3ac3b488edc6a7ef108636c86fd3673bcfa53a1dc5f4ad45c5c5652a29f32226","md5":"17f0dc9b60f9170e24849af8baab21cc","sha256":"12818ddaf7ebe1c583a3e2440b7569709370f043c54c544768affc4504a63dcd"},"downloads":-1,"filename":"jcvi-0.6.2.tar.gz","has_sig":false,"md5_digest":"17f0dc9b60f9170e24849af8baab21cc","packagetype":"sdist","python_version":"source","requires_python":null,"size":669480,"upload_time":"2016-03-06T07:37:42","upload_time_iso_8601":"2016-03-06T07:37:42.437824Z","url":"https://files.pythonhosted.org/packages/3a/c3/b488edc6a7ef108636c86fd3673bcfa53a1dc5f4ad45c5c5652a29f32226/jcvi-0.6.2.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.6.6":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.6.6/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.6.6","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"b1d42d2d6f252243402231b000eb4d4850ed6303064f5586b00d69364c6ee60d","md5":"2ff3c6a1cb8ec38035962b9607cc7379","sha256":"720e6ffa0c846dfc3bae2560c24a8e39ed0709b0ab121c0b331cea99ae0e6d25"},"downloads":-1,"filename":"jcvi-0.6.6.tar.gz","has_sig":false,"md5_digest":"2ff3c6a1cb8ec38035962b9607cc7379","packagetype":"sdist","python_version":"source","requires_python":null,"size":687112,"upload_time":"2016-06-26T20:56:56","upload_time_iso_8601":"2016-06-26T20:56:56.544330Z","url":"https://files.pythonhosted.org/packages/b1/d4/2d2d6f252243402231b000eb4d4850ed6303064f5586b00d69364c6ee60d/jcvi-0.6.6.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.6.9":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"UNKNOWN","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"UNKNOWN","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Download":"UNKNOWN","Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.6.9/","requires_dist":null,"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.6.9","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"1f0a4d1328c1cb4244d445aad2d7009f25d1490bc6d557cc4863a4ac5c42bc62","md5":"c221791fc2e52edae2a42416fd4a58ea","sha256":"e8f953a834ece1a017ffb5a085c710c81ba6b3bcbc91aa794aa383abf903b5ce"},"downloads":-1,"filename":"jcvi-0.6.9.tar.gz","has_sig":false,"md5_digest":"c221791fc2e52edae2a42416fd4a58ea","packagetype":"sdist","python_version":"source","requires_python":null,"size":712548,"upload_time":"2016-10-02T14:27:08","upload_time_iso_8601":"2016-10-02T14:27:08.742104Z","url":"https://files.pythonhosted.org/packages/1f/0a/4d1328c1cb4244d445aad2d7009f25d1490bc6d557cc4863a4ac5c42bc62/jcvi-0.6.9.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.7.1":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.7.1/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.7.1","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"27886b2048b283c8ee70456e5bc7be04251020fd9b3929df13b6850d16e78e45","md5":"4e0f3d6c87cb7dba2308ae6eddca0c5c","sha256":"bf5bb92160bb1942b615013315404daf263da2f629b3bc141a7cb7f1dc211d3a"},"downloads":-1,"filename":"jcvi-0.7.1.tar.gz","has_sig":false,"md5_digest":"4e0f3d6c87cb7dba2308ae6eddca0c5c","packagetype":"sdist","python_version":"source","requires_python":null,"size":718515,"upload_time":"2017-01-20T18:58:16","upload_time_iso_8601":"2017-01-20T18:58:16.878349Z","url":"https://files.pythonhosted.org/packages/27/88/6b2048b283c8ee70456e5bc7be04251020fd9b3929df13b6850d16e78e45/jcvi-0.7.1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.7.3":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.7.3/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.7.3","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"c157226e744b4ad8c43086b050a710cc13012fc07a881847d7cfc98f10c2a35c","md5":"151e154cbefc1e5d604bdb648d8137eb","sha256":"58490d9ebb986ca04e4c4bcebde55edafbf267163c15f87eb250b6b34f3866dd"},"downloads":-1,"filename":"jcvi-0.7.3.tar.gz","has_sig":false,"md5_digest":"151e154cbefc1e5d604bdb648d8137eb","packagetype":"sdist","python_version":"source","requires_python":null,"size":724680,"upload_time":"2017-03-06T06:44:36","upload_time_iso_8601":"2017-03-06T06:44:36.509450Z","url":"https://files.pythonhosted.org/packages/c1/57/226e744b4ad8c43086b050a710cc13012fc07a881847d7cfc98f10c2a35c/jcvi-0.7.3.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.7.5":{"info":{"author":"Haibao Tang","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.7.5/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.7.5","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"e9dd64edf8d5ff645b2b186030df11516cd90daef149b5a3b8658fbe52d3c804","md5":"46731c6f05399c57c2f181b4e9c24b38","sha256":"469186839a55f6ccb0930a812fb4166833d4977f80faf646934d8042321674b2"},"downloads":-1,"filename":"jcvi-0.7.5.tar.gz","has_sig":false,"md5_digest":"46731c6f05399c57c2f181b4e9c24b38","packagetype":"sdist","python_version":"source","requires_python":null,"size":758501,"upload_time":"2017-08-31T13:26:51","upload_time_iso_8601":"2017-08-31T13:26:51.151340Z","url":"https://files.pythonhosted.org/packages/e9/dd/64edf8d5ff645b2b186030df11516cd90daef149b5a3b8658fbe52d3c804/jcvi-0.7.5.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.7.7":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":null,"docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.7.7/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.7.7","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"e1e760e9e2c221731f6c0305784ac952c431625bf7be41a39464a568f4e3b18c","md5":"81d75071632d64e8cb84b1309861d369","sha256":"561b9800f17542b29867e71488ddbd5a8dec72e5d0024a742e5917bc36798e5f"},"downloads":-1,"filename":"jcvi-0.7.7.tar.gz","has_sig":false,"md5_digest":"81d75071632d64e8cb84b1309861d369","packagetype":"sdist","python_version":"source","requires_python":null,"size":767697,"upload_time":"2017-10-15T01:49:54","upload_time_iso_8601":"2017-10-15T01:49:54.579145Z","url":"https://files.pythonhosted.org/packages/e1/e7/60e9e2c221731f6c0305784ac952c431625bf7be41a39464a568f4e3b18c/jcvi-0.7.7.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.8.12":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.8.12/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.8.12","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"73be2308651186c01a36a08fa327be49e6f7d0190211a34d11d243fe889e6de1","md5":"205b301cc14afe546ef29212d24540ee","sha256":"dbe6422b388f92abf806f5c21ec3fd050b6a1a5471bd459b538827e109224d8d"},"downloads":-1,"filename":"jcvi-0.8.12.tar.gz","has_sig":false,"md5_digest":"205b301cc14afe546ef29212d24540ee","packagetype":"sdist","python_version":"source","requires_python":null,"size":790253,"upload_time":"2018-12-10T00:13:23","upload_time_iso_8601":"2018-12-10T00:13:23.779890Z","url":"https://files.pythonhosted.org/packages/73/be/2308651186c01a36a08fa327be49e6f7d0190211a34d11d243fe889e6de1/jcvi-0.8.12.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.8.4":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.8.4/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.8.4","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"2f4c745403735f07d6f4f83d0779cbfe1b565a366c5caba854bff17970b7b524","md5":"30a952989856eddcf31a7d42a14c9415","sha256":"d326ef550fa56b45190b3f5de7c2917af9d64ace8d22592cd65ceafad10b5280"},"downloads":-1,"filename":"jcvi-0.8.4.tar.gz","has_sig":false,"md5_digest":"30a952989856eddcf31a7d42a14c9415","packagetype":"sdist","python_version":"source","requires_python":null,"size":775029,"upload_time":"2018-04-28T22:33:59","upload_time_iso_8601":"2018-04-28T22:33:59.680127Z","url":"https://files.pythonhosted.org/packages/2f/4c/745403735f07d6f4f83d0779cbfe1b565a366c5caba854bff17970b7b524/jcvi-0.8.4.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.9.11":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.9.11/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.9.11","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"f2860f8df6719496e325af9c5373081b3f88e854ffdb128a1f412124011fbe23","md5":"e237351bd7e55887a556340364487797","sha256":"e7719014ebbd82107806adda6c784d73cd6ba5036289ccb2058800ad22bbad7a"},"downloads":-1,"filename":"jcvi-0.9.11.tar.gz","has_sig":false,"md5_digest":"e237351bd7e55887a556340364487797","packagetype":"sdist","python_version":"source","requires_python":null,"size":801568,"upload_time":"2019-09-28T03:40:42","upload_time_iso_8601":"2019-09-28T03:40:42.206790Z","url":"https://files.pythonhosted.org/packages/f2/86/0f8df6719496e325af9c5373081b3f88e854ffdb128a1f412124011fbe23/jcvi-0.9.11.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.9.12":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.9.12/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.9.12","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"b4fb9aac88999c9eb01575ec8e0924df82b247b4df1e626bbc853caccff3e83e","md5":"cb1a176392d2c48ffbefef8eef86b910","sha256":"4ac2a5adc03c95826cf2f6359f181c7cccb8cdb6a3f02f6718b045d439a0254e"},"downloads":-1,"filename":"jcvi-0.9.12.tar.gz","has_sig":false,"md5_digest":"cb1a176392d2c48ffbefef8eef86b910","packagetype":"sdist","python_version":"source","requires_python":null,"size":801550,"upload_time":"2019-10-03T02:26:03","upload_time_iso_8601":"2019-10-03T02:26:03.187095Z","url":"https://files.pythonhosted.org/packages/b4/fb/9aac88999c9eb01575ec8e0924df82b247b4df1e626bbc853caccff3e83e/jcvi-0.9.12.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.9.13":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.9.13/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.9.13","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"f4ec5b12cd16bd7ece78e740974aa190b554e61c9ec817ecfbaf090efb715a31","md5":"a3a9b217e79ee44d8897487c62a806f8","sha256":"f333a091fae5d9e40c0ed7eb31064537f5e87fe4ef6c231977552938f61e7248"},"downloads":-1,"filename":"jcvi-0.9.13.tar.gz","has_sig":false,"md5_digest":"a3a9b217e79ee44d8897487c62a806f8","packagetype":"sdist","python_version":"source","requires_python":null,"size":803861,"upload_time":"2019-11-03T20:29:15","upload_time_iso_8601":"2019-11-03T20:29:15.443159Z","url":"https://files.pythonhosted.org/packages/f4/ec/5b12cd16bd7ece78e740974aa190b554e61c9ec817ecfbaf090efb715a31/jcvi-0.9.13.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"0.9.14":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/0.9.14/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"0.9.14","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"9b4cc454c7e965d28b1ef90b186be5502aee2460ecd242513ef7ca28ce4691e5","md5":"7475c6f0ccf08ee2393b977383f5734b","sha256":"90b7300ba979d41b443c0c6af6768a7bddee0ae2abd5a87a8bc90f044d75a9de"},"downloads":-1,"filename":"jcvi-0.9.14.tar.gz","has_sig":false,"md5_digest":"7475c6f0ccf08ee2393b977383f5734b","packagetype":"sdist","python_version":"source","requires_python":null,"size":806925,"upload_time":"2019-12-10T09:02:28","upload_time_iso_8601":"2019-12-10T09:02:28.430255Z","url":"https://files.pythonhosted.org/packages/9b/4c/c454c7e965d28b1ef90b186be5502aee2460ecd242513ef7ca28ce4691e5/jcvi-0.9.14.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.0.1":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.0.1/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.0.1","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"b12a6630b839be29f1d0ce2f6059ee0889eb8e65bee5c80216901f0edf3a7dd6","md5":"60c495377aa9a2ef4891eb7e49a41982","sha256":"2ea7b692b55485c53aba9dee58f0e218df841ea7b55454680c053ad8fee6e647"},"downloads":-1,"filename":"jcvi-1.0.1.tar.gz","has_sig":false,"md5_digest":"60c495377aa9a2ef4891eb7e49a41982","packagetype":"sdist","python_version":"source","requires_python":null,"size":812681,"upload_time":"2020-01-31T06:39:48","upload_time_iso_8601":"2020-01-31T06:39:48.206199Z","url":"https://files.pythonhosted.org/packages/b1/2a/6630b839be29f1d0ce2f6059ee0889eb8e65bee5c80216901f0edf3a7dd6/jcvi-1.0.1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.0.10":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.0.10/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.0.10","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"9dec6c6329502b18bcaf244d19a66aab8df287ac99c7cbaa0c047a6c18844de8","md5":"b839ac9b8e59b8238bc40d57ef827ddf","sha256":"56881652b39662a54d32c2f6387e9c58e40a925ac326c9bf1b4ba929b5a86562"},"downloads":-1,"filename":"jcvi-1.0.10.tar.gz","has_sig":false,"md5_digest":"b839ac9b8e59b8238bc40d57ef827ddf","packagetype":"sdist","python_version":"source","requires_python":null,"size":840691,"upload_time":"2020-10-28T00:02:25","upload_time_iso_8601":"2020-10-28T00:02:25.943986Z","url":"https://files.pythonhosted.org/packages/9d/ec/6c6329502b18bcaf244d19a66aab8df287ac99c7cbaa0c047a6c18844de8/jcvi-1.0.10.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.0.13":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.0.13/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.0.13","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"2ce3587dd5ddba13f6eff78a78b85d0dc7d008b15e5e28d04fc4081cff9f2ca6","md5":"18df32709f5e2862dff15f2a009a5dd6","sha256":"659ada559937f5914113a7a60bdc41bd58ddeadf7c1db974e11271b526e8c963"},"downloads":-1,"filename":"jcvi-1.0.13.tar.gz","has_sig":false,"md5_digest":"18df32709f5e2862dff15f2a009a5dd6","packagetype":"sdist","python_version":"source","requires_python":null,"size":849364,"upload_time":"2020-11-29T07:49:35","upload_time_iso_8601":"2020-11-29T07:49:35.437057Z","url":"https://files.pythonhosted.org/packages/2c/e3/587dd5ddba13f6eff78a78b85d0dc7d008b15e5e28d04fc4081cff9f2ca6/jcvi-1.0.13.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.0.14":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.0.14/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.0.14","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"d8232d8a77861f1c1e066a6d8edc217c9217641a6e7ca5cdd5539ccd1b6ab8b9","md5":"d0bb60409801ac79f4497750ca4b1341","sha256":"2fda3b5e0dc9dcf0fb30578033d9274a99723b54ce6e514936f9dbd2c872f626"},"downloads":-1,"filename":"jcvi-1.0.14.tar.gz","has_sig":false,"md5_digest":"d0bb60409801ac79f4497750ca4b1341","packagetype":"sdist","python_version":"source","requires_python":null,"size":849607,"upload_time":"2020-12-13T18:27:23","upload_time_iso_8601":"2020-12-13T18:27:23.593186Z","url":"https://files.pythonhosted.org/packages/d8/23/2d8a77861f1c1e066a6d8edc217c9217641a6e7ca5cdd5539ccd1b6ab8b9/jcvi-1.0.14.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.0.3":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.0.3/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.0.3","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"bc969cee88ea244fef540ca144a19c99e859102641861df833a075e3e5824aaf","md5":"2cadc25bacdb287b690f65edc93a0e49","sha256":"6115882020338d53058b2d35ccbc451f737cbe0205320742fc63c8c41b46d7df"},"downloads":-1,"filename":"jcvi-1.0.3.tar.gz","has_sig":false,"md5_digest":"2cadc25bacdb287b690f65edc93a0e49","packagetype":"sdist","python_version":"source","requires_python":null,"size":814488,"upload_time":"2020-02-11T06:36:06","upload_time_iso_8601":"2020-02-11T06:36:06.738639Z","url":"https://files.pythonhosted.org/packages/bc/96/9cee88ea244fef540ca144a19c99e859102641861df833a075e3e5824aaf/jcvi-1.0.3.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.0.5":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.0.5/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.0.5","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"57a2c4366a77f1ffacfe04a0b338c18a675d878728e89d4ef2b26ae5c15f00d3","md5":"78504b510a50e755b661a520b787cdc9","sha256":"5dd0515541548cee07a0cbb26bec70cdea8d502fc365971c420f3b919ef3074b"},"downloads":-1,"filename":"jcvi-1.0.5.tar.gz","has_sig":false,"md5_digest":"78504b510a50e755b661a520b787cdc9","packagetype":"sdist","python_version":"source","requires_python":null,"size":821677,"upload_time":"2020-03-03T07:17:33","upload_time_iso_8601":"2020-03-03T07:17:33.896264Z","url":"https://files.pythonhosted.org/packages/57/a2/c4366a77f1ffacfe04a0b338c18a675d878728e89d4ef2b26ae5c15f00d3/jcvi-1.0.5.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.0.6":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.0.6/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.0.6","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"95997dbf1fe691d207f09fb898775ee72afb5174253d09bf9a37978860d00b5a","md5":"2e40001d7692f55015119460962ae2be","sha256":"49565d9dfe7519ee58a365a2507162f1483943370a89dfdc357650bbc3540c25"},"downloads":-1,"filename":"jcvi-1.0.6.tar.gz","has_sig":false,"md5_digest":"2e40001d7692f55015119460962ae2be","packagetype":"sdist","python_version":"source","requires_python":null,"size":822257,"upload_time":"2020-04-15T16:11:28","upload_time_iso_8601":"2020-04-15T16:11:28.683283Z","url":"https://files.pythonhosted.org/packages/95/99/7dbf1fe691d207f09fb898775ee72afb5174253d09bf9a37978860d00b5a/jcvi-1.0.6.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.0.8":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.0.8/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.0.8","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"79d2d570003c0045ea92485ea9c5e8f0561d47bbf18ea8951fe31450ca8961ff","md5":"c85e3e77cd3db2ab18ba5eca524b69d1","sha256":"64cf47d3bbcc54dabfa8e20bdae7693dba8de8bd67e6c9c70d3ff16f24cf279e"},"downloads":-1,"filename":"jcvi-1.0.8.tar.gz","has_sig":false,"md5_digest":"c85e3e77cd3db2ab18ba5eca524b69d1","packagetype":"sdist","python_version":"source","requires_python":null,"size":829935,"upload_time":"2020-06-25T06:16:41","upload_time_iso_8601":"2020-06-25T06:16:41.147567Z","url":"https://files.pythonhosted.org/packages/79/d2/d570003c0045ea92485ea9c5e8f0561d47bbf18ea8951fe31450ca8961ff/jcvi-1.0.8.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.0.9":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 2","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.0.9/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.0.9","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"976ffb49e1603d4617f0a136f86a94e035be5cf1fe34b9ff59ddfc7e5fc5d04d","md5":"cfdb28721a591a0b812b484f470c660f","sha256":"b03f2385639b601f111c812872763fee6699aa8f2683431347520f5bf9155480"},"downloads":-1,"filename":"jcvi-1.0.9.tar.gz","has_sig":false,"md5_digest":"cfdb28721a591a0b812b484f470c660f","packagetype":"sdist","python_version":"source","requires_python":null,"size":832163,"upload_time":"2020-07-25T19:48:55","upload_time_iso_8601":"2020-07-25T19:48:55.002884Z","url":"https://files.pythonhosted.org/packages/97/6f/fb49e1603d4617f0a136f86a94e035be5cf1fe34b9ff59ddfc7e5fc5d04d/jcvi-1.0.9.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.1.11":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.1.11/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.1.11","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"5b361ed66483a5d733d87bd77466e425ef557fa4e1aa8c779b0acf02a810f822","md5":"cd70db3bf7ac3c21b497f00c1e2947f1","sha256":"871ea81abb709470fc2f86038372915211dfb211901a9faed0b84714783780e7"},"downloads":-1,"filename":"jcvi-1.1.11.tar.gz","has_sig":false,"md5_digest":"cd70db3bf7ac3c21b497f00c1e2947f1","packagetype":"sdist","python_version":"source","requires_python":null,"size":820518,"upload_time":"2021-03-26T16:13:21","upload_time_iso_8601":"2021-03-26T16:13:21.179951Z","url":"https://files.pythonhosted.org/packages/5b/36/1ed66483a5d733d87bd77466e425ef557fa4e1aa8c779b0acf02a810f822/jcvi-1.1.11.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.1.12":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.1.12/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.1.12","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"7e5c76e236becc18806e305a68068ab84eab0eeeb862fbcea38674a7775c72c5","md5":"7251180efc0a88e151eb6f08093e1613","sha256":"9c688816d2770300a137fe0cdb7c4cdbc0f94e9f96d849cf0c1465af4464f8fe"},"downloads":-1,"filename":"jcvi-1.1.12.tar.gz","has_sig":false,"md5_digest":"7251180efc0a88e151eb6f08093e1613","packagetype":"sdist","python_version":"source","requires_python":null,"size":820630,"upload_time":"2021-04-18T23:31:04","upload_time_iso_8601":"2021-04-18T23:31:04.488447Z","url":"https://files.pythonhosted.org/packages/7e/5c/76e236becc18806e305a68068ab84eab0eeeb862fbcea38674a7775c72c5/jcvi-1.1.12.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.1.15":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.1.15/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.1.15","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"89971497942bf5ec52ada7cee1ad1961eecbe87361494812c57c9fb7cf659834","md5":"292be8acac7f04bf9ab8eab527db94c9","sha256":"d22c72cd566f41ca8e9e47e30ca430ec03fe06cc62dd22a652e8e0257c3a3e90"},"downloads":-1,"filename":"jcvi-1.1.15.tar.gz","has_sig":false,"md5_digest":"292be8acac7f04bf9ab8eab527db94c9","packagetype":"sdist","python_version":"source","requires_python":null,"size":794830,"upload_time":"2021-06-27T16:37:36","upload_time_iso_8601":"2021-06-27T16:37:36.770782Z","url":"https://files.pythonhosted.org/packages/89/97/1497942bf5ec52ada7cee1ad1961eecbe87361494812c57c9fb7cf659834/jcvi-1.1.15.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.1.17":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.1.17/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.1.17","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"9594db0f2759b6f1e6f6e4f7e66f8168b95c846a4ba233a6b71a1bc5352f4014","md5":"1341e446114dce39c1b20a349a7e7626","sha256":"e8bccf025ce08acdb89bb9f9b3017e38c6ed65f55785edd298338af8adfe3769"},"downloads":-1,"filename":"jcvi-1.1.17.tar.gz","has_sig":false,"md5_digest":"1341e446114dce39c1b20a349a7e7626","packagetype":"sdist","python_version":"source","requires_python":null,"size":795864,"upload_time":"2021-07-22T06:08:24","upload_time_iso_8601":"2021-07-22T06:08:24.719669Z","url":"https://files.pythonhosted.org/packages/95/94/db0f2759b6f1e6f6e4f7e66f8168b95c846a4ba233a6b71a1bc5352f4014/jcvi-1.1.17.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.1.18":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.1.18/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.1.18","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"fefec605c28525d957300214f84cb3e3a3abf1e4645030736ef2190650e5ecec","md5":"86efb51e80747e388dccccd827718323","sha256":"69b508b722786ffe6ba03cdbab3e456404ae000adbe79c3f3ad8b791fb5f7679"},"downloads":-1,"filename":"jcvi-1.1.18.tar.gz","has_sig":false,"md5_digest":"86efb51e80747e388dccccd827718323","packagetype":"sdist","python_version":"source","requires_python":null,"size":795336,"upload_time":"2021-09-09T03:33:19","upload_time_iso_8601":"2021-09-09T03:33:19.959420Z","url":"https://files.pythonhosted.org/packages/fe/fe/c605c28525d957300214f84cb3e3a3abf1e4645030736ef2190650e5ecec/jcvi-1.1.18.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.1.21":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.1.21/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.1.21","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"a06dcc7023508363f2a67bc070c1c3bd3f6980bead63a33b5c151bdefd30be4d","md5":"94ef26838d6e50fb78a6d69d88dca631","sha256":"db31e89301f6214f922192002558679420e416ae83439edf92aca61328ad64ab"},"downloads":-1,"filename":"jcvi-1.1.21.tar.gz","has_sig":false,"md5_digest":"94ef26838d6e50fb78a6d69d88dca631","packagetype":"sdist","python_version":"source","requires_python":null,"size":796313,"upload_time":"2021-11-25T18:34:34","upload_time_iso_8601":"2021-11-25T18:34:34.047940Z","url":"https://files.pythonhosted.org/packages/a0/6d/cc7023508363f2a67bc070c1c3bd3f6980bead63a33b5c151bdefd30be4d/jcvi-1.1.21.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.1.23":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.1.23/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.1.23","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"a52ccf661c41d63b5a29089f6fd5a3c54b52386f38bb8ee6a337ce2e4cffb475","md5":"ce09ac24e83c2dea813b9f21ab86a1f0","sha256":"43bdc1246469086936a84289269daccf5bba27ea76adda3c2b43f3e270c4fd2e"},"downloads":-1,"filename":"jcvi-1.1.23.tar.gz","has_sig":false,"md5_digest":"ce09ac24e83c2dea813b9f21ab86a1f0","packagetype":"sdist","python_version":"source","requires_python":null,"size":797164,"upload_time":"2021-12-25T21:45:36","upload_time_iso_8601":"2021-12-25T21:45:36.877652Z","url":"https://files.pythonhosted.org/packages/a5/2c/cf661c41d63b5a29089f6fd5a3c54b52386f38bb8ee6a337ce2e4cffb475/jcvi-1.1.23.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.1.7":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.1.7/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.1.7","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"01be3ae008ee2b3a53b46f8953bbaf1c5372b5faaf790ee7c5813201d50fbdaf","md5":"5648de9538335efada02dd00a6cb2957","sha256":"2709f0e2420da0f9d5a5da581f8f19bd54d7bb9a9720f0d0e9141f30e84b5ab2"},"downloads":-1,"filename":"jcvi-1.1.7.tar.gz","has_sig":false,"md5_digest":"5648de9538335efada02dd00a6cb2957","packagetype":"sdist","python_version":"source","requires_python":null,"size":819268,"upload_time":"2021-01-25T20:33:22","upload_time_iso_8601":"2021-01-25T20:33:22.444822Z","url":"https://files.pythonhosted.org/packages/01/be/3ae008ee2b3a53b46f8953bbaf1c5372b5faaf790ee7c5813201d50fbdaf/jcvi-1.1.7.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.1.8":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.1.8/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.1.8","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"015444acf2550250a12ea505f2b4be565357d06bdc87d7ea575f955ae98e9700","md5":"3a25b299b4beffbe4fb0814343c742bc","sha256":"8d4ce6586068e6a2fa6e39303f5dab1b6f068a1335be09e2488c5f9387685228"},"downloads":-1,"filename":"jcvi-1.1.8.tar.gz","has_sig":false,"md5_digest":"3a25b299b4beffbe4fb0814343c742bc","packagetype":"sdist","python_version":"source","requires_python":null,"size":819284,"upload_time":"2021-02-18T16:44:46","upload_time_iso_8601":"2021-02-18T16:44:46.784197Z","url":"https://files.pythonhosted.org/packages/01/54/44acf2550250a12ea505f2b4be565357d06bdc87d7ea575f955ae98e9700/jcvi-1.1.8.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.2.1":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":"","project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.2.1/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.2.1","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"712139f235ea7681e16975132c79c5c016c99f0483eafdfd4e3a835a1ff23362","md5":"be44a711465f4d6dcd1a55d72ca00f76","sha256":"4b815eac171339ef7c662e23981c3f5ff9cf38b6b2a7fc964008c3c628483791"},"downloads":-1,"filename":"jcvi-1.2.1.tar.gz","has_sig":false,"md5_digest":"be44a711465f4d6dcd1a55d72ca00f76","packagetype":"sdist","python_version":"source","requires_python":null,"size":796533,"upload_time":"2022-01-21T19:25:01","upload_time_iso_8601":"2022-01-21T19:25:01.204373Z","url":"https://files.pythonhosted.org/packages/71/21/39f235ea7681e16975132c79c5c016c99f0483eafdfd4e3a835a1ff23362/jcvi-1.2.1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.2.10":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.2.10/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.2.10","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"7a55a28c06b4eb3ed457d669d60cd230236a4c5b053fd79710ba54dd3536b54e","md5":"d9b68566edd96e95d6224ff6fed3867c","sha256":"41f1b2f0ee4ef21721928a56394a49508da1ff3475b23508e01e112d39c94e5a"},"downloads":-1,"filename":"jcvi-1.2.10.tar.gz","has_sig":false,"md5_digest":"d9b68566edd96e95d6224ff6fed3867c","packagetype":"sdist","python_version":"source","requires_python":null,"size":800292,"upload_time":"2022-07-08T04:02:30","upload_time_iso_8601":"2022-07-08T04:02:30.960381Z","url":"https://files.pythonhosted.org/packages/7a/55/a28c06b4eb3ed457d669d60cd230236a4c5b053fd79710ba54dd3536b54e/jcvi-1.2.10.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.2.12":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.2.12/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.2.12","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"f34862784bd3d4e658d265b2f794461cce8386e63e467d35b567312d7880d7dc","md5":"bc49eb65d9c113f5d14266f265967b5e","sha256":"49e4c35dbd79c8ebed96012443d2af6b3655ab955ed30be304b379501ad00da0"},"downloads":-1,"filename":"jcvi-1.2.12.tar.gz","has_sig":false,"md5_digest":"bc49eb65d9c113f5d14266f265967b5e","packagetype":"sdist","python_version":"source","requires_python":null,"size":802849,"upload_time":"2022-09-27T05:19:56","upload_time_iso_8601":"2022-09-27T05:19:56.404982Z","url":"https://files.pythonhosted.org/packages/f3/48/62784bd3d4e658d265b2f794461cce8386e63e467d35b567312d7880d7dc/jcvi-1.2.12.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.2.14":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.2.14/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.2.14","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"a6baec24b216c29beff45524450b5c75b9fa0c8c41a30e018dba3285bd97db34","md5":"feb634141eea12611336f70519c7a26e","sha256":"3b67c676ddb318dd6c78b51811ace7b5fc2fc823ceec7be02eb74b4857a4ddc3"},"downloads":-1,"filename":"jcvi-1.2.14.tar.gz","has_sig":false,"md5_digest":"feb634141eea12611336f70519c7a26e","packagetype":"sdist","python_version":"source","requires_python":null,"size":803406,"upload_time":"2022-10-05T07:58:27","upload_time_iso_8601":"2022-10-05T07:58:27.749392Z","url":"https://files.pythonhosted.org/packages/a6/ba/ec24b216c29beff45524450b5c75b9fa0c8c41a30e018dba3285bd97db34/jcvi-1.2.14.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.2.20":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.2.20/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.2.20","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"f180f1866d991615949f15857977d1245c95a5657238734af8ec559adaf9a67f","md5":"32351fec9fff4de928ebacfb952a1afe","sha256":"c1a3bc0201505d838a3c5ada410e12864708a1dc60c01231c6ae967f6bd91743"},"downloads":-1,"filename":"jcvi-1.2.20-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"32351fec9fff4de928ebacfb952a1afe","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":932559,"upload_time":"2022-11-27T05:20:48","upload_time_iso_8601":"2022-11-27T05:20:48.420623Z","url":"https://files.pythonhosted.org/packages/f1/80/f1866d991615949f15857977d1245c95a5657238734af8ec559adaf9a67f/jcvi-1.2.20-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"15c34bad2e913bb884c92054969d8ea4c26d559e006f5cbf402715ff8c3ba1e8","md5":"fcfd9b52b77d1d889a51bce32ee4af11","sha256":"888e46fcd8bae86be73758fbb620189a8ab2fb8ec90f3283a43f117bb0ce28b4"},"downloads":-1,"filename":"jcvi-1.2.20.tar.gz","has_sig":false,"md5_digest":"fcfd9b52b77d1d889a51bce32ee4af11","packagetype":"sdist","python_version":"source","requires_python":null,"size":786796,"upload_time":"2022-11-26T22:08:44","upload_time_iso_8601":"2022-11-26T22:08:44.879210Z","url":"https://files.pythonhosted.org/packages/15/c3/4bad2e913bb884c92054969d8ea4c26d559e006f5cbf402715ff8c3ba1e8/jcvi-1.2.20.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.2.7":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.2.7/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.2.7","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"ede835ff7a890663b305cabce71263f2dc69e3be23b6b2a00a662fbef5f15240","md5":"624281ee5a5f705db889add3661e4428","sha256":"9d1deee1efeea33d0ac28f4a9fae523eddf3e11e2d6527ac38a1122ceae73929"},"downloads":-1,"filename":"jcvi-1.2.7.tar.gz","has_sig":false,"md5_digest":"624281ee5a5f705db889add3661e4428","packagetype":"sdist","python_version":"source","requires_python":null,"size":796681,"upload_time":"2022-03-21T04:26:13","upload_time_iso_8601":"2022-03-21T04:26:13.061979Z","url":"https://files.pythonhosted.org/packages/ed/e8/35ff7a890663b305cabce71263f2dc69e3be23b6b2a00a662fbef5f15240/jcvi-1.2.7.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.2.9":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.2.9/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.2.9","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"accca0f433e2d107a5161d843bdfe446f111633b384a724f69ea501d61e20a17","md5":"195c5aff09ebeb1f120d60a1762aa575","sha256":"5f4922cb2959aec10107c1bb280fb28831bf3198212ffb12cd1eaafef0ff24af"},"downloads":-1,"filename":"jcvi-1.2.9.tar.gz","has_sig":false,"md5_digest":"195c5aff09ebeb1f120d60a1762aa575","packagetype":"sdist","python_version":"source","requires_python":null,"size":799330,"upload_time":"2022-06-29T14:35:41","upload_time_iso_8601":"2022-06-29T14:35:41.069142Z","url":"https://files.pythonhosted.org/packages/ac/cc/a0f433e2d107a5161d843bdfe446f111633b384a724f69ea501d61e20a17/jcvi-1.2.9.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.3.3":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.3.3/","requires_dist":null,"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.3.3","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"7045594c33a71de597d0a443cfcdeafe8deb04c29b5793efafc6c94155041f09","md5":"08672622aca49df030b2c4980e8073b6","sha256":"84bd4aa9fa44bf4b2176c75889805b562c5366b91da46267c23d21c16c39cb52"},"downloads":-1,"filename":"jcvi-1.3.3-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"08672622aca49df030b2c4980e8073b6","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":936569,"upload_time":"2023-02-17T10:14:07","upload_time_iso_8601":"2023-02-17T10:14:07.461245Z","url":"https://files.pythonhosted.org/packages/70/45/594c33a71de597d0a443cfcdeafe8deb04c29b5793efafc6c94155041f09/jcvi-1.3.3-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"9dea340e82d55c1848f969d92574557977444398de715cf08bea9ef3a4c6b9cf","md5":"8b245793ca2b1861817053aa09fb38dd","sha256":"92b69f38f0a91b6b48b9c98f26144e53d7e8a8724d0543bbda2adf2bf3067d39"},"downloads":-1,"filename":"jcvi-1.3.3.tar.gz","has_sig":false,"md5_digest":"8b245793ca2b1861817053aa09fb38dd","packagetype":"sdist","python_version":"source","requires_python":null,"size":786064,"upload_time":"2023-02-17T10:13:54","upload_time_iso_8601":"2023-02-17T10:13:54.433014Z","url":"https://files.pythonhosted.org/packages/9d/ea/340e82d55c1848f969d92574557977444398de715cf08bea9ef3a4c6b9cf/jcvi-1.3.3.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.3.4":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.3.4/","requires_dist":["CrossMap","PyPDF2","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy","ortools","pybedtools","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.3.4","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"ad7ca40e69b8aac6ca6c3aa45f1477aa78414dce65af992385eb536098f41a48","md5":"cf4dd7c98a484e5c566d95d6e1a1818c","sha256":"2b311f156637f7192c8ec52315b3fa602e9dcb54b33f47e637f11d84c3854f95"},"downloads":-1,"filename":"jcvi-1.3.4-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"cf4dd7c98a484e5c566d95d6e1a1818c","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":936743,"upload_time":"2023-04-27T08:21:06","upload_time_iso_8601":"2023-04-27T08:21:06.801390Z","url":"https://files.pythonhosted.org/packages/ad/7c/a40e69b8aac6ca6c3aa45f1477aa78414dce65af992385eb536098f41a48/jcvi-1.3.4-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"13c6c6c98fcce95751ab20b85433aeabad4ad11599d4e1ceaa43b27e1f1d1881","md5":"17a8dafb9f0d51af8a74edcb984b3831","sha256":"08c6d74a8be14f1757bdf39fbb5a2b09895fb78d373c07a5e4b43da5dd08d185"},"downloads":-1,"filename":"jcvi-1.3.4.tar.gz","has_sig":false,"md5_digest":"17a8dafb9f0d51af8a74edcb984b3831","packagetype":"sdist","python_version":"source","requires_python":null,"size":789327,"upload_time":"2023-04-27T08:21:09","upload_time_iso_8601":"2023-04-27T08:21:09.771462Z","url":"https://files.pythonhosted.org/packages/13/c6/c6c98fcce95751ab20b85433aeabad4ad11599d4e1ceaa43b27e1f1d1881/jcvi-1.3.4.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.3.5":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.3.5/","requires_dist":["CrossMap","PyPDF2","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy","ortools","pybedtools","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.3.5","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"4bca0a722cd7aadca25710553688448e2f2a86776062e1bb922db3118ccb08e2","md5":"7dd938920c11dde7b5fe504cfbce557d","sha256":"1683b79d93f7cd8a8dc47aa9e8c93c59d4411a70ba18ba55043f0c79da1dfba0"},"downloads":-1,"filename":"jcvi-1.3.5-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"7dd938920c11dde7b5fe504cfbce557d","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":937601,"upload_time":"2023-05-20T02:10:08","upload_time_iso_8601":"2023-05-20T02:10:08.627859Z","url":"https://files.pythonhosted.org/packages/4b/ca/0a722cd7aadca25710553688448e2f2a86776062e1bb922db3118ccb08e2/jcvi-1.3.5-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"5441853aa89aac24c68a4576289e3964a0b24be91075c76928323e7bba42d4e7","md5":"5ad1c361202bb37a44ab38e6f8183d10","sha256":"91bc844ff82fc702d8d344a1810be3d3dc788b5e1721b3b1effd3011b4ca1849"},"downloads":-1,"filename":"jcvi-1.3.5.tar.gz","has_sig":false,"md5_digest":"5ad1c361202bb37a44ab38e6f8183d10","packagetype":"sdist","python_version":"source","requires_python":null,"size":790160,"upload_time":"2023-05-20T02:10:12","upload_time_iso_8601":"2023-05-20T02:10:12.085994Z","url":"https://files.pythonhosted.org/packages/54/41/853aa89aac24c68a4576289e3964a0b24be91075c76928323e7bba42d4e7/jcvi-1.3.5.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-35932"],"details":"### Summary\nA configuration injection happens when user input is considered by the application in an unsanitized format and can reach the configuration file. A malicious user may craft a special payload that may lead to a command injection.\n\n### PoC\n\nThe vulnerable code snippet is [/jcvi/apps/base.py#LL2227C1-L2228C41](https://github.com/tanghaibao/jcvi/blob/cede6c65c8e7603cb266bc3395ac8f915ea9eac7/jcvi/apps/base.py#LL2227C1-L2228C41). Under some circumstances a user input is retrieved and stored within the `fullpath` variable which reaches the configuration file `~/.jcvirc`.\n\n```python\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n```\n\nI ripped a part of the codebase into a runnable PoC as follows. All the PoC does is call the `getpath()` function under some circumstances.\n\n```python\nfrom configparser import (\n    ConfigParser,\n    RawConfigParser,\n    NoOptionError,\n    NoSectionError,\n    ParsingError,\n)\n\nimport errno\nimport os\nimport sys\nimport os.path as op\nimport shutil\nimport signal\nimport sys\nimport logging\n\n\ndef is_exe(fpath):\n    return op.isfile(fpath) and os.access(fpath, os.X_OK)\n\n\ndef which(program):\n    \"\"\"\n    Emulates the unix which command.\n\n    >>> which(\"cat\")\n    \"/bin/cat\"\n    >>> which(\"nosuchprogram\")\n    \"\"\"\n    fpath, fname = op.split(program)\n    if fpath:\n        if is_exe(program):\n            return program\n    else:\n        for path in os.environ[\"PATH\"].split(os.pathsep):\n            exe_file = op.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n\n    return None\n\n\ndef getpath(cmd, name=None, url=None, cfg=\"~/.jcvirc\", warn=\"exit\"):\n    \"\"\"\n    Get install locations of common binaries\n    First, check ~/.jcvirc file to get the full path\n    If not present, ask on the console and store\n    \"\"\"\n    p = which(cmd)  # if in PATH, just returns it\n    if p:\n        return p\n\n    PATH = \"Path\"\n    config = RawConfigParser()\n    cfg = op.expanduser(cfg)\n    changed = False\n    if op.exists(cfg):\n        config.read(cfg)\n\n    assert name is not None, \"Need a program name\"\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoSectionError:\n        config.add_section(PATH)\n        changed = True\n\n    try:\n        fullpath = config.get(PATH, name)\n    except NoOptionError:\n        msg = \"=== Configure path for {0} ===\\n\".format(name, cfg)\n        if url:\n            msg += \"URL: {0}\\n\".format(url)\n        msg += \"[Directory that contains `{0}`]: \".format(cmd)\n        fullpath = input(msg).strip()\n        config.set(PATH, name, fullpath)\n        changed = True\n\n    path = op.join(op.expanduser(fullpath), cmd)\n    if warn == \"exit\":\n        try:\n            assert is_exe(path), \"***ERROR: Cannot execute binary `{0}`. \".format(path)\n        except AssertionError as e:\n            sys.exit(\"{0!s}Please verify and rerun.\".format(e))\n\n    if changed:\n        configfile = open(cfg, \"w\")\n        config.write(configfile)\n        logging.debug(\"Configuration written to `{0}`.\".format(cfg))\n\n    return path\n\n\n# Call to getpath\npath = getpath(\"not-part-of-path\", name=\"CLUSTALW2\", warn=\"warn\")\nprint(path)\n\n```\n\nTo run the PoC, you need to remove the config file `~/.jcvirc` to emulate the first run, \n\n```bash\n# Run the PoC with the payload\necho -e \"e\\rvvvvvvvv = zzzzzzzz\\n\" | python3 poc.py\n```\n\n![image](https://user-images.githubusercontent.com/13036531/247852364-f8a384a3-fc62-41ca-b467-877d197ac6ff.png)\n\nYou can notice the random key/value characters `vvvvvvvv = zzzzzzzz` were successfully injected.\n\n### Impact\n\nThe impact of a configuration injection may vary. Under some conditions, it may lead to command injection if there is for instance shell code execution from the configuration file values.\n","fixed_in":[],"id":"GHSA-x49m-3cw7-gq5q","link":"https://osv.dev/vulnerability/GHSA-x49m-3cw7-gq5q","source":"osv","summary":null,"withdrawn":null}]},"1.3.6":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.3.6/","requires_dist":["CrossMap","PyPDF2","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy","ortools","pybedtools","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.3.6","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"ca1db06d3dedbc680363698053fedf8334e138e43da2555f11f993766fd9e404","md5":"658d837e3fd80bf4fb709967de6bf242","sha256":"ccd76924b417db128bda0c638e05e59048ff5137b68a8c7d6755df0dc533fcd1"},"downloads":-1,"filename":"jcvi-1.3.6-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"658d837e3fd80bf4fb709967de6bf242","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":938608,"upload_time":"2023-06-23T16:27:32","upload_time_iso_8601":"2023-06-23T16:27:32.296778Z","url":"https://files.pythonhosted.org/packages/ca/1d/b06d3dedbc680363698053fedf8334e138e43da2555f11f993766fd9e404/jcvi-1.3.6-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"893e522ee388c1188df8a3cd1f1d85e0a0380557ad02c7b953a7ccd47ca11c19","md5":"d0f989a99e0351e6883a08d4273faa65","sha256":"1a85c4f2733c2bc4af16380625070b683a05034d9c3c3c00a387509eb09f1b48"},"downloads":-1,"filename":"jcvi-1.3.6.tar.gz","has_sig":false,"md5_digest":"d0f989a99e0351e6883a08d4273faa65","packagetype":"sdist","python_version":"source","requires_python":null,"size":791175,"upload_time":"2023-06-23T16:27:34","upload_time_iso_8601":"2023-06-23T16:27:34.549070Z","url":"https://files.pythonhosted.org/packages/89/3e/522ee388c1188df8a3cd1f1d85e0a0380557ad02c7b953a7ccd47ca11c19/jcvi-1.3.6.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.3.8":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.3.8/","requires_dist":["CrossMap","PyPDF2","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy","ortools","pybedtools","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.3.8","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"beb984f934d3d5d81a368acc74adc729988785ec59f7412fa405ae037369c2d4","md5":"af305d1732f95d7799d24a07c3614f58","sha256":"0292c99ffe5a31dc37cd1d7f3197e9ba5e8cba003031e9fd340181c604e3cf66"},"downloads":-1,"filename":"jcvi-1.3.8-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"af305d1732f95d7799d24a07c3614f58","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":951618,"upload_time":"2023-08-30T02:02:14","upload_time_iso_8601":"2023-08-30T02:02:14.246903Z","url":"https://files.pythonhosted.org/packages/be/b9/84f934d3d5d81a368acc74adc729988785ec59f7412fa405ae037369c2d4/jcvi-1.3.8-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"99db080fa6a56426461bf372f537c51ff46a1aedaec14cf84de580e123e416f1","md5":"6acb32a5d97f837a387a9864aac5df5c","sha256":"f193f93b0a967ab6b6e940645f68e7ab640f2838973d270a0aa8662fe3f774ae"},"downloads":-1,"filename":"jcvi-1.3.8.tar.gz","has_sig":false,"md5_digest":"6acb32a5d97f837a387a9864aac5df5c","packagetype":"sdist","python_version":"source","requires_python":null,"size":791271,"upload_time":"2023-08-30T02:02:16","upload_time_iso_8601":"2023-08-30T02:02:16.530774Z","url":"https://files.pythonhosted.org/packages/99/db/080fa6a56426461bf372f537c51ff46a1aedaec14cf84de580e123e416f1/jcvi-1.3.8.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.3.9":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.3.9/","requires_dist":["CrossMap","PyPDF2","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy","ortools","pybedtools","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.3.9","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"1279423493aa03f6bd485dfd1219ad3a4cf816424ed518586a0c283bbd07b690","md5":"00a57442b8ca4d14a325b51e2af0fd16","sha256":"306f8faf2ca71bb0b04e95487b53888b751eeab4fc7748080b72963fe125b02c"},"downloads":-1,"filename":"jcvi-1.3.9-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"00a57442b8ca4d14a325b51e2af0fd16","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":951066,"upload_time":"2023-12-30T09:23:16","upload_time_iso_8601":"2023-12-30T09:23:16.198950Z","url":"https://files.pythonhosted.org/packages/12/79/423493aa03f6bd485dfd1219ad3a4cf816424ed518586a0c283bbd07b690/jcvi-1.3.9-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"cc838c960dfb1f4ce96c87388cd8edd11542c591a6e4aab3528376e1168641f4","md5":"8f3833b3b4b1594785615f792c59451c","sha256":"495940ed40e419a32c8b9dc9582fe64e233edf8d796fca71422223c3494ceaa8"},"downloads":-1,"filename":"jcvi-1.3.9.tar.gz","has_sig":false,"md5_digest":"8f3833b3b4b1594785615f792c59451c","packagetype":"sdist","python_version":"source","requires_python":null,"size":792318,"upload_time":"2023-12-30T09:23:19","upload_time_iso_8601":"2023-12-30T09:23:19.257313Z","url":"https://files.pythonhosted.org/packages/cc/83/8c960dfb1f4ce96c87388cd8edd11542c591a6e4aab3528376e1168641f4/jcvi-1.3.9.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.4.12":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.4.12/","requires_dist":["CrossMap","Wand","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","genomepy","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy","ortools","pybedtools","pyefd","pypdf","pytesseract","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.4.12","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"4b9fa77fd431bba691c740bfa933d64bb8408d26d3055ec4ea323a15048f5b96","md5":"7b24c29bbe10f4bc71c58861067d82e5","sha256":"f824a4118ff8e38461c0cd38871d7548836fd41a2f1c3d1cab374cab43c3f51e"},"downloads":-1,"filename":"jcvi-1.4.12-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"7b24c29bbe10f4bc71c58861067d82e5","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":972835,"upload_time":"2024-05-11T07:26:52","upload_time_iso_8601":"2024-05-11T07:26:52.798702Z","url":"https://files.pythonhosted.org/packages/4b/9f/a77fd431bba691c740bfa933d64bb8408d26d3055ec4ea323a15048f5b96/jcvi-1.4.12-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"47f60868e56cbd1a3cd4bba007bfb23c61ea2fb768cb8340242205bdf0ef4697","md5":"b941186fb7afd9a1451ff9933cab9eee","sha256":"e340f25979a8387756575803c7951deb2c4f2714a3ce091cba5794b8937a2506"},"downloads":-1,"filename":"jcvi-1.4.12.tar.gz","has_sig":false,"md5_digest":"b941186fb7afd9a1451ff9933cab9eee","packagetype":"sdist","python_version":"source","requires_python":null,"size":780219,"upload_time":"2024-05-11T07:26:55","upload_time_iso_8601":"2024-05-11T07:26:55.766932Z","url":"https://files.pythonhosted.org/packages/47/f6/0868e56cbd1a3cd4bba007bfb23c61ea2fb768cb8340242205bdf0ef4697/jcvi-1.4.12.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.4.17":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.4.17/","requires_dist":["CrossMap","Wand","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","genomepy","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy<2","ortools","pybedtools","pyefd","pypdf","pytesseract","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.4.17","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"0a0831b0076e7db67387d95fc0b23b5d1a4b1a31fcc4ecf1f21f6034593e9e23","md5":"69a2b78dc1a11efc55794f2b5f37af8d","sha256":"a6be31e02097338d68ba764c500bbb0032a4850cd0ba5d19d87ca24851100458"},"downloads":-1,"filename":"jcvi-1.4.17-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"69a2b78dc1a11efc55794f2b5f37af8d","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":967649,"upload_time":"2024-06-18T16:01:59","upload_time_iso_8601":"2024-06-18T16:01:59.292558Z","url":"https://files.pythonhosted.org/packages/0a/08/31b0076e7db67387d95fc0b23b5d1a4b1a31fcc4ecf1f21f6034593e9e23/jcvi-1.4.17-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"e643e4c9574ac782e4c4baae7072113e7c120c0fe722becc60b1052a1f8cf8d6","md5":"eb4e0147bbe63c08c652f9727cdba073","sha256":"71593f7fc889c2ab1c00a3b26229854a90c13c15c4a5893f6a46a8912a06f33a"},"downloads":-1,"filename":"jcvi-1.4.17.tar.gz","has_sig":false,"md5_digest":"eb4e0147bbe63c08c652f9727cdba073","packagetype":"sdist","python_version":"source","requires_python":null,"size":781113,"upload_time":"2024-06-18T16:02:04","upload_time_iso_8601":"2024-06-18T16:02:04.163477Z","url":"https://files.pythonhosted.org/packages/e6/43/e4c9574ac782e4c4baae7072113e7c120c0fe722becc60b1052a1f8cf8d6/jcvi-1.4.17.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.4.18":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.4.18/","requires_dist":["CrossMap","Wand","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","genomepy","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy<2","ortools","pybedtools","pyefd","pypdf","pytesseract","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.4.18","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"6183e192d63591c5137cf8b1392c4df11fd4556ad932c087d86d843e39741635","md5":"d53f32d513ceedbdba081812e28813f5","sha256":"610943f15c002f47f4420855d90d14558fcbad25bbdf31f50fc5f38550ac6701"},"downloads":-1,"filename":"jcvi-1.4.18-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"d53f32d513ceedbdba081812e28813f5","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":967701,"upload_time":"2024-06-28T13:24:10","upload_time_iso_8601":"2024-06-28T13:24:10.288132Z","url":"https://files.pythonhosted.org/packages/61/83/e192d63591c5137cf8b1392c4df11fd4556ad932c087d86d843e39741635/jcvi-1.4.18-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"51cd48641122d39f90fa03cd7b84075ad61c11d74c594011a2978af14a35a201","md5":"4b8276b5ac37de6102ae4eb0d55a149f","sha256":"99a891e765dd3d95e0d740e1eece58d187aada5724d6a2950edb624f6fd762c0"},"downloads":-1,"filename":"jcvi-1.4.18.tar.gz","has_sig":false,"md5_digest":"4b8276b5ac37de6102ae4eb0d55a149f","packagetype":"sdist","python_version":"source","requires_python":null,"size":781163,"upload_time":"2024-06-28T13:24:16","upload_time_iso_8601":"2024-06-28T13:24:16.205171Z","url":"https://files.pythonhosted.org/packages/51/cd/48641122d39f90fa03cd7b84075ad61c11d74c594011a2978af14a35a201/jcvi-1.4.18.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.4.19":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.4.19/","requires_dist":["CrossMap","Wand","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","genomepy","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy<2","ortools","pybedtools","pyefd","pypdf","pytesseract","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.4.19","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"c2cfefb5f23c2117015e9441966cef86e54e738fa8497ae81762afbc18751b74","md5":"121095b55f6a3b847183e5805b807679","sha256":"e7b4c7a494ca44ba5c1dc92fa27e29d311c2a4775aaa490b492e3ee031ce8b9d"},"downloads":-1,"filename":"jcvi-1.4.19-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"121095b55f6a3b847183e5805b807679","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":968030,"upload_time":"2024-07-10T10:47:41","upload_time_iso_8601":"2024-07-10T10:47:41.589288Z","url":"https://files.pythonhosted.org/packages/c2/cf/efb5f23c2117015e9441966cef86e54e738fa8497ae81762afbc18751b74/jcvi-1.4.19-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"f568d5312eea894c95b762403e2025d0797fe93651563fc01e7e6542058c99af","md5":"0243725d7e90482403c2752be58e251f","sha256":"7df7adfb1bc34eb1ae3166d973995c6411e8ce5232e31a54a48c85acfb30d200"},"downloads":-1,"filename":"jcvi-1.4.19.tar.gz","has_sig":false,"md5_digest":"0243725d7e90482403c2752be58e251f","packagetype":"sdist","python_version":"source","requires_python":null,"size":781445,"upload_time":"2024-07-10T10:47:45","upload_time_iso_8601":"2024-07-10T10:47:45.381225Z","url":"https://files.pythonhosted.org/packages/f5/68/d5312eea894c95b762403e2025d0797fe93651563fc01e7e6542058c99af/jcvi-1.4.19.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.4.2":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":"","license":"BSD","maintainer":"","maintainer_email":"","name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.4.2/","requires_dist":["CrossMap","PyPDF2","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","genomepy","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy","ortools","pybedtools","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":"","summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.4.2","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"f4db4d65c0b37cac4501db79c438b5c82738d6f609709a94a1203ac9f695b945","md5":"11ff57bc5ea3cbe5d497d9242534ec7b","sha256":"1d0a077f6c53a415e462f4e12748ab49d72ac43c63bb1bc06395535cf624abc9"},"downloads":-1,"filename":"jcvi-1.4.2-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"11ff57bc5ea3cbe5d497d9242534ec7b","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":951200,"upload_time":"2024-03-01T06:50:35","upload_time_iso_8601":"2024-03-01T06:50:35.184729Z","url":"https://files.pythonhosted.org/packages/f4/db/4d65c0b37cac4501db79c438b5c82738d6f609709a94a1203ac9f695b945/jcvi-1.4.2-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"b101b730e94b778d678e7244ee6d77ca9aaa6871f2841b4263fc937cae211af6","md5":"dbc52f88c92795d688c94aa4ae7d7f0f","sha256":"a1b1e4153a96e2a3257cf99f98cb60290f2aa60a8dff4ec82cb56de7a1da7ef3"},"downloads":-1,"filename":"jcvi-1.4.2.tar.gz","has_sig":false,"md5_digest":"dbc52f88c92795d688c94aa4ae7d7f0f","packagetype":"sdist","python_version":"source","requires_python":null,"size":792442,"upload_time":"2024-03-01T06:50:37","upload_time_iso_8601":"2024-03-01T06:50:37.764275Z","url":"https://files.pythonhosted.org/packages/b1/01/b730e94b778d678e7244ee6d77ca9aaa6871f2841b4263fc937cae211af6/jcvi-1.4.2.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.4.20":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.4.20/","requires_dist":["CrossMap","Wand","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","genomepy","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy<2","ortools","pybedtools","pyefd","pypdf","pytesseract","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.4.20","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"ac504276b4f339e9c8a827ce6c4c810c48e49d071b8352cb1c87fbd10ca3b1fd","md5":"c4a8c5ab346f451b5804b02184e29af3","sha256":"140c633a8d17f6c2e29e95b8b4a4bb613a240141243234521205585ef7b6322e"},"downloads":-1,"filename":"jcvi-1.4.20-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"c4a8c5ab346f451b5804b02184e29af3","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":969258,"upload_time":"2024-07-22T02:08:14","upload_time_iso_8601":"2024-07-22T02:08:14.312685Z","url":"https://files.pythonhosted.org/packages/ac/50/4276b4f339e9c8a827ce6c4c810c48e49d071b8352cb1c87fbd10ca3b1fd/jcvi-1.4.20-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"6e4d5fc0a5dbf655d6dbff6a2da8ce6ba48ebccf895013115ea73d642eeea681","md5":"93d0f84270a879fa8fa646f2a4505684","sha256":"5740cdf291f308562fc54f1a93df70974837ed10640905e750436ec5e3b01b11"},"downloads":-1,"filename":"jcvi-1.4.20.tar.gz","has_sig":false,"md5_digest":"93d0f84270a879fa8fa646f2a4505684","packagetype":"sdist","python_version":"source","requires_python":null,"size":782704,"upload_time":"2024-07-22T02:08:17","upload_time_iso_8601":"2024-07-22T02:08:17.058265Z","url":"https://files.pythonhosted.org/packages/6e/4d/5fc0a5dbf655d6dbff6a2da8ce6ba48ebccf895013115ea73d642eeea681/jcvi-1.4.20.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.4.21":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.4.21/","requires_dist":["CrossMap","Wand","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","genomepy","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy<2","ortools","pybedtools","pyefd","pypdf","pytesseract","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.4.21","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"a93bc3ec992d2cfdc12dabf060b00988380b90b9c646fa0736ed6cf036e23a28","md5":"0df89afedad7527b06a74bb831938e5f","sha256":"f84275e310c74531a0beb0de56f7ce55fb9243d07cf0cdd96397d76229d76f67"},"downloads":-1,"filename":"jcvi-1.4.21-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"0df89afedad7527b06a74bb831938e5f","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":969261,"upload_time":"2024-07-24T23:01:51","upload_time_iso_8601":"2024-07-24T23:01:51.513602Z","url":"https://files.pythonhosted.org/packages/a9/3b/c3ec992d2cfdc12dabf060b00988380b90b9c646fa0736ed6cf036e23a28/jcvi-1.4.21-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"88340591f71fdc227e2f7e9c6322e38b0e2200a217b1eb6f1793008eb08e4ef5","md5":"2814be65ec9907e4d463651286cd7007","sha256":"79268bfc259a1b6d3aa8108c0ccd391a0a7e74e396dd2769b189459a0a2de055"},"downloads":-1,"filename":"jcvi-1.4.21.tar.gz","has_sig":false,"md5_digest":"2814be65ec9907e4d463651286cd7007","packagetype":"sdist","python_version":"source","requires_python":null,"size":782749,"upload_time":"2024-07-24T23:01:53","upload_time_iso_8601":"2024-07-24T23:01:53.924739Z","url":"https://files.pythonhosted.org/packages/88/34/0591f71fdc227e2f7e9c6322e38b0e2200a217b1eb6f1793008eb08e4ef5/jcvi-1.4.21.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.4.22":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.4.22/","requires_dist":["CrossMap","Wand","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","genomepy","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy<2","ortools","pybedtools","pyefd","pypdf","pytesseract","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.4.22","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"923c4e4c547eeb97e70c0da1a3bbe0da184e46428ae50cf547e5171d52c3cb7c","md5":"3e952ca8ba313eaf1849fa4f0abb27af","sha256":"048cbe9865dd888cea99e86cf6fd98e6b6cd3904ed4bd01606922815e3091ece"},"downloads":-1,"filename":"jcvi-1.4.22-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"3e952ca8ba313eaf1849fa4f0abb27af","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":967121,"upload_time":"2024-09-06T01:58:15","upload_time_iso_8601":"2024-09-06T01:58:15.752097Z","url":"https://files.pythonhosted.org/packages/92/3c/4e4c547eeb97e70c0da1a3bbe0da184e46428ae50cf547e5171d52c3cb7c/jcvi-1.4.22-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"5bd5de1901195165cf4fd8891e37684cf5ab4ed4cf85644dbc6b34e19b63a318","md5":"b53f2166483e452fb5b40722dac80b19","sha256":"ed6a8a6300be65392e201a9dcaa393f2a7a0966e9ab060dfe5d63ecda9e9ee7e"},"downloads":-1,"filename":"jcvi-1.4.22.tar.gz","has_sig":false,"md5_digest":"b53f2166483e452fb5b40722dac80b19","packagetype":"sdist","python_version":"source","requires_python":null,"size":783891,"upload_time":"2024-09-06T01:58:18","upload_time_iso_8601":"2024-09-06T01:58:18.043382Z","url":"https://files.pythonhosted.org/packages/5b/d5/de1901195165cf4fd8891e37684cf5ab4ed4cf85644dbc6b34e19b63a318/jcvi-1.4.22.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.4.23":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.4.23/","requires_dist":["CrossMap","Wand","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","genomepy","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy<2","ortools","pybedtools","pyefd","pypdf","pytesseract","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.4.23","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"a262eeb53a73c207aecc49c36f2d734b11be318b94bf886b436e90dbe295ee7d","md5":"f55a2ed245445de8638cb893724d56ca","sha256":"0f3f56370b90f1d6e203ce7ee41a5947f788e09fe9a0f667fe58db0e72cf7053"},"downloads":-1,"filename":"jcvi-1.4.23-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"f55a2ed245445de8638cb893724d56ca","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":941723,"upload_time":"2024-10-16T04:08:51","upload_time_iso_8601":"2024-10-16T04:08:51.509757Z","url":"https://files.pythonhosted.org/packages/a2/62/eeb53a73c207aecc49c36f2d734b11be318b94bf886b436e90dbe295ee7d/jcvi-1.4.23-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"911411320d348bdacf10471bfa82c4437eb9d4a59c67597b0b98317e75f4e700","md5":"f0661599b9c1b5597bae72770f08e339","sha256":"38cfdf0125d239d12761eac87a26a28dd185ee0631dbf44e7d4e1c531a317d95"},"downloads":-1,"filename":"jcvi-1.4.23.tar.gz","has_sig":false,"md5_digest":"f0661599b9c1b5597bae72770f08e339","packagetype":"sdist","python_version":"source","requires_python":null,"size":783991,"upload_time":"2024-10-16T04:08:53","upload_time_iso_8601":"2024-10-16T04:08:53.721252Z","url":"https://files.pythonhosted.org/packages/91/14/11320d348bdacf10471bfa82c4437eb9d4a59c67597b0b98317e75f4e700/jcvi-1.4.23.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]},"1.4.5":{"info":{"author":"Haibao Tang, Vivek Krishnakumar, Jingping Li","author_email":"tanghaibao@gmail.com","bugtrack_url":null,"classifiers":["Development Status :: 4 - Beta","Intended Audience :: Science/Research","License :: OSI Approved :: BSD License","Programming Language :: Python","Programming Language :: Python :: 3","Topic :: Scientific/Engineering :: Bio-Informatics"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"http://github.com/tanghaibao/jcvi","keywords":null,"license":"BSD","maintainer":null,"maintainer_email":null,"name":"jcvi","package_url":"https://pypi.org/project/jcvi/","platform":null,"project_url":"https://pypi.org/project/jcvi/","project_urls":{"Homepage":"http://github.com/tanghaibao/jcvi"},"provides_extra":null,"release_url":"https://pypi.org/project/jcvi/1.4.5/","requires_dist":["CrossMap","PyPDF2","biopython","boto3","brewer2mpl","deap","ete3","ftpretty","gffutils","goatools","genomepy","graphviz","jinja2","matplotlib","more-itertools","natsort","networkx","numpy","ortools","pybedtools","pyefd","rich","scikit-image","scipy","seaborn","webcolors"],"requires_python":null,"summary":"Python utility libraries on genome assembly, annotation and comparative genomics","version":"1.4.5","yanked":false,"yanked_reason":null},"last_serial":25502129,"urls":[{"comment_text":"","digests":{"blake2b_256":"088320836414a47dfcfb98b29d20f0b341a96aedecac8981a738d0ff196f03a8","md5":"4f529d70a6d2fce65de86e59fe7ffb41","sha256":"d3fd0d65e8d4d92046ae26267294e31243bf3b780f288119294eb4aad2032e7d"},"downloads":-1,"filename":"jcvi-1.4.5-cp310-cp310-macosx_11_0_arm64.whl","has_sig":false,"md5_digest":"4f529d70a6d2fce65de86e59fe7ffb41","packagetype":"bdist_wheel","python_version":"cp310","requires_python":null,"size":972169,"upload_time":"2024-04-29T06:37:32","upload_time_iso_8601":"2024-04-29T06:37:32.063065Z","url":"https://files.pythonhosted.org/packages/08/83/20836414a47dfcfb98b29d20f0b341a96aedecac8981a738d0ff196f03a8/jcvi-1.4.5-cp310-cp310-macosx_11_0_arm64.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"3bc78f87e09c1bc53218c88e3cbd40b736a113062e49e0ba98afc3c204ac19b0","md5":"c63292f5c0ff8be776e7ed0efec4ebc1","sha256":"2b40afa0adc1528804dcac1caedc5972d00082dc55169d3971bf6619859fdbc8"},"downloads":-1,"filename":"jcvi-1.4.5.tar.gz","has_sig":false,"md5_digest":"c63292f5c0ff8be776e7ed0efec4ebc1","packagetype":"sdist","python_version":"source","requires_python":null,"size":791834,"upload_time":"2024-04-29T06:37:34","upload_time_iso_8601":"2024-04-29T06:37:34.951503Z","url":"https://files.pythonhosted.org/packages/3b/c7/8f87e09c1bc53218c88e3cbd40b736a113062e49e0ba98afc3c204ac19b0/jcvi-1.4.5.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]}}