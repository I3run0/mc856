{"0.1.0b1":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":[],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b1/","requires_dist":null,"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b1","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"b0b32c1921d9a77d7057b3c9bafd6200d47200505b17f0023a23b74b6c089a4f","md5":"8884776ecfb7946caa49161e867ec730","sha256":"fceededd00dd159ad2d7e7449096e672a0c2b32cef5d48ff1009584b3acc5ae5"},"downloads":-1,"filename":"vyper-0.1.0b1.tar.gz","has_sig":false,"md5_digest":"8884776ecfb7946caa49161e867ec730","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":62164,"upload_time":"2018-08-22T15:54:57","upload_time_iso_8601":"2018-08-22T15:54:57.824915Z","url":"https://files.pythonhosted.org/packages/b0/b3/2c1921d9a77d7057b3c9bafd6200d47200505b17f0023a23b74b6c089a4f/vyper-0.1.0b1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b10":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b10/","requires_dist":["pycryptodome (<4,>=3.5.1)","flake8 (<4,>=3.7) ; extra == 'lint'","flake8-bugbear (==18.8.0) ; extra == 'lint'","isort (<5,>=4.2.15) ; extra == 'lint'","mypy (==0.701) ; extra == 'lint'","pytest (>=3.6) ; extra == 'test'","pytest-cov (==2.4.0) ; extra == 'test'","coveralls[yaml] (==1.6.0) ; extra == 'test'","pytest-xdist (==1.18.1) ; extra == 'test'","py-evm (==0.2.0a39) ; extra == 'test'","eth-tester (==0.1.0b37) ; extra == 'test'","web3 (==5.0.0a6) ; extra == 'test'","tox (<4,>=3.7) ; extra == 'test'","hypothesis (==4.11.7) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b10","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"4e0eefb3c51ec62d5febcde9fab8dfcd032633f03d7b474342a5c890f2f1463f","md5":"bde75d238a05fe87613c6c8751c76f7e","sha256":"023db460e673f79ff9ddc606a59b961664edbb63d315b1e6837afb2c3326fff2"},"downloads":-1,"filename":"vyper-0.1.0b10-py3-none-any.whl","has_sig":false,"md5_digest":"bde75d238a05fe87613c6c8751c76f7e","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":119809,"upload_time":"2019-05-24T11:09:11","upload_time_iso_8601":"2019-05-24T11:09:11.753435Z","url":"https://files.pythonhosted.org/packages/4e/0e/efb3c51ec62d5febcde9fab8dfcd032633f03d7b474342a5c890f2f1463f/vyper-0.1.0b10-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"9a09692d9ccdf56cae38f8076170b50736ca6be9607429ebdcfbd72f67a60719","md5":"9bbad934d3f72eaf663c37630f65fa3c","sha256":"95901053c64c61ab5ac5b27af0bd0b43c970c87761202e8a4a9320d912d2cc3d"},"downloads":-1,"filename":"vyper-0.1.0b10.tar.gz","has_sig":false,"md5_digest":"9bbad934d3f72eaf663c37630f65fa3c","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":100372,"upload_time":"2019-05-24T11:09:14","upload_time_iso_8601":"2019-05-24T11:09:14.686506Z","url":"https://files.pythonhosted.org/packages/9a/09/692d9ccdf56cae38f8076170b50736ca6be9607429ebdcfbd72f67a60719/vyper-0.1.0b10.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b11":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b11/","requires_dist":["pycryptodome (<4,>=3.5.1)","flake8 (<4,>=3.7) ; extra == 'lint'","flake8-bugbear (==18.8.0) ; extra == 'lint'","isort (<5,>=4.2.15) ; extra == 'lint'","mypy (==0.701) ; extra == 'lint'","pytest (>=3.6) ; extra == 'test'","pytest-cov (==2.4.0) ; extra == 'test'","coveralls[yaml] (==1.6.0) ; extra == 'test'","pytest-xdist (==1.18.1) ; extra == 'test'","py-evm (==0.2.0a42) ; extra == 'test'","eth-tester (==0.1.0b39) ; extra == 'test'","eth-abi (==2.0.0b9) ; extra == 'test'","web3 (==5.0.0b2) ; extra == 'test'","tox (<4,>=3.7) ; extra == 'test'","hypothesis (==4.11.7) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b11","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"338cc0bc2a901b0e2fa472a876a451f81a02743e666a64bc9033307cfd28b79b","md5":"c12be73799360a6d3770ab135a6567be","sha256":"19b3e5dd8d780e6fc73ff540716ffad1846088b36fbc60aeccf9c1b565714ba7"},"downloads":-1,"filename":"vyper-0.1.0b11-py3-none-any.whl","has_sig":false,"md5_digest":"c12be73799360a6d3770ab135a6567be","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":124092,"upload_time":"2019-07-23T17:37:48","upload_time_iso_8601":"2019-07-23T17:37:48.275250Z","url":"https://files.pythonhosted.org/packages/33/8c/c0bc2a901b0e2fa472a876a451f81a02743e666a64bc9033307cfd28b79b/vyper-0.1.0b11-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"297ead75b008effa93cd8c10b06ea1c68f68f38384b3f0ef9f1a321c5924bf31","md5":"2d138c0e1330f3a3f5f370b99ea6b6ef","sha256":"9defca4ed13886baa86cc9cdc435e7781f171cc0d26522bb08304017b5663868"},"downloads":-1,"filename":"vyper-0.1.0b11.tar.gz","has_sig":false,"md5_digest":"2d138c0e1330f3a3f5f370b99ea6b6ef","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":104230,"upload_time":"2019-07-23T17:37:51","upload_time_iso_8601":"2019-07-23T17:37:51.245886Z","url":"https://files.pythonhosted.org/packages/29/7e/ad75b008effa93cd8c10b06ea1c68f68f38384b3f0ef9f1a321c5924bf31/vyper-0.1.0b11.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b12":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b12/","requires_dist":["asttokens (==1.1.13)","pycryptodome (<4,>=3.5.1)","flake8 (<4,>=3.7) ; extra == 'lint'","flake8-bugbear (==18.8.0) ; extra == 'lint'","isort (<5,>=4.2.15) ; extra == 'lint'","mypy (==0.701) ; extra == 'lint'","pytest (>=3.6) ; extra == 'test'","pytest-cov (==2.4.0) ; extra == 'test'","coveralls[yaml] (==1.6.0) ; extra == 'test'","pytest-xdist (==1.18.1) ; extra == 'test'","py-evm (==0.2.0a42) ; extra == 'test'","eth-tester (==0.1.0b39) ; extra == 'test'","eth-abi (==2.0.0b9) ; extra == 'test'","web3 (==5.0.0b2) ; extra == 'test'","tox (<4,>=3.7) ; extra == 'test'","hypothesis (==4.11.7) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b12","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"f0c6d8da3fa0ff15cebe6bc277286b4df293a28d956106480b08332559106220","md5":"87075130fbaacb815a5ebae59cb583cc","sha256":"51c57d8cf7324bfe3b24546f9911b553cdd1c0e6186cf45b5fb2dd5085d264d6"},"downloads":-1,"filename":"vyper-0.1.0b12-py3-none-any.whl","has_sig":false,"md5_digest":"87075130fbaacb815a5ebae59cb583cc","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":127701,"upload_time":"2019-08-28T13:14:21","upload_time_iso_8601":"2019-08-28T13:14:21.063395Z","url":"https://files.pythonhosted.org/packages/f0/c6/d8da3fa0ff15cebe6bc277286b4df293a28d956106480b08332559106220/vyper-0.1.0b12-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"58d6a3920698d7793fed31dd9b79d9bd54c936b5a80e6fefb0a724d4edd5d2d3","md5":"f309a24981dd5a58b8a4a3cb4cfc5c80","sha256":"0f239b4a14f0d0055adedbee7d342d989308b3b34d13ff01c4877b934e160c98"},"downloads":-1,"filename":"vyper-0.1.0b12.tar.gz","has_sig":false,"md5_digest":"f309a24981dd5a58b8a4a3cb4cfc5c80","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":105436,"upload_time":"2019-08-28T13:14:23","upload_time_iso_8601":"2019-08-28T13:14:23.681710Z","url":"https://files.pythonhosted.org/packages/58/d6/a3920698d7793fed31dd9b79d9bd54c936b5a80e6fefb0a724d4edd5d2d3/vyper-0.1.0b12.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b13":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b13/","requires_dist":["asttokens (==1.1.13)","pycryptodome (<4,>=3.5.1)","flake8 (<4,>=3.7) ; extra == 'lint'","flake8-bugbear (==18.8.0) ; extra == 'lint'","isort (<5,>=4.2.15) ; extra == 'lint'","mypy (==0.701) ; extra == 'lint'","pytest (>=3.6) ; extra == 'test'","pytest-cov (==2.4.0) ; extra == 'test'","coveralls[yaml] (==1.6.0) ; extra == 'test'","pytest-xdist (==1.18.1) ; extra == 'test'","py-evm (==0.2.0a42) ; extra == 'test'","eth-tester (==0.1.0b39) ; extra == 'test'","eth-abi (==2.0.0b9) ; extra == 'test'","web3 (==5.0.0b2) ; extra == 'test'","tox (<4,>=3.7) ; extra == 'test'","hypothesis (==4.11.7) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b13","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"0b49eeff25137a05240bffb176e9577ea3b7407cec08ae10881c15574c46438f","md5":"55ced252eea47404c6f861c69761c975","sha256":"bb14a3f49cc02cf93b22d8d74dc7e4196cbff6e637366ebdeb1087b085d45f97"},"downloads":-1,"filename":"vyper-0.1.0b13-py3-none-any.whl","has_sig":false,"md5_digest":"55ced252eea47404c6f861c69761c975","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":133439,"upload_time":"2019-09-27T18:00:58","upload_time_iso_8601":"2019-09-27T18:00:58.255461Z","url":"https://files.pythonhosted.org/packages/0b/49/eeff25137a05240bffb176e9577ea3b7407cec08ae10881c15574c46438f/vyper-0.1.0b13-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"0efa1ea4dad06df87eecdc59f467e0006ec5969791dc2d3fd1e97a89e2a8aadf","md5":"f0f8e2d5b4537703652e949f04eed564","sha256":"b0527d188b9e84020da1f9f66d9d06b756c6cef5e0e395ea30e584fdba94c959"},"downloads":-1,"filename":"vyper-0.1.0b13.tar.gz","has_sig":false,"md5_digest":"f0f8e2d5b4537703652e949f04eed564","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":108408,"upload_time":"2019-09-27T18:01:01","upload_time_iso_8601":"2019-09-27T18:01:01.653659Z","url":"https://files.pythonhosted.org/packages/0e/fa/1ea4dad06df87eecdc59f467e0006ec5969791dc2d3fd1e97a89e2a8aadf/vyper-0.1.0b13.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b14":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b14/","requires_dist":["asttokens (==1.1.13)","pycryptodome (<4,>=3.5.1)","flake8 (<4,>=3.7) ; extra == 'lint'","flake8-bugbear (<20,>=19.8.0) ; extra == 'lint'","isort (<5,>=4.2.15) ; extra == 'lint'","mypy (<1,>=0.740) ; extra == 'lint'","pytest (<6,>=5.2.0) ; extra == 'test'","pytest-cov (<3,>=2.8.1) ; extra == 'test'","coveralls[yaml] (<2,>=1.8.2) ; extra == 'test'","pytest-xdist (<2,>=1.30.0) ; extra == 'test'","eth-tester[py-evm] (<0.4,>=0.3.0b1) ; extra == 'test'","web3 (<5.3.0,>=5.2.0) ; extra == 'test'","tox (<4,>=3.7) ; extra == 'test'","hypothesis (<5,>=4.41.3) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b14","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"4f65b30d19cc27ee9a8aa499e24b5cbbb9dadeceef934792025f32364282f6a8","md5":"381ecb24ee53e1d79112c962d487a20d","sha256":"2416978e2e6acc4510afb1aed464bd2fbb72ed7b981005677fb8fd6f63e969ae"},"downloads":-1,"filename":"vyper-0.1.0b14-py3-none-any.whl","has_sig":false,"md5_digest":"381ecb24ee53e1d79112c962d487a20d","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":133638,"upload_time":"2019-11-13T01:40:42","upload_time_iso_8601":"2019-11-13T01:40:42.672637Z","url":"https://files.pythonhosted.org/packages/4f/65/b30d19cc27ee9a8aa499e24b5cbbb9dadeceef934792025f32364282f6a8/vyper-0.1.0b14-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"194b789a2dee802039ff4c3e34be3628f68706cb2aac18917604bd147a001d05","md5":"b40183f63a1010102f5782d0f9fae312","sha256":"cb1e49322bcd46e576350b5fe34c1893fb68bfa3ef12fce947a2d88b7bce62c8"},"downloads":-1,"filename":"vyper-0.1.0b14.tar.gz","has_sig":false,"md5_digest":"b40183f63a1010102f5782d0f9fae312","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":108578,"upload_time":"2019-11-13T01:40:44","upload_time_iso_8601":"2019-11-13T01:40:44.637313Z","url":"https://files.pythonhosted.org/packages/19/4b/789a2dee802039ff4c3e34be3628f68706cb2aac18917604bd147a001d05/vyper-0.1.0b14.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b15":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b15/","requires_dist":["asttokens (==2.0.3)","pycryptodome (<4,>=3.5.1)","flake8 (<4,>=3.7) ; extra == 'lint'","flake8-bugbear (<20,>=19.8.0) ; extra == 'lint'","flake8-use-fstring (<2.0.0,>=1.0.0) ; extra == 'lint'","isort (<5,>=4.2.15) ; extra == 'lint'","mypy (<1,>=0.740) ; extra == 'lint'","pytest (<6,>=5.2.0) ; extra == 'test'","pytest-cov (<3,>=2.8.1) ; extra == 'test'","coveralls[yaml] (<2,>=1.8.2) ; extra == 'test'","pytest-xdist (<2,>=1.30.0) ; extra == 'test'","eth-tester[py-evm] (<0.4,>=0.3.0b1) ; extra == 'test'","web3 (<5.3.0,>=5.2.0) ; extra == 'test'","tox (<4,>=3.7) ; extra == 'test'","lark-parser (<1,>=0.7.8) ; extra == 'test'","hypothesis[lark] (<5,>=4.53.2) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.1.0b15","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"3990c988cd547003e89dd3e9ac092e0bd1733a370357f9ef45f22d8b052ebc2a","md5":"cd0234c282d7586eaa3156901e08d51b","sha256":"8ed886c0ed50fc3ded146920291b9088a2a7e771b3d6d0664d90b3328237acbc"},"downloads":-1,"filename":"vyper-0.1.0b15-py3-none-any.whl","has_sig":false,"md5_digest":"cd0234c282d7586eaa3156901e08d51b","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":146986,"upload_time":"2020-01-07T17:44:21","upload_time_iso_8601":"2020-01-07T17:44:21.655433Z","url":"https://files.pythonhosted.org/packages/39/90/c988cd547003e89dd3e9ac092e0bd1733a370357f9ef45f22d8b052ebc2a/vyper-0.1.0b15-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"1f7ed3e6b5757d106cbdf3121859c7d2d63d19ff814dd77f9f7720829bc72416","md5":"1f0f8c4e8e00ab682b07c67ac13c6a04","sha256":"7ab83f5aecce78fec3e99b8d44e17a9770c0d667102e32706017cd181d31267c"},"downloads":-1,"filename":"vyper-0.1.0b15.tar.gz","has_sig":false,"md5_digest":"1f0f8c4e8e00ab682b07c67ac13c6a04","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":118970,"upload_time":"2020-01-07T17:44:23","upload_time_iso_8601":"2020-01-07T17:44:23.419013Z","url":"https://files.pythonhosted.org/packages/1f/7e/d3e6b5757d106cbdf3121859c7d2d63d19ff814dd77f9f7720829bc72416/vyper-0.1.0b15.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b16":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b16/","requires_dist":["asttokens (==2.0.3)","pycryptodome (<4,>=3.5.1)","flake8 (<4,>=3.7) ; extra == 'lint'","flake8-bugbear (<20,>=19.8.0) ; extra == 'lint'","flake8-use-fstring (<2.0.0,>=1.0.0) ; extra == 'lint'","isort (<5,>=4.2.15) ; extra == 'lint'","mypy (<1,>=0.740) ; extra == 'lint'","pytest (<6,>=5.2.0) ; extra == 'test'","pytest-cov (<3,>=2.8.1) ; extra == 'test'","coveralls[yaml] (<2,>=1.8.2) ; extra == 'test'","pytest-xdist (<2,>=1.30.0) ; extra == 'test'","eth-tester[py-evm] (<0.4,>=0.3.0b1) ; extra == 'test'","web3 (<5.3.0,>=5.2.0) ; extra == 'test'","tox (<4,>=3.7) ; extra == 'test'","lark-parser (<1,>=0.7.8) ; extra == 'test'","hypothesis[lark] (<5,>=4.53.2) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.1.0b16","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"d30a0ed3e3fc0c185e6948802f6f15438a934bfe1afef40fa8ef08f60b26a8d2","md5":"aa05f475570d2c5ba74887dfed6b1e8b","sha256":"c78728cd9f2e7810e4b7c32df0e8fedaea09fb611b16475d19b680cdfde5ce1b"},"downloads":-1,"filename":"vyper-0.1.0b16-py3-none-any.whl","has_sig":false,"md5_digest":"aa05f475570d2c5ba74887dfed6b1e8b","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":146977,"upload_time":"2020-01-09T23:43:53","upload_time_iso_8601":"2020-01-09T23:43:53.283849Z","url":"https://files.pythonhosted.org/packages/d3/0a/0ed3e3fc0c185e6948802f6f15438a934bfe1afef40fa8ef08f60b26a8d2/vyper-0.1.0b16-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"057c4547a4560a57e983a6db740c871faed76587d1a073582b6a7e39efcce320","md5":"56fa2a66e7852a4675bfede551e29c34","sha256":"d86e6bcc85e9e7e2c633248690aa76fc7ff68cd6eb55261ad04a1aaa3ca9fe62"},"downloads":-1,"filename":"vyper-0.1.0b16.tar.gz","has_sig":false,"md5_digest":"56fa2a66e7852a4675bfede551e29c34","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":121698,"upload_time":"2020-01-09T23:43:55","upload_time_iso_8601":"2020-01-09T23:43:55.358262Z","url":"https://files.pythonhosted.org/packages/05/7c/4547a4560a57e983a6db740c871faed76587d1a073582b6a7e39efcce320/vyper-0.1.0b16.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b17":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b17/","requires_dist":["asttokens (==2.0.3)","pycryptodome (<4,>=3.5.1)","flake8 (<4,>=3.7) ; extra == 'lint'","flake8-bugbear (<20,>=19.8.0) ; extra == 'lint'","flake8-use-fstring (<2.0.0,>=1.0.0) ; extra == 'lint'","isort (<5,>=4.2.15) ; extra == 'lint'","mypy (<1,>=0.740) ; extra == 'lint'","pytest (<6,>=5.2.0) ; extra == 'test'","pytest-cov (<3,>=2.8.1) ; extra == 'test'","coveralls[yaml] (<2,>=1.8.2) ; extra == 'test'","pytest-xdist (<2,>=1.30.0) ; extra == 'test'","eth-tester[py-evm] (<0.4,>=0.3.0b1) ; extra == 'test'","web3 (<5.3.0,>=5.2.0) ; extra == 'test'","tox (<4,>=3.7) ; extra == 'test'","lark-parser (<1,>=0.7.8) ; extra == 'test'","hypothesis[lark] (<5,>=4.53.2) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.1.0b17","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"90635b06572d2b37c523112cc6f4fbd4fc40b2e251e2de6d488d3d98b6e73af5","md5":"fb2b15d39ec01a571f84ca0fca7e819e","sha256":"87ce8d6c45c0dd179b4ae074e393f334303f0e71862dfa6a22a2a55d77efc57f"},"downloads":-1,"filename":"vyper-0.1.0b17-py3-none-any.whl","has_sig":false,"md5_digest":"fb2b15d39ec01a571f84ca0fca7e819e","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":152970,"upload_time":"2020-03-24T14:24:58","upload_time_iso_8601":"2020-03-24T14:24:58.411082Z","url":"https://files.pythonhosted.org/packages/90/63/5b06572d2b37c523112cc6f4fbd4fc40b2e251e2de6d488d3d98b6e73af5/vyper-0.1.0b17-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"e7ad255f7ba1c6b8982d6272a25bbf2c41c13216fa048df3e63c9b9109529df0","md5":"8816539f5fe559e5eb38ece72b672458","sha256":"1956776a483ea0c4b4fd99a76766136183272986f649910b25d17909212eccad"},"downloads":-1,"filename":"vyper-0.1.0b17.tar.gz","has_sig":false,"md5_digest":"8816539f5fe559e5eb38ece72b672458","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":123617,"upload_time":"2020-03-24T14:24:59","upload_time_iso_8601":"2020-03-24T14:24:59.435130Z","url":"https://files.pythonhosted.org/packages/e7/ad/255f7ba1c6b8982d6272a25bbf2c41c13216fa048df3e63c9b9109529df0/vyper-0.1.0b17.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b2":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":[],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b2/","requires_dist":null,"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b2","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"1a20e110f3988c515034c4ef8cc0d6ddfe06c8981f27a82d5bbb66e7de878786","md5":"7b9541d03726f84a8827235ea0b434ea","sha256":"d39eb2e1fe5bc89b418fa78e49e1c9785891d38fabffe70cfa367e7bf8ced0c9"},"downloads":-1,"filename":"vyper-0.1.0b2-py3-none-any.whl","has_sig":false,"md5_digest":"7b9541d03726f84a8827235ea0b434ea","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":69381,"upload_time":"2018-08-22T16:16:06","upload_time_iso_8601":"2018-08-22T16:16:06.624799Z","url":"https://files.pythonhosted.org/packages/1a/20/e110f3988c515034c4ef8cc0d6ddfe06c8981f27a82d5bbb66e7de878786/vyper-0.1.0b2-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"d803b2a41d7ee2e96a05d277b99c5794d7689437a01b8e4b5ac21f7fa8055e35","md5":"260c774e23ef3f83b4db0b5f7dcceb63","sha256":"14b4e169dbc4f3cc0573c04e21260137bc9546ffb7e7bed4d9effa6b491407bc"},"downloads":-1,"filename":"vyper-0.1.0b2.tar.gz","has_sig":false,"md5_digest":"260c774e23ef3f83b4db0b5f7dcceb63","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":61304,"upload_time":"2018-08-22T16:07:22","upload_time_iso_8601":"2018-08-22T16:07:22.280929Z","url":"https://files.pythonhosted.org/packages/d8/03/b2a41d7ee2e96a05d277b99c5794d7689437a01b8e4b5ac21f7fa8055e35/vyper-0.1.0b2.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b3":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b3/","requires_dist":["pycryptodome (<4,>=3.5.1)"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b3","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"f8637dd7f9cffe286351744f7ce56cc3401de99c8bfe8e417aefdcaa289b7672","md5":"fc27cefbe13fbef6bec0a95765679c83","sha256":"9e43f11670bd7809a88972db01b28e50a4f438c82131413ab7197031975bcd86"},"downloads":-1,"filename":"vyper-0.1.0b3-py3-none-any.whl","has_sig":false,"md5_digest":"fc27cefbe13fbef6bec0a95765679c83","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":74366,"upload_time":"2018-09-25T16:17:23","upload_time_iso_8601":"2018-09-25T16:17:23.926511Z","url":"https://files.pythonhosted.org/packages/f8/63/7dd7f9cffe286351744f7ce56cc3401de99c8bfe8e417aefdcaa289b7672/vyper-0.1.0b3-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"c5040e62458b65f43bd462383a386937dba316511e7b462f4b85062c48642dd8","md5":"0c5b160f7d7a7c4f48e2e85db10d9731","sha256":"4ca54ab1fdafce69bab519f130f51428e595462e1e797f5126ae1a224765f3d2"},"downloads":-1,"filename":"vyper-0.1.0b3.tar.gz","has_sig":false,"md5_digest":"0c5b160f7d7a7c4f48e2e85db10d9731","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":63843,"upload_time":"2018-09-25T16:17:26","upload_time_iso_8601":"2018-09-25T16:17:26.058003Z","url":"https://files.pythonhosted.org/packages/c5/04/0e62458b65f43bd462383a386937dba316511e7b462f4b85062c48642dd8/vyper-0.1.0b3.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b4":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b4/","requires_dist":["pycryptodome (<4,>=3.5.1)"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b4","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"b345220ddcb3dc72ad50d104398c9605afac9e7c2d2386dcd9189a9cee24966a","md5":"a388a30df53bfc2a3c4115be66bcac08","sha256":"c38a1b7a2bc15bb80c2314caacd51bca7dad104816bc175b99d67be846b74b4b"},"downloads":-1,"filename":"vyper-0.1.0b4-py3-none-any.whl","has_sig":false,"md5_digest":"a388a30df53bfc2a3c4115be66bcac08","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":81039,"upload_time":"2018-10-19T21:49:33","upload_time_iso_8601":"2018-10-19T21:49:33.126713Z","url":"https://files.pythonhosted.org/packages/b3/45/220ddcb3dc72ad50d104398c9605afac9e7c2d2386dcd9189a9cee24966a/vyper-0.1.0b4-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"1217fb43bf7197d8807f268f1cf91fd97fb96e44a572db94005f58b575f5bbb6","md5":"fb846580106521861920903dfd362428","sha256":"e28901dc2dcf2e6ac1ae51f2c5707fc34a5f504e2ffcec80bc810abbd4e54a27"},"downloads":-1,"filename":"vyper-0.1.0b4.tar.gz","has_sig":false,"md5_digest":"fb846580106521861920903dfd362428","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":69244,"upload_time":"2018-10-19T21:49:35","upload_time_iso_8601":"2018-10-19T21:49:35.580593Z","url":"https://files.pythonhosted.org/packages/12/17/fb43bf7197d8807f268f1cf91fd97fb96e44a572db94005f58b575f5bbb6/vyper-0.1.0b4.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b5":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b5/","requires_dist":["pycryptodome (<4,>=3.5.1)"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b5","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"aceb6385279adbb3f4d14277bba250850b4bdfbdb60d16a3a83f6640afaf870e","md5":"ad5f6dac36f8f4a2d3bc1ddcb83ed33e","sha256":"1aa409e5c98a6930262c8a0d51d7f79045119cb22eec1b538d28433e86eeb583"},"downloads":-1,"filename":"vyper-0.1.0b5-py3-none-any.whl","has_sig":false,"md5_digest":"ad5f6dac36f8f4a2d3bc1ddcb83ed33e","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":83464,"upload_time":"2018-11-30T15:08:52","upload_time_iso_8601":"2018-11-30T15:08:52.873249Z","url":"https://files.pythonhosted.org/packages/ac/eb/6385279adbb3f4d14277bba250850b4bdfbdb60d16a3a83f6640afaf870e/vyper-0.1.0b5-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"fb935f78a29f48ebc266703f60e2c5486c9e7c07532233f244ea6e7c380b174c","md5":"261ef35aca02962c342dc99a59e4a783","sha256":"c5a98e3b1220d13f21eccf60e533c1b21cbbfedf50423e9dfafc8b9d892b339c"},"downloads":-1,"filename":"vyper-0.1.0b5.tar.gz","has_sig":false,"md5_digest":"261ef35aca02962c342dc99a59e4a783","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":71718,"upload_time":"2018-11-30T15:08:55","upload_time_iso_8601":"2018-11-30T15:08:55.947341Z","url":"https://files.pythonhosted.org/packages/fb/93/5f78a29f48ebc266703f60e2c5486c9e7c07532233f244ea6e7c380b174c/vyper-0.1.0b5.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b6":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b6/","requires_dist":["pycryptodome (<4,>=3.5.1)","pytest; extra == 'test'","pytest-cov; extra == 'test'","py-evm (==0.2.0a34); extra == 'test'","eth-tester (==0.1.0b33); extra == 'test'","web3 (==4.8.2); extra == 'test'"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b6","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"220982987c619a9d8ac522d69a4c38abb38a06843806a34774ff0c799d0a1d24","md5":"c03224fe0a752c5e3cd3410be5dd76c2","sha256":"04f09d5fcc3459339b1980efe9b34e37484489a0b028eb09066ca135917ef3c5"},"downloads":-1,"filename":"vyper-0.1.0b6-py3-none-any.whl","has_sig":false,"md5_digest":"c03224fe0a752c5e3cd3410be5dd76c2","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":88541,"upload_time":"2018-12-13T15:47:21","upload_time_iso_8601":"2018-12-13T15:47:21.724745Z","url":"https://files.pythonhosted.org/packages/22/09/82987c619a9d8ac522d69a4c38abb38a06843806a34774ff0c799d0a1d24/vyper-0.1.0b6-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"89c1d3e5fbefce875ecbb8499267f3d1275e53e2d6254557e85de2e18b0d0602","md5":"f6f33f86cd5b9979cbef092e82f4b806","sha256":"4e93e931a7a8b623170f4b776fc5c006058e9a0e9f558b5555e84d289be9a0da"},"downloads":-1,"filename":"vyper-0.1.0b6.tar.gz","has_sig":false,"md5_digest":"f6f33f86cd5b9979cbef092e82f4b806","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":74695,"upload_time":"2018-12-13T15:47:24","upload_time_iso_8601":"2018-12-13T15:47:24.633973Z","url":"https://files.pythonhosted.org/packages/89/c1/d3e5fbefce875ecbb8499267f3d1275e53e2d6254557e85de2e18b0d0602/vyper-0.1.0b6.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b7":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b7/","requires_dist":["pycryptodome (<4,>=3.5.1)","pytest ; extra == 'test'","pytest-cov ; extra == 'test'","py-evm (==0.2.0a34) ; extra == 'test'","eth-tester (==0.1.0b33) ; extra == 'test'","web3 (==4.8.2) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b7","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"676fea889b6e68494c0fa1f488a9e38f2e4e1201ec17136a0ccabb0af428d76e","md5":"ed709c3a589ee73912ed691a5a749ef0","sha256":"10078c0534009abefcb8924ea6e881030104ec91c409a87dc4c21fcc95bb35e0"},"downloads":-1,"filename":"vyper-0.1.0b7-py3-none-any.whl","has_sig":false,"md5_digest":"ed709c3a589ee73912ed691a5a749ef0","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":92826,"upload_time":"2019-01-18T13:30:12","upload_time_iso_8601":"2019-01-18T13:30:12.097229Z","url":"https://files.pythonhosted.org/packages/67/6f/ea889b6e68494c0fa1f488a9e38f2e4e1201ec17136a0ccabb0af428d76e/vyper-0.1.0b7-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"6b551663434c13850ab891d40c5ebb831dcee9c303b51be7600f812a18a8e6ca","md5":"c48ab0889715e3256cd3d77f79689fb9","sha256":"7c24a9bd4643d303e8cdaab758e5f3ef3cd6372b43c71a5a2d1bb32208c4186c"},"downloads":-1,"filename":"vyper-0.1.0b7.tar.gz","has_sig":false,"md5_digest":"c48ab0889715e3256cd3d77f79689fb9","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":80398,"upload_time":"2019-01-18T13:30:14","upload_time_iso_8601":"2019-01-18T13:30:14.479548Z","url":"https://files.pythonhosted.org/packages/6b/55/1663434c13850ab891d40c5ebb831dcee9c303b51be7600f812a18a8e6ca/vyper-0.1.0b7.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b8":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b8/","requires_dist":["pycryptodome (<4,>=3.5.1)","pytest ; extra == 'test'","pytest-cov ; extra == 'test'","py-evm (==0.2.0a34) ; extra == 'test'","eth-tester (==0.1.0b33) ; extra == 'test'","web3 (==4.8.2) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b8","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"22482b71e889d9c915c02ee0da37df774047cfc7e290ae5e95f10476db069c87","md5":"3bc6031735bd9e363385520d5dd599c8","sha256":"de5b0d98b32dd6b379fecf03e7f72a70bd9d3b66eb4fc117798d3901fe781b22"},"downloads":-1,"filename":"vyper-0.1.0b8-py3-none-any.whl","has_sig":false,"md5_digest":"3bc6031735bd9e363385520d5dd599c8","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":97462,"upload_time":"2019-02-06T09:40:08","upload_time_iso_8601":"2019-02-06T09:40:08.328872Z","url":"https://files.pythonhosted.org/packages/22/48/2b71e889d9c915c02ee0da37df774047cfc7e290ae5e95f10476db069c87/vyper-0.1.0b8-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"f919f788498b95d17e29fe32c88a5e7888289e5c1cf6b845f4de4e986442aad5","md5":"97c591d8763a70067ddba8cee3d2b0ce","sha256":"a1681a321720dfdeab0404357ea91cb42ad293a463b258ef04d4031fc855401e"},"downloads":-1,"filename":"vyper-0.1.0b8.tar.gz","has_sig":false,"md5_digest":"97c591d8763a70067ddba8cee3d2b0ce","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":84126,"upload_time":"2019-02-06T09:40:10","upload_time_iso_8601":"2019-02-06T09:40:10.948818Z","url":"https://files.pythonhosted.org/packages/f9/19/f788498b95d17e29fe32c88a5e7888289e5c1cf6b845f4de4e986442aad5/vyper-0.1.0b8.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.1.0b9":{"info":{"author":"Vitalik Buterin","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/ethereum/vyper","keywords":"ethereum","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/ethereum/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.1.0b9/","requires_dist":["pycryptodome (<4,>=3.5.1)","coveralls (<2,>=1.6) ; extra == 'lint'","flake8 (<4,>=3.7) ; extra == 'lint'","flake8-bugbear (==18.8.0) ; extra == 'lint'","isort (<5,>=4.2.15) ; extra == 'lint'","pytest (>=3.6) ; extra == 'test'","pytest-cov (==2.4.0) ; extra == 'test'","pytest-xdist (==1.18.1) ; extra == 'test'","py-evm (==0.2.0a39) ; extra == 'test'","eth-tester (==0.1.0b37) ; extra == 'test'","web3 (==5.0.0a6) ; extra == 'test'","tox (<4,>=3.7) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper Programming Language for Ethereum","version":"0.1.0b9","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"e1183abfc264a829bf1f64553ddc2a82b0beb8a5482418069a216bf103f641a1","md5":"649cd9dd53ce6880084dda757d69c783","sha256":"269fa7bf6620a611223a0f3098c439c9d89906b7571131c0b2d009f4baf35621"},"downloads":-1,"filename":"vyper-0.1.0b9-py3-none-any.whl","has_sig":false,"md5_digest":"649cd9dd53ce6880084dda757d69c783","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":106242,"upload_time":"2019-03-12T14:53:22","upload_time_iso_8601":"2019-03-12T14:53:22.181714Z","url":"https://files.pythonhosted.org/packages/e1/18/3abfc264a829bf1f64553ddc2a82b0beb8a5482418069a216bf103f641a1/vyper-0.1.0b9-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"a2bb9bc80e06f99a5e68997501773735d716da0820210de802dac59b54fb9d7b","md5":"c872274a5138e171cf4620f243e490c4","sha256":"e4ab218fa0d30e184b1c09ff5f7d3a2123e13605447f81570c59403bf65466bc"},"downloads":-1,"filename":"vyper-0.1.0b9.tar.gz","has_sig":false,"md5_digest":"c872274a5138e171cf4620f243e490c4","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":91973,"upload_time":"2019-03-12T14:53:24","upload_time_iso_8601":"2019-03-12T14:53:24.375759Z","url":"https://files.pythonhosted.org/packages/a2/bb/9bc80e06f99a5e68997501773735d716da0820210de802dac59b54fb9d7b/vyper-0.1.0b9.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"# VVE-2020-0001\n\nEarlier today, we received a responsible disclosure of a potential issue from @montyly (security researcher at @trailofbits) for Vyper users who make assumptions about what values certain interface types can return.\n\n### Impact\nWe determined the issue to be mild and unlikely to be exploited, with an easy workaround while the correct resolution is in process. The issue stems from a number of things, which we will detail here.\n\n(1) The ABI Specification is under-defined such that function return type is not always reflected in how you use it\n\nThis means that a function which returns `uint8` under the hood actually returns a 32 byte integer, making it identical to a function that returns `uint256`. This allows users to read an interface that returns a `uint8` value to be stored into a `uint256` variable without any explicit casting or input validation.\n\n(2) Vyper doesn&#39;t have `uint8` types\n\nWhen Vyper was originally created, it only had one numeric type, but we added just enough types to be able to work with the majority of ERC interfaces that exist.\n\nUnfortunately, we never added `uint8`, because it&#39;s only majority usage was for `ERC20.decimals()` as the return type, which isn&#39;t reflected in the method ID. Because of (1), it didn&#39;t matter that we didn&#39;t have these types implemented because you could capture the return value as `uint256` and use it just fine.\n\n(3) `ERC20.decimals()` returns `uint8`\n\n`ERC20.decimal()` (which is an optional function) returns a `uint8` type. While it was never intentioned to be used directly within a smart contract (hence being optional), someone could easily make the decision to rely on it to perform important functionality within their Vyper smart contract. This might lead to a scenario where an unexpectedly large value (&gt; 255) returned by calling this function (which a malicious contract writer might write) would allow an attacker to manipulate or bypass certain logic depending on this value.\n\nIn summary, because of (1), it isn&#39;t necessary to have to cast the return value of a function that returns `uint8` to `uint256`, and because of (2) it isn&#39;t possible to have the type system protect against this type of error. This could lead to scenarios like (3) where this behavior can be exploited.\n\n### Patches\nWe are currently refactoring our typing system so we can implement all ABI-compliant integer types, but no currently patched version is available that gives users access to the `uint8` type.\n\n### Workarounds\nThere is an easy workaround where you should check that the value returned by an interface which specifies `uint8` should be checked to be within the bounds of a `uint8` integer. As an example:\n\n```python\n...\n# returns uint8, but we implicitly cast to uint256 without checking\ndecimals: uint256 = ERC20(_token).decimal()\n# FIX: Insert this line\nassert decimals &lt; 256\n...\n```\n\nDepending on how you use this value, it may not be necessary to insert this check.\n\n### References\n* [ABI Specification](https://solidity.readthedocs.io/en/latest/abi-spec.html)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Chat with us in [our gitter ](https://gitter.im/vyperlang/community)\n* Open an issue in [https://github.com/vyperlang/vyper](https://github.com/vyperlang/vyper)\n* Email us at [security@vyperlang.org](mailto:security@vyperlang.org)","fixed_in":[],"id":"GHSA-mr6r-mvw4-736g","link":"https://osv.dev/vulnerability/GHSA-mr6r-mvw4-736g","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.1":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.1/","requires_dist":["asttokens (==2.0.3)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (<6.0,>=5.11) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (<1.0,>=0.8) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==4.3.21) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==4.3.21) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (<6.0,>=5.11) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (<1.0,>=0.8) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.1","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"e61c663cf311df3254398b7696e5f66f4155d2301331b921c3a45c06414ff831","md5":"fa9ae75ee01db571eeb50d8468ad5178","sha256":"1f9c288d01716f69b026a835086e1b3a3adbd6fc7b43e629a11903901048b5bf"},"downloads":-1,"filename":"vyper-0.2.1-py3-none-any.whl","has_sig":false,"md5_digest":"fa9ae75ee01db571eeb50d8468ad5178","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":195117,"upload_time":"2020-07-03T19:47:07","upload_time_iso_8601":"2020-07-03T19:47:07.135309Z","url":"https://files.pythonhosted.org/packages/e6/1c/663cf311df3254398b7696e5f66f4155d2301331b921c3a45c06414ff831/vyper-0.2.1-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"f3bdefed28c757c06535aa315d40b4381f9aa8a59f88092028f74b7d742d8235","md5":"8384d2da551ea1b1538da26bf42d65ce","sha256":"0861868741fcb95ec5c7463c9811e6bccb295d26c22cd58aeb19e3fa601bd258"},"downloads":-1,"filename":"vyper-0.2.1.tar.gz","has_sig":false,"md5_digest":"8384d2da551ea1b1538da26bf42d65ce","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":154612,"upload_time":"2020-07-03T19:47:08","upload_time_iso_8601":"2020-07-03T19:47:08.416379Z","url":"https://files.pythonhosted.org/packages/f3/bd/efed28c757c06535aa315d40b4381f9aa8a59f88092028f74b7d742d8235/vyper-0.2.1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.10":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.10/","requires_dist":["asttokens (==2.0.4)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (==5.12.3) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.7.0) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.7.0) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (==5.12.3) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.10","yanked":true,"yanked_reason":"Potential runtime bug introduced"},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"af23d8ca861f4b67055cca85c2d3aa66c224c335b2d46529037c3a3095cfbd96","md5":"6076ccefd6454672d30a318aca650fa8","sha256":"53df5c65199d1da42ffceee37623d8d9a07bcf782cb55e8ba3ff086eb2dd9496"},"downloads":-1,"filename":"vyper-0.2.10-py3-none-any.whl","has_sig":false,"md5_digest":"6076ccefd6454672d30a318aca650fa8","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":220192,"upload_time":"2021-02-17T16:33:38","upload_time_iso_8601":"2021-02-17T16:33:38.586387Z","url":"https://files.pythonhosted.org/packages/af/23/d8ca861f4b67055cca85c2d3aa66c224c335b2d46529037c3a3095cfbd96/vyper-0.2.10-py3-none-any.whl","yanked":true,"yanked_reason":"Potential runtime bug introduced"},{"comment_text":"","digests":{"blake2b_256":"8484dd07f5e40b2cc6d081478e0863b2eaa0c644b6fc230aeea23c7a42f12622","md5":"7822331c56207bae509bba621719fe19","sha256":"474e0225bbfde86df0d16cb1203610c9dc7b950d5a2984121ff42b8f342628e3"},"downloads":-1,"filename":"vyper-0.2.10.tar.gz","has_sig":false,"md5_digest":"7822331c56207bae509bba621719fe19","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":183950,"upload_time":"2021-02-17T16:33:40","upload_time_iso_8601":"2021-02-17T16:33:40.197246Z","url":"https://files.pythonhosted.org/packages/84/84/dd07f5e40b2cc6d081478e0863b2eaa0c644b6fc230aeea23c7a42f12622/vyper-0.2.10.tar.gz","yanked":true,"yanked_reason":"Potential runtime bug introduced"}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.11":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.11/","requires_dist":["asttokens (==2.0.4)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (==5.12.3) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.7.0) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.7.0) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (==5.12.3) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.11","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"5038a3401d32789c263339efe775bb5476d346e13acf2c41b42bd0035683cc5b","md5":"ac7383d3a1654347e19ab130276eda4c","sha256":"006ef530930a842478db2de4b171d4ccb1fa7fb8185e6f31204618837c3c1d0b"},"downloads":-1,"filename":"vyper-0.2.11-py3-none-any.whl","has_sig":false,"md5_digest":"ac7383d3a1654347e19ab130276eda4c","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":220263,"upload_time":"2021-02-28T01:34:20","upload_time_iso_8601":"2021-02-28T01:34:20.509327Z","url":"https://files.pythonhosted.org/packages/50/38/a3401d32789c263339efe775bb5476d346e13acf2c41b42bd0035683cc5b/vyper-0.2.11-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"6375449c4823245b065af726cf9380208e1c377b77c7ead5b1366dc11fd32bb6","md5":"2c8906c9061bc7c23a4e14328dc7d861","sha256":"e763561a161c35c03b92a0c176096dd9b4c78ab003c2f08324d443f459b3de84"},"downloads":-1,"filename":"vyper-0.2.11.tar.gz","has_sig":false,"md5_digest":"2c8906c9061bc7c23a4e14328dc7d861","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":184027,"upload_time":"2021-02-28T01:34:21","upload_time_iso_8601":"2021-02-28T01:34:21.580185Z","url":"https://files.pythonhosted.org/packages/63/75/449c4823245b065af726cf9380208e1c377b77c7ead5b1366dc11fd32bb6/vyper-0.2.11.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.12":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.12/","requires_dist":["asttokens (==2.0.4)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (==5.12.3) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.7.0) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.7.0) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (==5.12.3) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.12","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"e1559d17c0d0ef1aa1ee45574a78d50c63e468f28c6df13a44d81e1a6e0b2f02","md5":"b70b400184bebaea479cd326372de675","sha256":"c97dd2d2c9ed5185338c8d9c78ad00432873fbe3387db62ecf7e33bf4e33882a"},"downloads":-1,"filename":"vyper-0.2.12-py3-none-any.whl","has_sig":false,"md5_digest":"b70b400184bebaea479cd326372de675","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":222176,"upload_time":"2021-04-16T15:54:19","upload_time_iso_8601":"2021-04-16T15:54:19.886005Z","url":"https://files.pythonhosted.org/packages/e1/55/9d17c0d0ef1aa1ee45574a78d50c63e468f28c6df13a44d81e1a6e0b2f02/vyper-0.2.12-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"d71f2a58675f310e220c85d43772d0f3ef1d5648966895dfc399716be75e654b","md5":"7db2274e31459c48d86092edecc8acdd","sha256":"caad7d03a1e69b80d6cd6711d1fb810df91d13e2cbced52a606a0bbb476af31e"},"downloads":-1,"filename":"vyper-0.2.12.tar.gz","has_sig":false,"md5_digest":"7db2274e31459c48d86092edecc8acdd","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":185895,"upload_time":"2021-04-16T15:54:21","upload_time_iso_8601":"2021-04-16T15:54:21.278345Z","url":"https://files.pythonhosted.org/packages/d7/1f/2a58675f310e220c85d43772d0f3ef1d5648966895dfc399716be75e654b/vyper-0.2.12.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.13":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.13/","requires_dist":["asttokens (==2.0.4)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (==5.12.3) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.7.0) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.7.0) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (==5.12.3) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.13","yanked":true,"yanked_reason":"bug with 0.2.13"},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"dd31d1f899864cac4baa35dab948d7b13137a9a4d3ca52574ae7c8ed75039428","md5":"711c3a335a611b6aac74ae7bb97405df","sha256":"5ef7fa25c40957f5a86929a8efdd56ecf61b794e60b6c5f222fe7a48c0f4953e"},"downloads":-1,"filename":"vyper-0.2.13-py3-none-any.whl","has_sig":false,"md5_digest":"711c3a335a611b6aac74ae7bb97405df","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":223684,"upload_time":"2021-07-06T16:04:35","upload_time_iso_8601":"2021-07-06T16:04:35.613225Z","url":"https://files.pythonhosted.org/packages/dd/31/d1f899864cac4baa35dab948d7b13137a9a4d3ca52574ae7c8ed75039428/vyper-0.2.13-py3-none-any.whl","yanked":true,"yanked_reason":"bug with 0.2.13"},{"comment_text":"","digests":{"blake2b_256":"7f73621af6ac3c197d2f4f87035ec5dd2676d4c234739eb3ecd19ec04f8375ec","md5":"b013cab8c6bcb759c9c7c1796b768443","sha256":"88218584ea57103833cdd66977ecd20845c1c2e809f86eaf2e7c51b570d06315"},"downloads":-1,"filename":"vyper-0.2.13.tar.gz","has_sig":false,"md5_digest":"b013cab8c6bcb759c9c7c1796b768443","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":187080,"upload_time":"2021-07-06T16:04:36","upload_time_iso_8601":"2021-07-06T16:04:36.789010Z","url":"https://files.pythonhosted.org/packages/7f/73/621af6ac3c197d2f4f87035ec5dd2676d4c234739eb3ecd19ec04f8375ec/vyper-0.2.13.tar.gz","yanked":true,"yanked_reason":"bug with 0.2.13"}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Background\nWhen attempting to use the v0.2.14 release, @pandadefi discovered an issue using the `@nonreentrant` decorator.\n\n### Impact\nReentrancy protection storage slots get allocated to the same slots as storage variables, leading to the corruption of storage variables when using the `@nonreentrant` decorator.\n\n### Patches\nThis issue was fixed in v0.2.15 in #2391, #2379\n\n### Workarounds\nDon't use the `@nonreentrant` decorator in these versions.","fixed_in":["0.2.15"],"id":"GHSA-7f92-rr6w-cq64","link":"https://osv.dev/vulnerability/GHSA-7f92-rr6w-cq64","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.14":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.14/","requires_dist":["asttokens (==2.0.4)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (==5.12.3) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.7.0) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.7.0) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (==5.12.3) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.14","yanked":true,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"b60699182b378426be7d9fa180bcb4455ba14bc3ba708938d21fa167fb8dc068","md5":"2833208fae2db99b263618baff2ae32a","sha256":"9b4804dbb833160922d31c8ca74644606b77d4a656752801a52e50ba2335917d"},"downloads":-1,"filename":"vyper-0.2.14-py3-none-any.whl","has_sig":false,"md5_digest":"2833208fae2db99b263618baff2ae32a","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":225803,"upload_time":"2021-07-20T21:55:32","upload_time_iso_8601":"2021-07-20T21:55:32.890411Z","url":"https://files.pythonhosted.org/packages/b6/06/99182b378426be7d9fa180bcb4455ba14bc3ba708938d21fa167fb8dc068/vyper-0.2.14-py3-none-any.whl","yanked":true,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"f97203b7054e3629f84db1d271eb0dd41b75c1917b6f1ca6b8119df98de828c2","md5":"73b741cff69714677b344c9a8aed3786","sha256":"464a7423f48790a3d8b5a058e69e8761aa89311cada6228ee1b5ca7b57d5894b"},"downloads":-1,"filename":"vyper-0.2.14.tar.gz","has_sig":false,"md5_digest":"73b741cff69714677b344c9a8aed3786","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":188201,"upload_time":"2021-07-20T21:55:34","upload_time_iso_8601":"2021-07-20T21:55:34.974489Z","url":"https://files.pythonhosted.org/packages/f9/72/03b7054e3629f84db1d271eb0dd41b75c1917b6f1ca6b8119df98de828c2/vyper-0.2.14.tar.gz","yanked":true,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Background\nWhen attempting to use the v0.2.14 release, @pandadefi discovered an issue using the `@nonreentrant` decorator.\n\n### Impact\nReentrancy protection storage slots get allocated to the same slots as storage variables, leading to the corruption of storage variables when using the `@nonreentrant` decorator.\n\n### Patches\nThis issue was fixed in v0.2.15 in #2391, #2379\n\n### Workarounds\nDon't use the `@nonreentrant` decorator in these versions.","fixed_in":["0.2.15"],"id":"GHSA-7f92-rr6w-cq64","link":"https://osv.dev/vulnerability/GHSA-7f92-rr6w-cq64","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.15":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.15/","requires_dist":["asttokens (==2.0.4)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (==5.12.3) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.7.0) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.7.0) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (==5.12.3) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.15","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"853e4eb5f6acdf24e2b97970bc194357aa22c6ff27c3593c85bc922cf2550508","md5":"8374bb8dfbd59bdad762fd512532ee1b","sha256":"68f57ff7ca68e3a30d68100a232370f32640b15b56e244765c7675e4f21c8386"},"downloads":-1,"filename":"vyper-0.2.15-py3-none-any.whl","has_sig":false,"md5_digest":"8374bb8dfbd59bdad762fd512532ee1b","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":225823,"upload_time":"2021-07-24T00:22:44","upload_time_iso_8601":"2021-07-24T00:22:44.840772Z","url":"https://files.pythonhosted.org/packages/85/3e/4eb5f6acdf24e2b97970bc194357aa22c6ff27c3593c85bc922cf2550508/vyper-0.2.15-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"632de9b3ebaa1894b6c07d7be845a5cb7d2aff63d35f79b212270107374e1c49","md5":"4b475f394a04661ec9f54f1bab9a0285","sha256":"70d9ca1d52b0231d26882d95846601cdc49c9139f25989a33735b46c4ccfe1b5"},"downloads":-1,"filename":"vyper-0.2.15.tar.gz","has_sig":false,"md5_digest":"4b475f394a04661ec9f54f1bab9a0285","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":188246,"upload_time":"2021-07-24T00:22:47","upload_time_iso_8601":"2021-07-24T00:22:47.350488Z","url":"https://files.pythonhosted.org/packages/63/2d/e9b3ebaa1894b6c07d7be845a5cb7d2aff63d35f79b212270107374e1c49/vyper-0.2.15.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363"],"details":"### Impact\n\nIn versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically:\n\n- A `.vy` contract compiled with either of the following `vyper` versions: `0.2.15`, `0.2.16`, `0.3.0`\n- A primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates)\n- A secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/2439, https://github.com/vyperlang/vyper/pull/2514\n\n### Workarounds\nUpgrade to 0.3.1 or higher\n\n### References\nTechnical post-mortem report: https://hackmd.io/@vyperlang/HJUgNMhs2","fixed_in":["0.3.1"],"id":"GHSA-5824-cm3x-3c38","link":"https://osv.dev/vulnerability/GHSA-5824-cm3x-3c38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.16":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.16/","requires_dist":["asttokens (==2.0.4)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-instafail (<1.0,>=0.4) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (==5.12.3) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.7.0) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.7.0) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-instafail (<1.0,>=0.4) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (==5.12.3) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.16","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"a24de652880489f34b597fea596c7ec981d31ad0ef0bf7fc0018cd6d51b7e2dd","md5":"0b356f27097fd9b1c09a8a9fd0119d1c","sha256":"8f6e623a19bedc35947e0ab2aa4ccc88fc31683e56e293fc3b808a88730bc731"},"downloads":-1,"filename":"vyper-0.2.16-py3-none-any.whl","has_sig":false,"md5_digest":"0b356f27097fd9b1c09a8a9fd0119d1c","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":236106,"upload_time":"2021-08-28T16:56:50","upload_time_iso_8601":"2021-08-28T16:56:50.214462Z","url":"https://files.pythonhosted.org/packages/a2/4d/e652880489f34b597fea596c7ec981d31ad0ef0bf7fc0018cd6d51b7e2dd/vyper-0.2.16-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"c00a0c710eb6a918e842dfba444c3589402539a1e2029eed21f90c7e73075706","md5":"971b2a82630eefa39c6c5a1a058ab238","sha256":"6cf347440716964012d46686faefc9c689f01872f19736287a63aa8652ac3ddd"},"downloads":-1,"filename":"vyper-0.2.16.tar.gz","has_sig":false,"md5_digest":"971b2a82630eefa39c6c5a1a058ab238","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":197817,"upload_time":"2021-08-28T16:56:51","upload_time_iso_8601":"2021-08-28T16:56:51.864500Z","url":"https://files.pythonhosted.org/packages/c0/0a/0c710eb6a918e842dfba444c3589402539a1e2029eed21f90c7e73075706/vyper-0.2.16.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363"],"details":"### Impact\n\nIn versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically:\n\n- A `.vy` contract compiled with either of the following `vyper` versions: `0.2.15`, `0.2.16`, `0.3.0`\n- A primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates)\n- A secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/2439, https://github.com/vyperlang/vyper/pull/2514\n\n### Workarounds\nUpgrade to 0.3.1 or higher\n\n### References\nTechnical post-mortem report: https://hackmd.io/@vyperlang/HJUgNMhs2","fixed_in":["0.3.1"],"id":"GHSA-5824-cm3x-3c38","link":"https://osv.dev/vulnerability/GHSA-5824-cm3x-3c38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.2":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.2/","requires_dist":["asttokens (==2.0.3)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (<6.0,>=5.11) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (<1.0,>=0.8) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==4.3.21) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==4.3.21) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (<6.0,>=5.11) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (<1.0,>=0.8) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.2","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"1da355118fbdc63ad844383f57e29c47e1bf9a8a56900da570ae9c5c007c19f0","md5":"556d5ef42cd0c6e63009f796d94cadff","sha256":"8c21d6970722b1b9571645f0683d0ea845312fa130fba6c6579196ffa5a16acf"},"downloads":-1,"filename":"vyper-0.2.2-py3-none-any.whl","has_sig":false,"md5_digest":"556d5ef42cd0c6e63009f796d94cadff","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":193764,"upload_time":"2020-07-04T20:47:09","upload_time_iso_8601":"2020-07-04T20:47:09.408526Z","url":"https://files.pythonhosted.org/packages/1d/a3/55118fbdc63ad844383f57e29c47e1bf9a8a56900da570ae9c5c007c19f0/vyper-0.2.2-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"e74675fc4c2d6a372a75b8a36f6f88972e51bbde3153628e2acb7d562e583e0c","md5":"4acc3a79ddac30aa47b0da063ee26cc7","sha256":"c49ad837b9f26679729781afa434ff9692aab2994a911b234c2c73cea133f218"},"downloads":-1,"filename":"vyper-0.2.2.tar.gz","has_sig":false,"md5_digest":"4acc3a79ddac30aa47b0da063ee26cc7","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":153610,"upload_time":"2020-07-04T20:47:10","upload_time_iso_8601":"2020-07-04T20:47:10.437094Z","url":"https://files.pythonhosted.org/packages/e7/46/75fc4c2d6a372a75b8a36f6f88972e51bbde3153628e2acb7d562e583e0c/vyper-0.2.2.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.3":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.3/","requires_dist":["asttokens (==2.0.3)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (<6.0,>=5.11) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (<1.0,>=0.8) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==4.3.21) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==4.3.21) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (<6.0,>=5.11) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (<1.0,>=0.8) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.3","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"40cdf517a68248605a2b7f97ef30ceb19917a21ea9f30fc7adb997180b36cc70","md5":"f6ae74dbc493dbbb3b334207af5db0d2","sha256":"545433a2641b7c8bac889720f3d79993b7f1081806776c3b7bf288ac7459c749"},"downloads":-1,"filename":"vyper-0.2.3-py3-none-any.whl","has_sig":false,"md5_digest":"f6ae74dbc493dbbb3b334207af5db0d2","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":194567,"upload_time":"2020-07-16T22:26:43","upload_time_iso_8601":"2020-07-16T22:26:43.488855Z","url":"https://files.pythonhosted.org/packages/40/cd/f517a68248605a2b7f97ef30ceb19917a21ea9f30fc7adb997180b36cc70/vyper-0.2.3-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"e3f6efa4ddd2e5e04141166a33ffd23c32e0ac4e970f81a7c05702750b86dbbc","md5":"500539de813e48e9136b03cacef6e207","sha256":"65ffb5cd938e930d6960e01818649688f97fd75a3346bff22e06e22c9afdbc92"},"downloads":-1,"filename":"vyper-0.2.3.tar.gz","has_sig":false,"md5_digest":"500539de813e48e9136b03cacef6e207","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":154402,"upload_time":"2020-07-16T22:26:44","upload_time_iso_8601":"2020-07-16T22:26:44.658141Z","url":"https://files.pythonhosted.org/packages/e3/f6/efa4ddd2e5e04141166a33ffd23c32e0ac4e970f81a7c05702750b86dbbc/vyper-0.2.3.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.4":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.4/","requires_dist":["asttokens (==2.0.3)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (<6.0,>=5.11) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (<1.0,>=0.8) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==4.3.21) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==4.3.21) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (<6.0,>=5.11) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (<1.0,>=0.8) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.4","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"702c69ea3e0b4da06b153e79110860121bfc88fc1cdecc5102e36b94f23d6f58","md5":"3c1c20231c20253751ef6bf1288b92e9","sha256":"48b6747fb181718cf0e2f63ecc75984d50581de4240843badd6a9547b505d8f8"},"downloads":-1,"filename":"vyper-0.2.4-py3-none-any.whl","has_sig":false,"md5_digest":"3c1c20231c20253751ef6bf1288b92e9","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":195556,"upload_time":"2020-08-04T18:30:13","upload_time_iso_8601":"2020-08-04T18:30:13.302501Z","url":"https://files.pythonhosted.org/packages/70/2c/69ea3e0b4da06b153e79110860121bfc88fc1cdecc5102e36b94f23d6f58/vyper-0.2.4-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"db4019392f9aa3deb931fb82a4ca5fbf79c15a79c820923bd54c5250d7c64d87","md5":"55eff9e5084f8a2b5800ae6d4165e851","sha256":"6954ce80260b927b029bc31ae20dbd6b91909900eeb5155be65ae14c88246835"},"downloads":-1,"filename":"vyper-0.2.4.tar.gz","has_sig":false,"md5_digest":"55eff9e5084f8a2b5800ae6d4165e851","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":155330,"upload_time":"2020-08-04T18:30:14","upload_time_iso_8601":"2020-08-04T18:30:14.512642Z","url":"https://files.pythonhosted.org/packages/db/40/19392f9aa3deb931fb82a4ca5fbf79c15a79c820923bd54c5250d7c64d87/vyper-0.2.4.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.5":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.5/","requires_dist":["asttokens (==2.0.3)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (<6.0,>=5.11) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (<1.0,>=0.8) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==4.3.21) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==4.3.21) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (<6.0,>=5.11) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (<1.0,>=0.8) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.5","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"b221aa19589d3f1cf0d5ca546e72c8cc9591403d75f108af7b71695a08d7384b","md5":"e910e1a649ec9b4896dcc965262658a3","sha256":"64cd3d445be47e07d0aa5edfbbe083b1e4d56b223c3d0e3f9ba3843d973cd32e"},"downloads":-1,"filename":"vyper-0.2.5-py3-none-any.whl","has_sig":false,"md5_digest":"e910e1a649ec9b4896dcc965262658a3","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":197239,"upload_time":"2020-09-30T02:16:32","upload_time_iso_8601":"2020-09-30T02:16:32.173331Z","url":"https://files.pythonhosted.org/packages/b2/21/aa19589d3f1cf0d5ca546e72c8cc9591403d75f108af7b71695a08d7384b/vyper-0.2.5-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"cc0da16b46adff9749ca319d7c6e00a0bec67429c8cc5d9ea833e5e2f32bed96","md5":"9646fd030d243f1c00aa501fc2cf2ae6","sha256":"4a400e1f1593eb56ae89e867ec2198dfd2d66b00ce1a3dfa797650ccbf11e8db"},"downloads":-1,"filename":"vyper-0.2.5.tar.gz","has_sig":false,"md5_digest":"9646fd030d243f1c00aa501fc2cf2ae6","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":156865,"upload_time":"2020-09-30T02:16:33","upload_time_iso_8601":"2020-09-30T02:16:33.662867Z","url":"https://files.pythonhosted.org/packages/cc/0d/a16b46adff9749ca319d7c6e00a0bec67429c8cc5d9ea833e5e2f32bed96/vyper-0.2.5.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.6":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.6/","requires_dist":["asttokens (==2.0.3)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (<6.0,>=5.11) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (<1.0,>=0.8) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==4.3.21) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==4.3.21) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (<6.0,>=5.11) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (<1.0,>=0.8) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.16.2) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.6","yanked":true,"yanked_reason":"memory allocation bug"},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"afea25a79277f630b102f1cccab654c480a7c284644923365da41691aadd6c70","md5":"cc0f06e7032b81a35e0093691311d492","sha256":"9cc59f98c4418b1a3b48e187cd88d74cfab134da9808d0076875360b049ce71b"},"downloads":-1,"filename":"vyper-0.2.6-py3-none-any.whl","has_sig":false,"md5_digest":"cc0f06e7032b81a35e0093691311d492","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":199499,"upload_time":"2020-10-10T16:42:04","upload_time_iso_8601":"2020-10-10T16:42:04.986328Z","url":"https://files.pythonhosted.org/packages/af/ea/25a79277f630b102f1cccab654c480a7c284644923365da41691aadd6c70/vyper-0.2.6-py3-none-any.whl","yanked":true,"yanked_reason":"memory allocation bug"},{"comment_text":"","digests":{"blake2b_256":"3b1b85a8c9ba38174076f21f14aa0c1f2e4cb860af54c105ddabb03ff8045e79","md5":"2dd59eba8e49cdbbd3ccdb75f5aad2ab","sha256":"6df17d49da93c56da5b4d0452df0047c0ed92658ebd5254bd9721973bd226ec8"},"downloads":-1,"filename":"vyper-0.2.6.tar.gz","has_sig":false,"md5_digest":"2dd59eba8e49cdbbd3ccdb75f5aad2ab","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":158968,"upload_time":"2020-10-10T16:42:06","upload_time_iso_8601":"2020-10-10T16:42:06.375785Z","url":"https://files.pythonhosted.org/packages/3b/1b/85a8c9ba38174076f21f14aa0c1f2e4cb860af54c105ddabb03ff8045e79/vyper-0.2.6.tar.gz","yanked":true,"yanked_reason":"memory allocation bug"}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.7":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.7/","requires_dist":["asttokens (==2.0.3)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (<6.0,>=5.11) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==4.3.21) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==4.3.21) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (<6.0,>=5.11) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.7","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"7a24a9f9835c8db5063fbfdf22d0a1f6d70f8ccc65039e685ad84fc4f240d312","md5":"5bb37166df8a7e5194dda2132bed05ac","sha256":"23ef37ce25c9620fde737abb0d3e45373cd349adb1e0df487de80f5b6b461fa6"},"downloads":-1,"filename":"vyper-0.2.7-py3-none-any.whl","has_sig":false,"md5_digest":"5bb37166df8a7e5194dda2132bed05ac","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":201117,"upload_time":"2020-10-15T03:07:40","upload_time_iso_8601":"2020-10-15T03:07:40.048000Z","url":"https://files.pythonhosted.org/packages/7a/24/a9f9835c8db5063fbfdf22d0a1f6d70f8ccc65039e685ad84fc4f240d312/vyper-0.2.7-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"68774a366d898381a5a285daf4f7a67ca0cfdb1bec9ecf20c22bab4da7a4ab00","md5":"f15f36494b5640a2fb09612739f8fe9a","sha256":"d825cf43260789cf4ca824e6d5ae51a4b7204340960549417252651a6b0e111b"},"downloads":-1,"filename":"vyper-0.2.7.tar.gz","has_sig":false,"md5_digest":"f15f36494b5640a2fb09612739f8fe9a","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":160213,"upload_time":"2020-10-15T03:07:41","upload_time_iso_8601":"2020-10-15T03:07:41.408195Z","url":"https://files.pythonhosted.org/packages/68/77/4a366d898381a5a285daf4f7a67ca0cfdb1bec9ecf20c22bab4da7a4ab00/vyper-0.2.7.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.8":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: MIT License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"MIT","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.8/","requires_dist":["asttokens (==2.0.4)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (==5.12.3) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==4.3.21) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==4.3.21) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (==5.12.3) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.8","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"d5d38f8086dd6c58fa2c29724d7546f288ef5767ea2f24f46e2916d72f5ccc56","md5":"b633b0474a2f5f6858cf3f6985917d41","sha256":"8e1c7b991440765847923842278b4f5611423fbea3d231a5780f661e87d80500"},"downloads":-1,"filename":"vyper-0.2.8-py3-none-any.whl","has_sig":false,"md5_digest":"b633b0474a2f5f6858cf3f6985917d41","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":219637,"upload_time":"2020-12-04T04:19:48","upload_time_iso_8601":"2020-12-04T04:19:48.751491Z","url":"https://files.pythonhosted.org/packages/d5/d3/8f8086dd6c58fa2c29724d7546f288ef5767ea2f24f46e2916d72f5ccc56/vyper-0.2.8-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"c355997f47afc66acd76ad0160090f7be9d7ce9bf7e16cfd892b0b16187792f7","md5":"2384cd2d0f52e7cce2abfafe94d17b4e","sha256":"6207ba362bb9784c42aad4800c1c154acf8d006c944e8b134aa1790586d92e35"},"downloads":-1,"filename":"vyper-0.2.8.tar.gz","has_sig":false,"md5_digest":"2384cd2d0f52e7cce2abfafe94d17b4e","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":180016,"upload_time":"2020-12-04T04:19:50","upload_time_iso_8601":"2020-12-04T04:19:50.075224Z","url":"https://files.pythonhosted.org/packages/c3/55/997f47afc66acd76ad0160090f7be9d7ce9bf7e16cfd892b0b16187792f7/vyper-0.2.8.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"## Background\n\n@tjayrush reported a data handling issue with certain Web3 libraries using Vyper-deploy forwarder proxy contracts using our Vyper's built-in `create_forwarder_to` function prior to our change to support EIP-1167 style forwarder proxies.\n\n### Impact\nIf you are an end user of a forwarder-style proxy deployed using Vyper's built-in `create_forwarder_to` function AND you have a function that returns >4096 bytes AND you do no return data sanitation on the value returned, you could potentially see a data corruption issue.\n\nOtherwise, if you are handling the result of a return call AND you expect a specific `RETURNDATASIZE` that is less than 4096 (such as `SafeERC20.safeTransfer`) then the call will fail that check.\n\n### Patches\nThe issue was patched when we upgraded to EIP-1167 style forwarder proxies in #2281.\n\n### Workarounds\nIf you are making a call to a contract method that is expected to return <= 4096 bytes, there is no issue as the ABI decoders in both Solidity and Vyper will truncate the data properly. Web3 libraries will also do this, unless you are doing `eth_call` or `eth_sendTransaction` directly.\n\nIf you are using a Solidity library that checks `RETURNDATASIZE` of an external call to a forwarder proxy deployed prior to this patch, it will fail on that assertion (such as `SafeERC20.safeTransfer`). The workaround is to always do a greater than or equal to check, rather than a strict equals to check.","fixed_in":["0.2.9"],"id":"GHSA-375m-5fvv-xq23","link":"https://osv.dev/vulnerability/GHSA-375m-5fvv-xq23","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.2.9":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.6"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.2.9/","requires_dist":["asttokens (==2.0.4)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","web3 (==5.12.3) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==19.10b0) ; extra == 'dev'","flake8 (==3.8.3) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.7.0) ; extra == 'dev'","mypy (==0.780) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==19.10b0) ; extra == 'lint'","flake8 (==3.8.3) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.7.0) ; extra == 'lint'","mypy (==0.780) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","web3 (==5.12.3) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.6","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.2.9","yanked":true,"yanked_reason":"Issue with generating storage getter ABIs"},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"60eaabde714cbabf406335fb9e308134cde3238dc4ed63f85fb8150981b126df","md5":"8f660fe806cd94bd89b424369b701b06","sha256":"4d6ff3dc74a0c6c71ec8d98dbd67bc0a15a992d54652bcdff172b6c484db2f48"},"downloads":-1,"filename":"vyper-0.2.9-py3-none-any.whl","has_sig":false,"md5_digest":"8f660fe806cd94bd89b424369b701b06","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.6","size":220169,"upload_time":"2021-02-17T01:25:44","upload_time_iso_8601":"2021-02-17T01:25:44.773138Z","url":"https://files.pythonhosted.org/packages/60/ea/abde714cbabf406335fb9e308134cde3238dc4ed63f85fb8150981b126df/vyper-0.2.9-py3-none-any.whl","yanked":true,"yanked_reason":"Issue with generating storage getter ABIs"},{"comment_text":"","digests":{"blake2b_256":"963d7ce87e6ca687ce11b5418a6314ede44c6a543c4ad35ed8566ab811d2a9e7","md5":"5456724a14dc265747445beb016d1051","sha256":"b926ea7e3100064bdd91540ee1b444a4d5d1a43cb080b35dc05eb3c8f95b3ed6"},"downloads":-1,"filename":"vyper-0.2.9.tar.gz","has_sig":false,"md5_digest":"5456724a14dc265747445beb016d1051","packagetype":"sdist","python_version":"source","requires_python":">=3.6","size":183925,"upload_time":"2021-02-17T01:25:46","upload_time_iso_8601":"2021-02-17T01:25:46.095400Z","url":"https://files.pythonhosted.org/packages/96/3d/7ce87e6ca687ce11b5418a6314ede44c6a543c4ad35ed8566ab811d2a9e7/vyper-0.2.9.tar.gz","yanked":true,"yanked_reason":"Issue with generating storage getter ABIs"}],"vulnerabilities":[{"aliases":["CVE-2021-41122","GHSA-c7pr-343r-5c46"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions external functions did not properly validate the bounds of decimal arguments. The can lead to logic errors. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-366","link":"https://osv.dev/vulnerability/PYSEC-2021-366","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121","GHSA-xv8x-pr4h-73jv"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. In affected versions when performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack. This issue has been resolved in version 0.3.0.","fixed_in":["0.3.0"],"id":"PYSEC-2021-365","link":"https://osv.dev/vulnerability/PYSEC-2021-365","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41121"],"details":"### Impact\n\nWhen performing a function call inside a literal struct, there is a memory corruption issue that occurs because of an incorrect pointer to the the top of the stack.\n\n### Patches\n0.3.0 / #2447\n\n*","fixed_in":["0.3.0"],"id":"GHSA-xv8x-pr4h-73jv","link":"https://osv.dev/vulnerability/GHSA-xv8x-pr4h-73jv","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nWhen performing a function call inside an array, there is a memory corruption issue that occurs because of an incorrect pointer to the the tip of the stack.\n\n### Patches\nThis issue was partially fixed in [VVE-2020-0004](https://github.com/vyperlang/vyper/security/advisories/GHSA-2r3x-4mrv-mcxf), however the fix did not update similar code for arrays, which had a similar issue. The issue is fully fixed in https://github.com/vyperlang/vyper/pull/2345","fixed_in":["0.2.12"],"id":"GHSA-22wc-c9wj-6q2v","link":"https://osv.dev/vulnerability/GHSA-22wc-c9wj-6q2v","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2021-41122"],"details":"### Impact\n\nThe following code does not properly validate that its input is in bounds.\n\n```python\n@external\ndef foo(x: decimal) -> decimal:\n    return x\n```\n\n### Patches\n0.3.0 / #2447\n\n### Workarounds\nDon't use decimal args\n\n","fixed_in":["0.3.0"],"id":"GHSA-c7pr-343r-5c46","link":"https://osv.dev/vulnerability/GHSA-c7pr-343r-5c46","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32648"],"details":"### Summary\nPrior to v0.3.0, `__default__()` functions did not respect the `@nonreentrancy` decorator and the lock was not emitted. This is a known bug and was already visible in the issue tracker (https://github.com/vyperlang/vyper/issues/2455), but it is being re-issued as an advisory so that tools relying on the advisory publication list can incorporate it into their searches.\n\nA contract search was additionally performed and no vulnerable contracts were found in production.\n\n### PoC\n```vyper\n@external\n@payable\n@nonreentrant(\"default\")\ndef __default__():\n    pass\n```\n\nafter codegen:\n```\n[seq,\n  [if, [lt, calldatasize, 4], [goto, fallback]],\n  [mstore, 28, [calldataload, 0]],\n  [with, _func_sig, [mload, 0], seq],\n  [seq_unchecked,\n    [label, fallback],\n    [seq,\n      pass,\n      # Line 5\n      pass,\n      pass,\n      # Line 4\n      stop]]],\n```\n\n### Impact\nNo vulnerable production contracts were found. Additionally, using a lock on a `default` function is a very sparsely used pattern. As such, the impact is `low`.\n","fixed_in":["0.3.0"],"id":"GHSA-m2v9-w374-5hj9","link":"https://osv.dev/vulnerability/GHSA-m2v9-w374-5hj9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.0":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.7","Programming Language :: Python :: 3.8","Programming Language :: Python :: 3.9"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.0/","requires_dist":["mypy (==0.910) ; extra == 'dev'","asttokens (==2.0.4)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","cached-property (==1.5.2) ; python_version < \"3.8\"","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-instafail (<1.0,>=0.4) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","py-evm (==0.4.0a4) ; extra == 'dev'","web3 (==5.12.3) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==21.9b0) ; extra == 'dev'","flake8 (==3.9.2) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.9.3) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==21.9b0) ; extra == 'lint'","flake8 (==3.9.2) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.9.3) ; extra == 'lint'","mypy (==0.910) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-instafail (<1.0,>=0.4) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","py-evm (==0.4.0a4) ; extra == 'test'","web3 (==5.12.3) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.7,<3.10","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.0","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"fbf8e0b1b326998ed3342a15e014eab33bd643851758431f64a34031e5298520","md5":"ccb7e0273764f91eebf5b3bad4bbe3d1","sha256":"2e36910faef0776e76a99fa9aa6c0b7d50cb15f67bf0313763de415dcab2c6c2"},"downloads":-1,"filename":"vyper-0.3.0-py3-none-any.whl","has_sig":false,"md5_digest":"ccb7e0273764f91eebf5b3bad4bbe3d1","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.7,<3.10","size":237601,"upload_time":"2021-10-05T15:42:23","upload_time_iso_8601":"2021-10-05T15:42:23.144916Z","url":"https://files.pythonhosted.org/packages/fb/f8/e0b1b326998ed3342a15e014eab33bd643851758431f64a34031e5298520/vyper-0.3.0-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"b336e05a16b987be82098ad6daea768611dfd2d98761daabba4d1f9b19726c3f","md5":"adbb5a9b67fc1f981dabca07eab29840","sha256":"3e50cd802696ea3f5e6ab1bf4c9a90a39c332591d416c99f3d2fa93d7d7ba394"},"downloads":-1,"filename":"vyper-0.3.0.tar.gz","has_sig":false,"md5_digest":"adbb5a9b67fc1f981dabca07eab29840","packagetype":"sdist","python_version":"source","requires_python":">=3.7,<3.10","size":1082554,"upload_time":"2021-10-05T15:42:26","upload_time_iso_8601":"2021-10-05T15:42:26.148168Z","url":"https://files.pythonhosted.org/packages/b3/36/e05a16b987be82098ad6daea768611dfd2d98761daabba4d1f9b19726c3f/vyper-0.3.0.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363"],"details":"### Impact\n\nIn versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically:\n\n- A `.vy` contract compiled with either of the following `vyper` versions: `0.2.15`, `0.2.16`, `0.3.0`\n- A primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates)\n- A secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/2439, https://github.com/vyperlang/vyper/pull/2514\n\n### Workarounds\nUpgrade to 0.3.1 or higher\n\n### References\nTechnical post-mortem report: https://hackmd.io/@vyperlang/HJUgNMhs2","fixed_in":["0.3.1"],"id":"GHSA-5824-cm3x-3c38","link":"https://osv.dev/vulnerability/GHSA-5824-cm3x-3c38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.1":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.7","Programming Language :: Python :: 3.8","Programming Language :: Python :: 3.9"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":"","project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.1/","requires_dist":["asttokens (==2.0.5)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","cached-property (==1.5.2) ; python_version < \"3.8\"","importlib-metadata ; python_version < \"3.8\"","pytest (<6.0,>=5.4) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-instafail (<1.0,>=0.4) ; extra == 'dev'","pytest-xdist (<2.0,>=1.32) ; extra == 'dev'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'dev'","py-evm (==0.4.0a4) ; extra == 'dev'","web3 (==5.21.0) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==21.9b0) ; extra == 'dev'","flake8 (==3.9.2) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.9.3) ; extra == 'dev'","mypy (==0.910) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==21.9b0) ; extra == 'lint'","flake8 (==3.9.2) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.9.3) ; extra == 'lint'","mypy (==0.910) ; extra == 'lint'","pytest (<6.0,>=5.4) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-instafail (<1.0,>=0.4) ; extra == 'test'","pytest-xdist (<2.0,>=1.32) ; extra == 'test'","eth-tester[py-evm] (<0.6,>=0.5.0b1) ; extra == 'test'","py-evm (==0.4.0a4) ; extra == 'test'","web3 (==5.21.0) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.7,<3.10","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.1","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"3066c51426e9a62f0c089782e91b841a198b66bf66b988736d0c843e3ecd4e9b","md5":"f83fea486ef6148bc22d2a9a2a12fca6","sha256":"40eabebb0cf859f9660ad94d3af273d3176252d50597fdb94fa808446943d1c5"},"downloads":-1,"filename":"vyper-0.3.1-py3-none-any.whl","has_sig":false,"md5_digest":"f83fea486ef6148bc22d2a9a2a12fca6","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.7,<3.10","size":241193,"upload_time":"2021-12-01T01:41:17","upload_time_iso_8601":"2021-12-01T01:41:17.296893Z","url":"https://files.pythonhosted.org/packages/30/66/c51426e9a62f0c089782e91b841a198b66bf66b988736d0c843e3ecd4e9b/vyper-0.3.1-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"ab8667ad3e2d60026129812b8fed123e24644ad0192f9db44897e554bfce428b","md5":"0dc101d8ef61a57fdb3a7b216f165527","sha256":"7d7ba0e6fdf3b2dcf5f6e7b1316a241c156c7dc9766427483885ca78b57287f4"},"downloads":-1,"filename":"vyper-0.3.1.tar.gz","has_sig":false,"md5_digest":"0dc101d8ef61a57fdb3a7b216f165527","packagetype":"sdist","python_version":"source","requires_python":">=3.7,<3.10","size":1091083,"upload_time":"2021-12-01T01:41:18","upload_time_iso_8601":"2021-12-01T01:41:18.982066Z","url":"https://files.pythonhosted.org/packages/ab/86/67ad3e2d60026129812b8fed123e24644ad0192f9db44897e554bfce428b/vyper-0.3.1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2022-24845","GHSA-j2x6-9323-fp7h"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In affected versions, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. This issue can result in a misinterpretation of the integer value and lead to incorrect behavior. As of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions. Users are advised to upgrade. There is no known workaround for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-198","link":"https://osv.dev/vulnerability/PYSEC-2022-198","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24787","GHSA-7vrm-3jc8-5wwm"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.","fixed_in":["0.3.2"],"id":"PYSEC-2022-196","link":"https://osv.dev/vulnerability/PYSEC-2022-196","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788","GHSA-4mrx-6fxm-8jpg"],"details":"Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. Versions of vyper prior to 0.3.2 suffer from a potential buffer overrun. Importing a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun. Users are advised to upgrade. There are no known workarounds for this issue.","fixed_in":["0.3.2"],"id":"PYSEC-2022-197","link":"https://osv.dev/vulnerability/PYSEC-2022-197","source":"osv","summary":null,"withdrawn":null},{"aliases":[],"details":"### Impact\nbytestrings can have dirty bytes in them, resulting in the word-for-word comparison to give incorrect results, e.g.\n```vyper\nb1: Bytes[32] = b\"abcdef\"\nb1 = slice(b1, 0, 1)\nb2: Bytes[32] = b\"abcdef\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\neven without dirty nonzero bytes, because there is no comparison of the length, two bytestrings can compare to equal if one ends with `\"\\x00\"`.\n```vyper\nb1: Bytes[32] = b\"abc\\0\"\nb2: Bytes[32] = b\"abc\"\nt: bool = b1 == b2  # incorrectly evaluates to True\n```\n\n### Patches\nfixed in https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508","fixed_in":["0.3.2"],"id":"GHSA-7vrm-3jc8-5wwm","link":"https://osv.dev/vulnerability/GHSA-7vrm-3jc8-5wwm","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24845"],"details":"### Impact\nin the following code, the return of `<iface>.returns_int128()` is not validated to fall within the bounds of `int128`. as of v0.3.0, `<iface>.returns_int128()` is validated in simple expressions, but not complex expressions.\n```vyper\ninterface iface:\n    def returns_int128() -> int128: view\n    def returns_Bytes33() -> Bytes[33]: view\n\nx: iface\n \n@external\ndef call_out():\n    x: int128 = self.x.returns_int128()  # affected, <0.3.0\n    y: uint256 = convert(self.x.returns_int128(), uint256)  # affected, <0.3.2\n    z: Bytes[33] = concat(self.x.returns_Bytes33(), b\"\")  # affected >= 0.3.0, <0.3.2\n```\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nBreak up operations involving external calls into multiple statements. For instance, instead of the example above, use\n```\nx: int128 = self.x.returns_int128()\ny: uint256 = convert(x, uint256)\n```","fixed_in":["0.3.2"],"id":"GHSA-j2x6-9323-fp7h","link":"https://osv.dev/vulnerability/GHSA-j2x6-9323-fp7h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-24788"],"details":"### Impact\nImporting a function from a JSON interface which returns `bytes` generates bytecode which does not clamp bytes length, potentially resulting in a buffer overrun.\n\n### Patches\n0.3.2 (as of https://github.com/vyperlang/vyper/commit/049dbdc647b2ce838fae7c188e6bb09cf16e470b)\n\n### Workarounds\nUse .vy interfaces.","fixed_in":["0.3.2"],"id":"GHSA-4mrx-6fxm-8jpg","link":"https://osv.dev/vulnerability/GHSA-4mrx-6fxm-8jpg","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629"],"details":"### Background\nDuring the audit of [Lido's Gate Seals](https://github.com/lidofinance/gate-seals) code [statemind](https://statemind.io) team identified a weird behavior of the code that uses `raw_call`: https://github.com/lidofinance/gate-seals/blob/051593e74df01a4131c485b4fda52e691cd4b7d8/contracts/GateSeal.vy#L164 .\n\nConstruction like this:\n```vyper\nsuccess = raw_call(\n    sealable,\n    _abi_encode(SEAL_DURATION_SECONDS, method_id=method_id(\"pauseFor(uint256)\")),\n    revert_on_failure=False\n)\n```\nwas not fully documented: https://docs.vyperlang.org/en/v0.3.7/built-in-functions.html#raw_call .\n\nThe documentation says that: if `max_outsize=0` it should return nothing and then it says that if `revert_on_failure=False` it should return a `success` flag in the tuple of response, but what if `max_outsize=0`  and `revert_on_failure=False`.\n\n<img width=\"715\" alt=\"image\" src=\"https://user-images.githubusercontent.com/22330612/232125364-d2b3bbac-0b4f-40cb-80ff-f55d8eafef44.png\">\n\n So the team started researching what exactly happened in that case, after some research we found that the Vyper compiler generates the wrong bytecode in that case, it generates the sequence:\n```\nCALL // call\nMLOAD // MLOAD is wrong since the CALL result is already stored in the stack\n```\n\n### Impact\nExample of buggy code:\n```vyper\n@external\ndef returnSome(calling: address, a: uint256) -> bool:\n    success: bool = false\n    success = raw_call(\n        calling,\n        _abi_encode(a, method_id=method_id(\"a(uint256)\")),\n        revert_on_failure=False\n        )\n```\n\nany contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`.\n\n### Patches\nFix by @charles-cooper https://github.com/vyperlang/vyper/commit/851f7a1b3aa2a36fd041e3d0ed38f9355a58c8ae\n\n### Workarounds\nThe simple workaround is always to put  `max_outsize>0`.\nWorkaround example https://github.com/lidofinance/gate-seals/pull/5/files\n\n### References\nLido's fix: https://github.com/lidofinance/gate-seals/pull/5/files\n","fixed_in":["0.3.8"],"id":"GHSA-w9g2-3w7p-72g9","link":"https://osv.dev/vulnerability/GHSA-w9g2-3w7p-72g9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629","GHSA-w9g2-3w7p-72g9"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions 0.3.1 through 0.3.7, the Vyper compiler generates the wrong bytecode. Any contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`. A patch is available and, as of time of publication, anticipated to be part of Vyper 0.3.8. As a workaround, one may always put  `max_outsize>0`.","fixed_in":["0.3.8"],"id":"PYSEC-2023-131","link":"https://osv.dev/vulnerability/PYSEC-2023-131","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.10":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.10/","requires_dist":["cbor2 <6,>=5.4.6","asttokens <3,>=2.0.5","pycryptodome <4,>=3.5.1","packaging <24,>=23.1","importlib-metadata","wheel","pytest <7.0,>=6.2.5 ; extra == 'dev'","pytest-cov <3.0,>=2.10 ; extra == 'dev'","pytest-instafail <1.0,>=0.4 ; extra == 'dev'","pytest-xdist <3.0,>=2.5 ; extra == 'dev'","pytest-split <1.0,>=0.7.0 ; extra == 'dev'","pytest-rerunfailures <11,>=10.2 ; extra == 'dev'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'dev'","py-evm <0.8,>=0.7.0a1 ; extra == 'dev'","web3 ==6.0.0 ; extra == 'dev'","tox <4.0,>=3.15 ; extra == 'dev'","lark ==1.1.2 ; extra == 'dev'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'dev'","eth-stdlib ==0.2.6 ; extra == 'dev'","black ==23.3.0 ; extra == 'dev'","flake8 ==3.9.2 ; extra == 'dev'","flake8-bugbear ==20.1.4 ; extra == 'dev'","flake8-use-fstring ==1.1 ; extra == 'dev'","isort ==5.9.3 ; extra == 'dev'","mypy ==0.982 ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx <7.0,>=6.0 ; extra == 'dev'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx <7.0,>=6.0 ; extra == 'docs'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'docs'","black ==23.3.0 ; extra == 'lint'","flake8 ==3.9.2 ; extra == 'lint'","flake8-bugbear ==20.1.4 ; extra == 'lint'","flake8-use-fstring ==1.1 ; extra == 'lint'","isort ==5.9.3 ; extra == 'lint'","mypy ==0.982 ; extra == 'lint'","pytest <7.0,>=6.2.5 ; extra == 'test'","pytest-cov <3.0,>=2.10 ; extra == 'test'","pytest-instafail <1.0,>=0.4 ; extra == 'test'","pytest-xdist <3.0,>=2.5 ; extra == 'test'","pytest-split <1.0,>=0.7.0 ; extra == 'test'","pytest-rerunfailures <11,>=10.2 ; extra == 'test'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'test'","py-evm <0.8,>=0.7.0a1 ; extra == 'test'","web3 ==6.0.0 ; extra == 'test'","tox <4.0,>=3.15 ; extra == 'test'","lark ==1.1.2 ; extra == 'test'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'test'","eth-stdlib ==0.2.6 ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.10","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"1a7b4976166c71b4a782a9995d5e595c76855845696e1d50de7b8c87db52eff0","md5":"0f2b981390dc9258ffc3a3a768f1739e","sha256":"05636302341bf89602b19f749fcabc8d184a265d8eea4a45c20b3259780353b0"},"downloads":-1,"filename":"vyper-0.3.10-py3-none-any.whl","has_sig":false,"md5_digest":"0f2b981390dc9258ffc3a3a768f1739e","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":262282,"upload_time":"2023-10-04T17:17:16","upload_time_iso_8601":"2023-10-04T17:17:16.706107Z","url":"https://files.pythonhosted.org/packages/1a/7b/4976166c71b4a782a9995d5e595c76855845696e1d50de7b8c87db52eff0/vyper-0.3.10-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"5b1b506e5313b0b39b78f64b1421c2db1da3b7bb5ae95f1939d88327a6670b3f","md5":"1e98e2f756dc858c5d658c8d9229566e","sha256":"8dc1f501caab417fb0ce9c68a6944587f0147ec7cc7d3889cf3a45c19466e489"},"downloads":-1,"filename":"vyper-0.3.10.tar.gz","has_sig":false,"md5_digest":"1e98e2f756dc858c5d658c8d9229566e","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":1223673,"upload_time":"2023-10-04T17:17:18","upload_time_iso_8601":"2023-10-04T17:17:18.263942Z","url":"https://files.pythonhosted.org/packages/5b/1b/506e5313b0b39b78f64b1421c2db1da3b7bb5ae95f1939d88327a6670b3f/vyper-0.3.10.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.10rc1":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.10rc1/","requires_dist":["cbor2 <6,>=5.4.6","asttokens <3,>=2.0.5","pycryptodome <4,>=3.5.1","semantic-version <3,>=2.10","importlib-metadata","wheel","pytest <7.0,>=6.2.5 ; extra == 'dev'","pytest-cov <3.0,>=2.10 ; extra == 'dev'","pytest-instafail <1.0,>=0.4 ; extra == 'dev'","pytest-xdist <3.0,>=2.5 ; extra == 'dev'","pytest-split <1.0,>=0.7.0 ; extra == 'dev'","pytest-rerunfailures <11,>=10.2 ; extra == 'dev'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'dev'","py-evm <0.8,>=0.7.0a1 ; extra == 'dev'","web3 ==6.0.0 ; extra == 'dev'","tox <4.0,>=3.15 ; extra == 'dev'","lark ==1.1.2 ; extra == 'dev'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'dev'","eth-stdlib ==0.2.6 ; extra == 'dev'","black ==23.3.0 ; extra == 'dev'","flake8 ==3.9.2 ; extra == 'dev'","flake8-bugbear ==20.1.4 ; extra == 'dev'","flake8-use-fstring ==1.1 ; extra == 'dev'","isort ==5.9.3 ; extra == 'dev'","mypy ==0.982 ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx <7.0,>=6.0 ; extra == 'dev'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx <7.0,>=6.0 ; extra == 'docs'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'docs'","black ==23.3.0 ; extra == 'lint'","flake8 ==3.9.2 ; extra == 'lint'","flake8-bugbear ==20.1.4 ; extra == 'lint'","flake8-use-fstring ==1.1 ; extra == 'lint'","isort ==5.9.3 ; extra == 'lint'","mypy ==0.982 ; extra == 'lint'","pytest <7.0,>=6.2.5 ; extra == 'test'","pytest-cov <3.0,>=2.10 ; extra == 'test'","pytest-instafail <1.0,>=0.4 ; extra == 'test'","pytest-xdist <3.0,>=2.5 ; extra == 'test'","pytest-split <1.0,>=0.7.0 ; extra == 'test'","pytest-rerunfailures <11,>=10.2 ; extra == 'test'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'test'","py-evm <0.8,>=0.7.0a1 ; extra == 'test'","web3 ==6.0.0 ; extra == 'test'","tox <4.0,>=3.15 ; extra == 'test'","lark ==1.1.2 ; extra == 'test'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'test'","eth-stdlib ==0.2.6 ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.10rc1","yanked":true,"yanked_reason":"bad dependencies"},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"2589188ee38e3d4c71a8a3754f85032c6bc58dca3a3830a38beac00f82935daf","md5":"6b6c30213c9cd908623fde62504e7391","sha256":"18352c23056f6323c62920233fea35f2f94bf2f6334b5f6cd29c2e1836b0fc3b"},"downloads":-1,"filename":"vyper-0.3.10rc1-py3-none-any.whl","has_sig":false,"md5_digest":"6b6c30213c9cd908623fde62504e7391","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":260597,"upload_time":"2023-09-06T20:49:26","upload_time_iso_8601":"2023-09-06T20:49:26.628298Z","url":"https://files.pythonhosted.org/packages/25/89/188ee38e3d4c71a8a3754f85032c6bc58dca3a3830a38beac00f82935daf/vyper-0.3.10rc1-py3-none-any.whl","yanked":true,"yanked_reason":"bad dependencies"},{"comment_text":"","digests":{"blake2b_256":"5490a5a25bccebd2a8f0c8105cf5b831f93857d80bdb0d867f3ccbfb3a0776a8","md5":"d80c8cd6c1c42a808185ea8f7a7e16ea","sha256":"282c1e2864404dcc3e8c25a0d5663d0fe575b622871c90c74c580a596ab439f5"},"downloads":-1,"filename":"vyper-0.3.10rc1.tar.gz","has_sig":false,"md5_digest":"d80c8cd6c1c42a808185ea8f7a7e16ea","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":1214926,"upload_time":"2023-09-06T20:49:28","upload_time_iso_8601":"2023-09-06T20:49:28.810890Z","url":"https://files.pythonhosted.org/packages/54/90/a5a25bccebd2a8f0c8105cf5b831f93857d80bdb0d867f3ccbfb3a0776a8/vyper-0.3.10rc1.tar.gz","yanked":true,"yanked_reason":"bad dependencies"}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42443"],"details":"### Impact\nIn certain conditions, the memory used by the builtins `raw_call`, `create_from_blueprint` and `create_copy_of` can be corrupted.\n\n- For `raw_call`, the argument buffer of the call can be corrupted, leading to incorrect `calldata` in the sub-context.\n- For  `create_from_blueprint` and `create_copy_of`, the buffer for the to-be-deployed bytecode can be corrupted, leading to deploying incorrect bytecode.\n\nBelow are the conditions that must be fulfilled for the corruption to happen for each builtin:\n\n#### `raw_call`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `data` argument of the builtin is `msg.data`.\nand\n- The `to`, `value` or `gas` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\n#### `create_copy_of`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to  uninitialized memory (e.g. calling an internal function)\n\n#### `create_from_blueprint`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- Either no constructor parameters are passed to the builtin or `raw_args` is set to True.\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\nNote: When the builtin is being called from an `internal` function `f` from a function `g`, the issue is not present provided that `g` has written to memory before calling `f`.\n \n#### Examples\n\n\n##### `raw_call`\n\nIn the following contract, calling `bar(1,1)` will return:\n\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000001\n```\ninstead of:\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001\n```\n\n```Python\nidentity: constant(address) = 0x0000000000000000000000000000000000000004\n\n@external\ndef foo():\n    pass\n\n@internal\n@view\ndef get_address()->address:\n    a:uint256 = max_value(uint256) # 0xfff...fff\n    return identity\n@external\ndef bar(f:uint256, u:uint256) -> Bytes[100]:\n    a: Bytes[100] = raw_call(self.get_address(), msg.data, max_outsize=100)\n    return a\n```\n\n##### `create_copy_of`\nIn the following contract, after calling `test()`, the code deployed at `self.created_address` does not match the bytecode at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\n@external\ndef test(target: address) -> address:\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_copy_of(target, salt = keccak256(_abi_encode(target)))\n    return self.created_address\n```\n\n##### `create_from_blueprint`\nIn the following contract, after calling `test()`, the init bytecode used to create the contract deployed at the address `self.created_address` will not match the blueprint bytecode stored at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=keccak256(_abi_encode(target)))\n```\n### Patches\nissue tracking in https://github.com/vyperlang/vyper/issues/3609, patched in #3610 \n\n### Workarounds\n\nThe complex expressions that are being passed as kwargs to the builtin should be cached in memory prior to the call to the builtin. For the last example above, it would be:\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    salt: bytes32 = keccak256(_abi_encode(target))\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=salt)\n```\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-c647-pxm2-c52w","link":"https://osv.dev/vulnerability/GHSA-c647-pxm2-c52w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460"],"details":"### Impact\n`_abi_decode()` does not validate input when it is nested in an expression. the following example gets correctly validated (bounds checked):\n```vyper\nx: int128 = _abi_decode(slice(msg.data, 4, 32), int128)\n```\n\nhowever, the following example is not bounds checked\n```vyper\n@external\ndef abi_decode(x: uint256) -> uint256:\n    a: uint256 = convert(_abi_decode(slice(msg.data, 4, 32), (uint8)), uint256) + 1\n    return a  # abi_decode(256) returns: 257\n```\n\nthe issue can be triggered by constructing an example where the output of `_abi_decode` is not internally passed to `make_setter` (an internal codegen routine) or other input validating routine.\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3626\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-cx2q-hfxr-rj97","link":"https://osv.dev/vulnerability/GHSA-cx2q-hfxr-rj97","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460","GHSA-cx2q-hfxr-rj97"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. The `_abi_decode()` function does not validate input when it is nested in an expression. Uses of `_abi_decode()` can be constructed which allow for bounds checking to be bypassed resulting in incorrect results. This issue has not yet been fixed, but a fix is expected in release `0.3.10`. Users are advised to reference pull request #3626.","fixed_in":["0.3.10"],"id":"PYSEC-2023-191","link":"https://osv.dev/vulnerability/PYSEC-2023-191","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.10rc2":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.10rc2/","requires_dist":["cbor2 <6,>=5.4.6","asttokens <3,>=2.0.5","pycryptodome <4,>=3.5.1","packaging <24,>=23.1","importlib-metadata","wheel","pytest <7.0,>=6.2.5 ; extra == 'dev'","pytest-cov <3.0,>=2.10 ; extra == 'dev'","pytest-instafail <1.0,>=0.4 ; extra == 'dev'","pytest-xdist <3.0,>=2.5 ; extra == 'dev'","pytest-split <1.0,>=0.7.0 ; extra == 'dev'","pytest-rerunfailures <11,>=10.2 ; extra == 'dev'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'dev'","py-evm <0.8,>=0.7.0a1 ; extra == 'dev'","web3 ==6.0.0 ; extra == 'dev'","tox <4.0,>=3.15 ; extra == 'dev'","lark ==1.1.2 ; extra == 'dev'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'dev'","eth-stdlib ==0.2.6 ; extra == 'dev'","black ==23.3.0 ; extra == 'dev'","flake8 ==3.9.2 ; extra == 'dev'","flake8-bugbear ==20.1.4 ; extra == 'dev'","flake8-use-fstring ==1.1 ; extra == 'dev'","isort ==5.9.3 ; extra == 'dev'","mypy ==0.982 ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx <7.0,>=6.0 ; extra == 'dev'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx <7.0,>=6.0 ; extra == 'docs'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'docs'","black ==23.3.0 ; extra == 'lint'","flake8 ==3.9.2 ; extra == 'lint'","flake8-bugbear ==20.1.4 ; extra == 'lint'","flake8-use-fstring ==1.1 ; extra == 'lint'","isort ==5.9.3 ; extra == 'lint'","mypy ==0.982 ; extra == 'lint'","pytest <7.0,>=6.2.5 ; extra == 'test'","pytest-cov <3.0,>=2.10 ; extra == 'test'","pytest-instafail <1.0,>=0.4 ; extra == 'test'","pytest-xdist <3.0,>=2.5 ; extra == 'test'","pytest-split <1.0,>=0.7.0 ; extra == 'test'","pytest-rerunfailures <11,>=10.2 ; extra == 'test'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'test'","py-evm <0.8,>=0.7.0a1 ; extra == 'test'","web3 ==6.0.0 ; extra == 'test'","tox <4.0,>=3.15 ; extra == 'test'","lark ==1.1.2 ; extra == 'test'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'test'","eth-stdlib ==0.2.6 ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.10rc2","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"30a9dcb805f4b11f01202e26ee9c8986201b76fff583c4ce0fcc5ea9e502fcea","md5":"422e14672bfebe9c6f0154955023a75c","sha256":"96bf2fe420101696f2ebc7fe4f87077955496599420cd7e42edb6dd8d8773720"},"downloads":-1,"filename":"vyper-0.3.10rc2-py3-none-any.whl","has_sig":false,"md5_digest":"422e14672bfebe9c6f0154955023a75c","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":260597,"upload_time":"2023-09-06T21:58:07","upload_time_iso_8601":"2023-09-06T21:58:07.002795Z","url":"https://files.pythonhosted.org/packages/30/a9/dcb805f4b11f01202e26ee9c8986201b76fff583c4ce0fcc5ea9e502fcea/vyper-0.3.10rc2-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"378beb80b55010154892071d1da372c6b103b8252dbc774ef0e38427ac99f986","md5":"713e38f8ea4ac44e67df832ebf5d3b79","sha256":"95e03794e92aa514f097bad668027c2b663bec0a34abc82c7bccfef00e7209d8"},"downloads":-1,"filename":"vyper-0.3.10rc2.tar.gz","has_sig":false,"md5_digest":"713e38f8ea4ac44e67df832ebf5d3b79","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":1215016,"upload_time":"2023-09-06T21:58:09","upload_time_iso_8601":"2023-09-06T21:58:09.068074Z","url":"https://files.pythonhosted.org/packages/37/8b/eb80b55010154892071d1da372c6b103b8252dbc774ef0e38427ac99f986/vyper-0.3.10rc2.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42443"],"details":"### Impact\nIn certain conditions, the memory used by the builtins `raw_call`, `create_from_blueprint` and `create_copy_of` can be corrupted.\n\n- For `raw_call`, the argument buffer of the call can be corrupted, leading to incorrect `calldata` in the sub-context.\n- For  `create_from_blueprint` and `create_copy_of`, the buffer for the to-be-deployed bytecode can be corrupted, leading to deploying incorrect bytecode.\n\nBelow are the conditions that must be fulfilled for the corruption to happen for each builtin:\n\n#### `raw_call`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `data` argument of the builtin is `msg.data`.\nand\n- The `to`, `value` or `gas` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\n#### `create_copy_of`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to  uninitialized memory (e.g. calling an internal function)\n\n#### `create_from_blueprint`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- Either no constructor parameters are passed to the builtin or `raw_args` is set to True.\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\nNote: When the builtin is being called from an `internal` function `f` from a function `g`, the issue is not present provided that `g` has written to memory before calling `f`.\n \n#### Examples\n\n\n##### `raw_call`\n\nIn the following contract, calling `bar(1,1)` will return:\n\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000001\n```\ninstead of:\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001\n```\n\n```Python\nidentity: constant(address) = 0x0000000000000000000000000000000000000004\n\n@external\ndef foo():\n    pass\n\n@internal\n@view\ndef get_address()->address:\n    a:uint256 = max_value(uint256) # 0xfff...fff\n    return identity\n@external\ndef bar(f:uint256, u:uint256) -> Bytes[100]:\n    a: Bytes[100] = raw_call(self.get_address(), msg.data, max_outsize=100)\n    return a\n```\n\n##### `create_copy_of`\nIn the following contract, after calling `test()`, the code deployed at `self.created_address` does not match the bytecode at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\n@external\ndef test(target: address) -> address:\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_copy_of(target, salt = keccak256(_abi_encode(target)))\n    return self.created_address\n```\n\n##### `create_from_blueprint`\nIn the following contract, after calling `test()`, the init bytecode used to create the contract deployed at the address `self.created_address` will not match the blueprint bytecode stored at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=keccak256(_abi_encode(target)))\n```\n### Patches\nissue tracking in https://github.com/vyperlang/vyper/issues/3609, patched in #3610 \n\n### Workarounds\n\nThe complex expressions that are being passed as kwargs to the builtin should be cached in memory prior to the call to the builtin. For the last example above, it would be:\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    salt: bytes32 = keccak256(_abi_encode(target))\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=salt)\n```\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-c647-pxm2-c52w","link":"https://osv.dev/vulnerability/GHSA-c647-pxm2-c52w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460"],"details":"### Impact\n`_abi_decode()` does not validate input when it is nested in an expression. the following example gets correctly validated (bounds checked):\n```vyper\nx: int128 = _abi_decode(slice(msg.data, 4, 32), int128)\n```\n\nhowever, the following example is not bounds checked\n```vyper\n@external\ndef abi_decode(x: uint256) -> uint256:\n    a: uint256 = convert(_abi_decode(slice(msg.data, 4, 32), (uint8)), uint256) + 1\n    return a  # abi_decode(256) returns: 257\n```\n\nthe issue can be triggered by constructing an example where the output of `_abi_decode` is not internally passed to `make_setter` (an internal codegen routine) or other input validating routine.\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3626\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-cx2q-hfxr-rj97","link":"https://osv.dev/vulnerability/GHSA-cx2q-hfxr-rj97","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460","GHSA-cx2q-hfxr-rj97"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. The `_abi_decode()` function does not validate input when it is nested in an expression. Uses of `_abi_decode()` can be constructed which allow for bounds checking to be bypassed resulting in incorrect results. This issue has not yet been fixed, but a fix is expected in release `0.3.10`. Users are advised to reference pull request #3626.","fixed_in":["0.3.10"],"id":"PYSEC-2023-191","link":"https://osv.dev/vulnerability/PYSEC-2023-191","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.10rc3":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.10rc3/","requires_dist":["cbor2 <6,>=5.4.6","asttokens <3,>=2.0.5","pycryptodome <4,>=3.5.1","packaging <24,>=23.1","importlib-metadata","wheel","pytest <7.0,>=6.2.5 ; extra == 'dev'","pytest-cov <3.0,>=2.10 ; extra == 'dev'","pytest-instafail <1.0,>=0.4 ; extra == 'dev'","pytest-xdist <3.0,>=2.5 ; extra == 'dev'","pytest-split <1.0,>=0.7.0 ; extra == 'dev'","pytest-rerunfailures <11,>=10.2 ; extra == 'dev'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'dev'","py-evm <0.8,>=0.7.0a1 ; extra == 'dev'","web3 ==6.0.0 ; extra == 'dev'","tox <4.0,>=3.15 ; extra == 'dev'","lark ==1.1.2 ; extra == 'dev'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'dev'","eth-stdlib ==0.2.6 ; extra == 'dev'","black ==23.3.0 ; extra == 'dev'","flake8 ==3.9.2 ; extra == 'dev'","flake8-bugbear ==20.1.4 ; extra == 'dev'","flake8-use-fstring ==1.1 ; extra == 'dev'","isort ==5.9.3 ; extra == 'dev'","mypy ==0.982 ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx <7.0,>=6.0 ; extra == 'dev'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx <7.0,>=6.0 ; extra == 'docs'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'docs'","black ==23.3.0 ; extra == 'lint'","flake8 ==3.9.2 ; extra == 'lint'","flake8-bugbear ==20.1.4 ; extra == 'lint'","flake8-use-fstring ==1.1 ; extra == 'lint'","isort ==5.9.3 ; extra == 'lint'","mypy ==0.982 ; extra == 'lint'","pytest <7.0,>=6.2.5 ; extra == 'test'","pytest-cov <3.0,>=2.10 ; extra == 'test'","pytest-instafail <1.0,>=0.4 ; extra == 'test'","pytest-xdist <3.0,>=2.5 ; extra == 'test'","pytest-split <1.0,>=0.7.0 ; extra == 'test'","pytest-rerunfailures <11,>=10.2 ; extra == 'test'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'test'","py-evm <0.8,>=0.7.0a1 ; extra == 'test'","web3 ==6.0.0 ; extra == 'test'","tox <4.0,>=3.15 ; extra == 'test'","lark ==1.1.2 ; extra == 'test'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'test'","eth-stdlib ==0.2.6 ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.10rc3","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"4bff7173e01827713741d684a087ab44f318cdf1397fd8e98a4da69c13d2f5d3","md5":"249c14a9eac7e5ab39c4849524a1cba4","sha256":"716b08a2e0d71f8857384b2f1af4612b2a7df5197f677df858d2b69fe794e6c2"},"downloads":-1,"filename":"vyper-0.3.10rc3-py3-none-any.whl","has_sig":false,"md5_digest":"249c14a9eac7e5ab39c4849524a1cba4","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":260594,"upload_time":"2023-09-08T14:29:46","upload_time_iso_8601":"2023-09-08T14:29:46.026233Z","url":"https://files.pythonhosted.org/packages/4b/ff/7173e01827713741d684a087ab44f318cdf1397fd8e98a4da69c13d2f5d3/vyper-0.3.10rc3-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"1fdf4e007b33b3806d57d3973dc20341f232b13f888b78171c82e6e29b5a93cf","md5":"f991197eb1e23659e516adb6ebc45e17","sha256":"1bd3ae0d47ef2196788404913f1bc614ef0b2dad870689e77ac896e8331a6829"},"downloads":-1,"filename":"vyper-0.3.10rc3.tar.gz","has_sig":false,"md5_digest":"f991197eb1e23659e516adb6ebc45e17","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":1215000,"upload_time":"2023-09-08T14:29:47","upload_time_iso_8601":"2023-09-08T14:29:47.919446Z","url":"https://files.pythonhosted.org/packages/1f/df/4e007b33b3806d57d3973dc20341f232b13f888b78171c82e6e29b5a93cf/vyper-0.3.10rc3.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42443"],"details":"### Impact\nIn certain conditions, the memory used by the builtins `raw_call`, `create_from_blueprint` and `create_copy_of` can be corrupted.\n\n- For `raw_call`, the argument buffer of the call can be corrupted, leading to incorrect `calldata` in the sub-context.\n- For  `create_from_blueprint` and `create_copy_of`, the buffer for the to-be-deployed bytecode can be corrupted, leading to deploying incorrect bytecode.\n\nBelow are the conditions that must be fulfilled for the corruption to happen for each builtin:\n\n#### `raw_call`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `data` argument of the builtin is `msg.data`.\nand\n- The `to`, `value` or `gas` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\n#### `create_copy_of`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to  uninitialized memory (e.g. calling an internal function)\n\n#### `create_from_blueprint`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- Either no constructor parameters are passed to the builtin or `raw_args` is set to True.\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\nNote: When the builtin is being called from an `internal` function `f` from a function `g`, the issue is not present provided that `g` has written to memory before calling `f`.\n \n#### Examples\n\n\n##### `raw_call`\n\nIn the following contract, calling `bar(1,1)` will return:\n\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000001\n```\ninstead of:\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001\n```\n\n```Python\nidentity: constant(address) = 0x0000000000000000000000000000000000000004\n\n@external\ndef foo():\n    pass\n\n@internal\n@view\ndef get_address()->address:\n    a:uint256 = max_value(uint256) # 0xfff...fff\n    return identity\n@external\ndef bar(f:uint256, u:uint256) -> Bytes[100]:\n    a: Bytes[100] = raw_call(self.get_address(), msg.data, max_outsize=100)\n    return a\n```\n\n##### `create_copy_of`\nIn the following contract, after calling `test()`, the code deployed at `self.created_address` does not match the bytecode at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\n@external\ndef test(target: address) -> address:\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_copy_of(target, salt = keccak256(_abi_encode(target)))\n    return self.created_address\n```\n\n##### `create_from_blueprint`\nIn the following contract, after calling `test()`, the init bytecode used to create the contract deployed at the address `self.created_address` will not match the blueprint bytecode stored at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=keccak256(_abi_encode(target)))\n```\n### Patches\nissue tracking in https://github.com/vyperlang/vyper/issues/3609, patched in #3610 \n\n### Workarounds\n\nThe complex expressions that are being passed as kwargs to the builtin should be cached in memory prior to the call to the builtin. For the last example above, it would be:\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    salt: bytes32 = keccak256(_abi_encode(target))\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=salt)\n```\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-c647-pxm2-c52w","link":"https://osv.dev/vulnerability/GHSA-c647-pxm2-c52w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460"],"details":"### Impact\n`_abi_decode()` does not validate input when it is nested in an expression. the following example gets correctly validated (bounds checked):\n```vyper\nx: int128 = _abi_decode(slice(msg.data, 4, 32), int128)\n```\n\nhowever, the following example is not bounds checked\n```vyper\n@external\ndef abi_decode(x: uint256) -> uint256:\n    a: uint256 = convert(_abi_decode(slice(msg.data, 4, 32), (uint8)), uint256) + 1\n    return a  # abi_decode(256) returns: 257\n```\n\nthe issue can be triggered by constructing an example where the output of `_abi_decode` is not internally passed to `make_setter` (an internal codegen routine) or other input validating routine.\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3626\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-cx2q-hfxr-rj97","link":"https://osv.dev/vulnerability/GHSA-cx2q-hfxr-rj97","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460","GHSA-cx2q-hfxr-rj97"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. The `_abi_decode()` function does not validate input when it is nested in an expression. Uses of `_abi_decode()` can be constructed which allow for bounds checking to be bypassed resulting in incorrect results. This issue has not yet been fixed, but a fix is expected in release `0.3.10`. Users are advised to reference pull request #3626.","fixed_in":["0.3.10"],"id":"PYSEC-2023-191","link":"https://osv.dev/vulnerability/PYSEC-2023-191","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.10rc4":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.10rc4/","requires_dist":["cbor2 <6,>=5.4.6","asttokens <3,>=2.0.5","pycryptodome <4,>=3.5.1","packaging <24,>=23.1","importlib-metadata","wheel","pytest <7.0,>=6.2.5 ; extra == 'dev'","pytest-cov <3.0,>=2.10 ; extra == 'dev'","pytest-instafail <1.0,>=0.4 ; extra == 'dev'","pytest-xdist <3.0,>=2.5 ; extra == 'dev'","pytest-split <1.0,>=0.7.0 ; extra == 'dev'","pytest-rerunfailures <11,>=10.2 ; extra == 'dev'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'dev'","py-evm <0.8,>=0.7.0a1 ; extra == 'dev'","web3 ==6.0.0 ; extra == 'dev'","tox <4.0,>=3.15 ; extra == 'dev'","lark ==1.1.2 ; extra == 'dev'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'dev'","eth-stdlib ==0.2.6 ; extra == 'dev'","black ==23.3.0 ; extra == 'dev'","flake8 ==3.9.2 ; extra == 'dev'","flake8-bugbear ==20.1.4 ; extra == 'dev'","flake8-use-fstring ==1.1 ; extra == 'dev'","isort ==5.9.3 ; extra == 'dev'","mypy ==0.982 ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx <7.0,>=6.0 ; extra == 'dev'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx <7.0,>=6.0 ; extra == 'docs'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'docs'","black ==23.3.0 ; extra == 'lint'","flake8 ==3.9.2 ; extra == 'lint'","flake8-bugbear ==20.1.4 ; extra == 'lint'","flake8-use-fstring ==1.1 ; extra == 'lint'","isort ==5.9.3 ; extra == 'lint'","mypy ==0.982 ; extra == 'lint'","pytest <7.0,>=6.2.5 ; extra == 'test'","pytest-cov <3.0,>=2.10 ; extra == 'test'","pytest-instafail <1.0,>=0.4 ; extra == 'test'","pytest-xdist <3.0,>=2.5 ; extra == 'test'","pytest-split <1.0,>=0.7.0 ; extra == 'test'","pytest-rerunfailures <11,>=10.2 ; extra == 'test'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'test'","py-evm <0.8,>=0.7.0a1 ; extra == 'test'","web3 ==6.0.0 ; extra == 'test'","tox <4.0,>=3.15 ; extra == 'test'","lark ==1.1.2 ; extra == 'test'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'test'","eth-stdlib ==0.2.6 ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.10rc4","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"f4a62544c6620175acc0846192774f204e5401e091400b577a54c6a653aebd0c","md5":"11bae2e7ef891a4ebc80c916091af280","sha256":"b9ab0b9700ebb8c8e0df51ab14eb24374e6b9b4d7440d62aed000420367816fc"},"downloads":-1,"filename":"vyper-0.3.10rc4-py3-none-any.whl","has_sig":false,"md5_digest":"11bae2e7ef891a4ebc80c916091af280","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":262175,"upload_time":"2023-09-27T20:25:30","upload_time_iso_8601":"2023-09-27T20:25:30.412950Z","url":"https://files.pythonhosted.org/packages/f4/a6/2544c6620175acc0846192774f204e5401e091400b577a54c6a653aebd0c/vyper-0.3.10rc4-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"b459e9dd97e38532d7f68dad2516fb3e284a488986a7dadb2f0aaf546083b74e","md5":"67b9dd400f81d87f43e4587db550e82c","sha256":"acfa0ef7899a6ef8ebb351dfec16019ea2d297eaa0ccf5a91720f5270d957b05"},"downloads":-1,"filename":"vyper-0.3.10rc4.tar.gz","has_sig":false,"md5_digest":"67b9dd400f81d87f43e4587db550e82c","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":1221881,"upload_time":"2023-09-27T20:25:32","upload_time_iso_8601":"2023-09-27T20:25:32.445147Z","url":"https://files.pythonhosted.org/packages/b4/59/e9dd97e38532d7f68dad2516fb3e284a488986a7dadb2f0aaf546083b74e/vyper-0.3.10rc4.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460","GHSA-cx2q-hfxr-rj97"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. The `_abi_decode()` function does not validate input when it is nested in an expression. Uses of `_abi_decode()` can be constructed which allow for bounds checking to be bypassed resulting in incorrect results. This issue has not yet been fixed, but a fix is expected in release `0.3.10`. Users are advised to reference pull request #3626.","fixed_in":["0.3.10"],"id":"PYSEC-2023-191","link":"https://osv.dev/vulnerability/PYSEC-2023-191","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42443"],"details":"### Impact\nIn certain conditions, the memory used by the builtins `raw_call`, `create_from_blueprint` and `create_copy_of` can be corrupted.\n\n- For `raw_call`, the argument buffer of the call can be corrupted, leading to incorrect `calldata` in the sub-context.\n- For  `create_from_blueprint` and `create_copy_of`, the buffer for the to-be-deployed bytecode can be corrupted, leading to deploying incorrect bytecode.\n\nBelow are the conditions that must be fulfilled for the corruption to happen for each builtin:\n\n#### `raw_call`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `data` argument of the builtin is `msg.data`.\nand\n- The `to`, `value` or `gas` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\n#### `create_copy_of`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to  uninitialized memory (e.g. calling an internal function)\n\n#### `create_from_blueprint`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- Either no constructor parameters are passed to the builtin or `raw_args` is set to True.\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\nNote: When the builtin is being called from an `internal` function `f` from a function `g`, the issue is not present provided that `g` has written to memory before calling `f`.\n \n#### Examples\n\n\n##### `raw_call`\n\nIn the following contract, calling `bar(1,1)` will return:\n\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000001\n```\ninstead of:\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001\n```\n\n```Python\nidentity: constant(address) = 0x0000000000000000000000000000000000000004\n\n@external\ndef foo():\n    pass\n\n@internal\n@view\ndef get_address()->address:\n    a:uint256 = max_value(uint256) # 0xfff...fff\n    return identity\n@external\ndef bar(f:uint256, u:uint256) -> Bytes[100]:\n    a: Bytes[100] = raw_call(self.get_address(), msg.data, max_outsize=100)\n    return a\n```\n\n##### `create_copy_of`\nIn the following contract, after calling `test()`, the code deployed at `self.created_address` does not match the bytecode at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\n@external\ndef test(target: address) -> address:\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_copy_of(target, salt = keccak256(_abi_encode(target)))\n    return self.created_address\n```\n\n##### `create_from_blueprint`\nIn the following contract, after calling `test()`, the init bytecode used to create the contract deployed at the address `self.created_address` will not match the blueprint bytecode stored at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=keccak256(_abi_encode(target)))\n```\n### Patches\nissue tracking in https://github.com/vyperlang/vyper/issues/3609, patched in #3610 \n\n### Workarounds\n\nThe complex expressions that are being passed as kwargs to the builtin should be cached in memory prior to the call to the builtin. For the last example above, it would be:\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    salt: bytes32 = keccak256(_abi_encode(target))\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=salt)\n```\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-c647-pxm2-c52w","link":"https://osv.dev/vulnerability/GHSA-c647-pxm2-c52w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460"],"details":"### Impact\n`_abi_decode()` does not validate input when it is nested in an expression. the following example gets correctly validated (bounds checked):\n```vyper\nx: int128 = _abi_decode(slice(msg.data, 4, 32), int128)\n```\n\nhowever, the following example is not bounds checked\n```vyper\n@external\ndef abi_decode(x: uint256) -> uint256:\n    a: uint256 = convert(_abi_decode(slice(msg.data, 4, 32), (uint8)), uint256) + 1\n    return a  # abi_decode(256) returns: 257\n```\n\nthe issue can be triggered by constructing an example where the output of `_abi_decode` is not internally passed to `make_setter` (an internal codegen routine) or other input validating routine.\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3626\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-cx2q-hfxr-rj97","link":"https://osv.dev/vulnerability/GHSA-cx2q-hfxr-rj97","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.10rc5":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.10rc5/","requires_dist":["cbor2 <6,>=5.4.6","asttokens <3,>=2.0.5","pycryptodome <4,>=3.5.1","packaging <24,>=23.1","importlib-metadata","wheel","pytest <7.0,>=6.2.5 ; extra == 'dev'","pytest-cov <3.0,>=2.10 ; extra == 'dev'","pytest-instafail <1.0,>=0.4 ; extra == 'dev'","pytest-xdist <3.0,>=2.5 ; extra == 'dev'","pytest-split <1.0,>=0.7.0 ; extra == 'dev'","pytest-rerunfailures <11,>=10.2 ; extra == 'dev'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'dev'","py-evm <0.8,>=0.7.0a1 ; extra == 'dev'","web3 ==6.0.0 ; extra == 'dev'","tox <4.0,>=3.15 ; extra == 'dev'","lark ==1.1.2 ; extra == 'dev'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'dev'","eth-stdlib ==0.2.6 ; extra == 'dev'","black ==23.3.0 ; extra == 'dev'","flake8 ==3.9.2 ; extra == 'dev'","flake8-bugbear ==20.1.4 ; extra == 'dev'","flake8-use-fstring ==1.1 ; extra == 'dev'","isort ==5.9.3 ; extra == 'dev'","mypy ==0.982 ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx <7.0,>=6.0 ; extra == 'dev'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx <7.0,>=6.0 ; extra == 'docs'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'docs'","black ==23.3.0 ; extra == 'lint'","flake8 ==3.9.2 ; extra == 'lint'","flake8-bugbear ==20.1.4 ; extra == 'lint'","flake8-use-fstring ==1.1 ; extra == 'lint'","isort ==5.9.3 ; extra == 'lint'","mypy ==0.982 ; extra == 'lint'","pytest <7.0,>=6.2.5 ; extra == 'test'","pytest-cov <3.0,>=2.10 ; extra == 'test'","pytest-instafail <1.0,>=0.4 ; extra == 'test'","pytest-xdist <3.0,>=2.5 ; extra == 'test'","pytest-split <1.0,>=0.7.0 ; extra == 'test'","pytest-rerunfailures <11,>=10.2 ; extra == 'test'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'test'","py-evm <0.8,>=0.7.0a1 ; extra == 'test'","web3 ==6.0.0 ; extra == 'test'","tox <4.0,>=3.15 ; extra == 'test'","lark ==1.1.2 ; extra == 'test'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'test'","eth-stdlib ==0.2.6 ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.10rc5","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"f6cb3b33cb677d741e37aa703c1976b959279ea955a30b1692f2a3be50ebfc4c","md5":"6f7b015688550842664b0fcdc11e564e","sha256":"f5551fd6aa40342aee9fc64bc5d27810434b3049f339de5b2b98ac2b0a81b225"},"downloads":-1,"filename":"vyper-0.3.10rc5-py3-none-any.whl","has_sig":false,"md5_digest":"6f7b015688550842664b0fcdc11e564e","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":262179,"upload_time":"2023-09-28T22:29:00","upload_time_iso_8601":"2023-09-28T22:29:00.694951Z","url":"https://files.pythonhosted.org/packages/f6/cb/3b33cb677d741e37aa703c1976b959279ea955a30b1692f2a3be50ebfc4c/vyper-0.3.10rc5-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"0287ca4d7f56f8708d365b41d749ec7e9ebaa36f76f39a6d879490b661959a5e","md5":"1ce26aa3eb9e55368713744118e6e861","sha256":"b8eecf684984a07a4f5f75dcf8471d161ccee069ee0531e0a9f0541f5783cd3d"},"downloads":-1,"filename":"vyper-0.3.10rc5.tar.gz","has_sig":false,"md5_digest":"1ce26aa3eb9e55368713744118e6e861","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":1221994,"upload_time":"2023-09-28T22:29:02","upload_time_iso_8601":"2023-09-28T22:29:02.946406Z","url":"https://files.pythonhosted.org/packages/02/87/ca4d7f56f8708d365b41d749ec7e9ebaa36f76f39a6d879490b661959a5e/vyper-0.3.10rc5.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460","GHSA-cx2q-hfxr-rj97"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. The `_abi_decode()` function does not validate input when it is nested in an expression. Uses of `_abi_decode()` can be constructed which allow for bounds checking to be bypassed resulting in incorrect results. This issue has not yet been fixed, but a fix is expected in release `0.3.10`. Users are advised to reference pull request #3626.","fixed_in":["0.3.10"],"id":"PYSEC-2023-191","link":"https://osv.dev/vulnerability/PYSEC-2023-191","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42443"],"details":"### Impact\nIn certain conditions, the memory used by the builtins `raw_call`, `create_from_blueprint` and `create_copy_of` can be corrupted.\n\n- For `raw_call`, the argument buffer of the call can be corrupted, leading to incorrect `calldata` in the sub-context.\n- For  `create_from_blueprint` and `create_copy_of`, the buffer for the to-be-deployed bytecode can be corrupted, leading to deploying incorrect bytecode.\n\nBelow are the conditions that must be fulfilled for the corruption to happen for each builtin:\n\n#### `raw_call`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `data` argument of the builtin is `msg.data`.\nand\n- The `to`, `value` or `gas` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\n#### `create_copy_of`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to  uninitialized memory (e.g. calling an internal function)\n\n#### `create_from_blueprint`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- Either no constructor parameters are passed to the builtin or `raw_args` is set to True.\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\nNote: When the builtin is being called from an `internal` function `f` from a function `g`, the issue is not present provided that `g` has written to memory before calling `f`.\n \n#### Examples\n\n\n##### `raw_call`\n\nIn the following contract, calling `bar(1,1)` will return:\n\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000001\n```\ninstead of:\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001\n```\n\n```Python\nidentity: constant(address) = 0x0000000000000000000000000000000000000004\n\n@external\ndef foo():\n    pass\n\n@internal\n@view\ndef get_address()->address:\n    a:uint256 = max_value(uint256) # 0xfff...fff\n    return identity\n@external\ndef bar(f:uint256, u:uint256) -> Bytes[100]:\n    a: Bytes[100] = raw_call(self.get_address(), msg.data, max_outsize=100)\n    return a\n```\n\n##### `create_copy_of`\nIn the following contract, after calling `test()`, the code deployed at `self.created_address` does not match the bytecode at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\n@external\ndef test(target: address) -> address:\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_copy_of(target, salt = keccak256(_abi_encode(target)))\n    return self.created_address\n```\n\n##### `create_from_blueprint`\nIn the following contract, after calling `test()`, the init bytecode used to create the contract deployed at the address `self.created_address` will not match the blueprint bytecode stored at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=keccak256(_abi_encode(target)))\n```\n### Patches\nissue tracking in https://github.com/vyperlang/vyper/issues/3609, patched in #3610 \n\n### Workarounds\n\nThe complex expressions that are being passed as kwargs to the builtin should be cached in memory prior to the call to the builtin. For the last example above, it would be:\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    salt: bytes32 = keccak256(_abi_encode(target))\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=salt)\n```\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-c647-pxm2-c52w","link":"https://osv.dev/vulnerability/GHSA-c647-pxm2-c52w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460"],"details":"### Impact\n`_abi_decode()` does not validate input when it is nested in an expression. the following example gets correctly validated (bounds checked):\n```vyper\nx: int128 = _abi_decode(slice(msg.data, 4, 32), int128)\n```\n\nhowever, the following example is not bounds checked\n```vyper\n@external\ndef abi_decode(x: uint256) -> uint256:\n    a: uint256 = convert(_abi_decode(slice(msg.data, 4, 32), (uint8)), uint256) + 1\n    return a  # abi_decode(256) returns: 257\n```\n\nthe issue can be triggered by constructing an example where the output of `_abi_decode` is not internally passed to `make_setter` (an internal codegen routine) or other input validating routine.\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3626\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-cx2q-hfxr-rj97","link":"https://osv.dev/vulnerability/GHSA-cx2q-hfxr-rj97","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.2":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.7","Programming Language :: Python :: 3.8","Programming Language :: Python :: 3.9"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.2/","requires_dist":["asttokens (==2.0.5)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","wheel","cached-property (==1.5.2) ; python_version < \"3.8\"","importlib-metadata ; python_version < \"3.8\"","pytest (<7.0,>=6.2.5) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-instafail (<1.0,>=0.4) ; extra == 'dev'","pytest-xdist (<3.0,>=2.5) ; extra == 'dev'","pytest-split (<1.0,>=0.7.0) ; extra == 'dev'","pytest-rerunfailures (<11,>=10.2) ; extra == 'dev'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'dev'","py-evm (<0.6,>=0.5.0a3) ; extra == 'dev'","web3 (==5.27.0) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==21.9b0) ; extra == 'dev'","click (<8.1.0) ; extra == 'dev'","flake8 (==3.9.2) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.9.3) ; extra == 'dev'","mypy (==0.910) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==21.9b0) ; extra == 'lint'","click (<8.1.0) ; extra == 'lint'","flake8 (==3.9.2) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.9.3) ; extra == 'lint'","mypy (==0.910) ; extra == 'lint'","pytest (<7.0,>=6.2.5) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-instafail (<1.0,>=0.4) ; extra == 'test'","pytest-xdist (<3.0,>=2.5) ; extra == 'test'","pytest-split (<1.0,>=0.7.0) ; extra == 'test'","pytest-rerunfailures (<11,>=10.2) ; extra == 'test'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'test'","py-evm (<0.6,>=0.5.0a3) ; extra == 'test'","web3 (==5.27.0) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.7,<3.11","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.2","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"285f0e43e97c8377824e51c13a18531f4d061eb1b3519ef44bcd7d223bbcb16e","md5":"76c826715968c2d2b12f9e02efe580f9","sha256":"019867231da9cedda8a6ef85c967c9ec444e5439bef63f231b81fba884616de8"},"downloads":-1,"filename":"vyper-0.3.2-py3-none-any.whl","has_sig":false,"md5_digest":"76c826715968c2d2b12f9e02efe580f9","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.7,<3.11","size":260495,"upload_time":"2022-04-19T19:15:06","upload_time_iso_8601":"2022-04-19T19:15:06.461070Z","url":"https://files.pythonhosted.org/packages/28/5f/0e43e97c8377824e51c13a18531f4d061eb1b3519ef44bcd7d223bbcb16e/vyper-0.3.2-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"f77b369444a826efb2a564f29dadef2d2500ad3a487790d5fba6e5548d470b4c","md5":"9028d33d7979921b2444e4bc124815eb","sha256":"17bf0d3898bd229620cb82c1b70a534def94d92d251b29401155f2461cfca7a6"},"downloads":-1,"filename":"vyper-0.3.2.tar.gz","has_sig":false,"md5_digest":"9028d33d7979921b2444e4bc124815eb","packagetype":"sdist","python_version":"source","requires_python":">=3.7,<3.11","size":1134272,"upload_time":"2022-04-19T19:15:08","upload_time_iso_8601":"2022-04-19T19:15:08.970895Z","url":"https://files.pythonhosted.org/packages/f7/7b/369444a826efb2a564f29dadef2d2500ad3a487790d5fba6e5548d470b4c/vyper-0.3.2.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629"],"details":"### Background\nDuring the audit of [Lido's Gate Seals](https://github.com/lidofinance/gate-seals) code [statemind](https://statemind.io) team identified a weird behavior of the code that uses `raw_call`: https://github.com/lidofinance/gate-seals/blob/051593e74df01a4131c485b4fda52e691cd4b7d8/contracts/GateSeal.vy#L164 .\n\nConstruction like this:\n```vyper\nsuccess = raw_call(\n    sealable,\n    _abi_encode(SEAL_DURATION_SECONDS, method_id=method_id(\"pauseFor(uint256)\")),\n    revert_on_failure=False\n)\n```\nwas not fully documented: https://docs.vyperlang.org/en/v0.3.7/built-in-functions.html#raw_call .\n\nThe documentation says that: if `max_outsize=0` it should return nothing and then it says that if `revert_on_failure=False` it should return a `success` flag in the tuple of response, but what if `max_outsize=0`  and `revert_on_failure=False`.\n\n<img width=\"715\" alt=\"image\" src=\"https://user-images.githubusercontent.com/22330612/232125364-d2b3bbac-0b4f-40cb-80ff-f55d8eafef44.png\">\n\n So the team started researching what exactly happened in that case, after some research we found that the Vyper compiler generates the wrong bytecode in that case, it generates the sequence:\n```\nCALL // call\nMLOAD // MLOAD is wrong since the CALL result is already stored in the stack\n```\n\n### Impact\nExample of buggy code:\n```vyper\n@external\ndef returnSome(calling: address, a: uint256) -> bool:\n    success: bool = false\n    success = raw_call(\n        calling,\n        _abi_encode(a, method_id=method_id(\"a(uint256)\")),\n        revert_on_failure=False\n        )\n```\n\nany contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`.\n\n### Patches\nFix by @charles-cooper https://github.com/vyperlang/vyper/commit/851f7a1b3aa2a36fd041e3d0ed38f9355a58c8ae\n\n### Workarounds\nThe simple workaround is always to put  `max_outsize>0`.\nWorkaround example https://github.com/lidofinance/gate-seals/pull/5/files\n\n### References\nLido's fix: https://github.com/lidofinance/gate-seals/pull/5/files\n","fixed_in":["0.3.8"],"id":"GHSA-w9g2-3w7p-72g9","link":"https://osv.dev/vulnerability/GHSA-w9g2-3w7p-72g9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629","GHSA-w9g2-3w7p-72g9"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions 0.3.1 through 0.3.7, the Vyper compiler generates the wrong bytecode. Any contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`. A patch is available and, as of time of publication, anticipated to be part of Vyper 0.3.8. As a workaround, one may always put  `max_outsize>0`.","fixed_in":["0.3.8"],"id":"PYSEC-2023-131","link":"https://osv.dev/vulnerability/PYSEC-2023-131","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.3":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.7","Programming Language :: Python :: 3.8","Programming Language :: Python :: 3.9"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.3/","requires_dist":["asttokens (==2.0.5)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","wheel","cached-property (==1.5.2) ; python_version < \"3.8\"","importlib-metadata ; python_version < \"3.8\"","pytest (<7.0,>=6.2.5) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-instafail (<1.0,>=0.4) ; extra == 'dev'","pytest-xdist (<3.0,>=2.5) ; extra == 'dev'","pytest-split (<1.0,>=0.7.0) ; extra == 'dev'","pytest-rerunfailures (<11,>=10.2) ; extra == 'dev'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'dev'","py-evm (<0.6,>=0.5.0a3) ; extra == 'dev'","web3 (==5.27.0) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==21.9b0) ; extra == 'dev'","click (<8.1.0) ; extra == 'dev'","flake8 (==3.9.2) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.9.3) ; extra == 'dev'","mypy (==0.910) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==21.9b0) ; extra == 'lint'","click (<8.1.0) ; extra == 'lint'","flake8 (==3.9.2) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.9.3) ; extra == 'lint'","mypy (==0.910) ; extra == 'lint'","pytest (<7.0,>=6.2.5) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-instafail (<1.0,>=0.4) ; extra == 'test'","pytest-xdist (<3.0,>=2.5) ; extra == 'test'","pytest-split (<1.0,>=0.7.0) ; extra == 'test'","pytest-rerunfailures (<11,>=10.2) ; extra == 'test'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'test'","py-evm (<0.6,>=0.5.0a3) ; extra == 'test'","web3 (==5.27.0) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.7,<3.11","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.3","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"9fd546fc6d82a6de7950f88d93bef191dd6bdfb038f04e08f38ff8c1e5b236d1","md5":"dd115a539a3ce0aa4eab695649291143","sha256":"436dbc49e3bf08d3f36e331384fcdbffec3341d7561fe05960969508686257e6"},"downloads":-1,"filename":"vyper-0.3.3-py3-none-any.whl","has_sig":false,"md5_digest":"dd115a539a3ce0aa4eab695649291143","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.7,<3.11","size":261306,"upload_time":"2022-04-22T09:51:30","upload_time_iso_8601":"2022-04-22T09:51:30.139033Z","url":"https://files.pythonhosted.org/packages/9f/d5/46fc6d82a6de7950f88d93bef191dd6bdfb038f04e08f38ff8c1e5b236d1/vyper-0.3.3-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"c20d77cdefa85f6c33193f8376254e41301df05deed83e432b7c10bb7c0506e6","md5":"cddc65d5e05471d9ccbb32889a86fe6b","sha256":"0409cd8f6ec1d4701bf5554303af5b1466d08de3a9974839101da3b9a8ea040c"},"downloads":-1,"filename":"vyper-0.3.3.tar.gz","has_sig":false,"md5_digest":"cddc65d5e05471d9ccbb32889a86fe6b","packagetype":"sdist","python_version":"source","requires_python":">=3.7,<3.11","size":1134654,"upload_time":"2022-04-22T09:51:31","upload_time_iso_8601":"2022-04-22T09:51:31.585918Z","url":"https://files.pythonhosted.org/packages/c2/0d/77cdefa85f6c33193f8376254e41301df05deed83e432b7c10bb7c0506e6/vyper-0.3.3.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2022-29255"],"details":"### Impact\nwhen a calling an external contract with no return value, the contract address could be evaluated twice. this is usually only an efficiency problem, but if evaluation of the contract address has side effects, it could result in double evaluation of the side effects.\n\nin the following example, `Foo(msg.sender).bar()` is the contract address for the following call (to `.foo()`), and could get evaluated twice\n\n```vyper\ninterface Foo:\n    def foo(): nonpayable\n    def bar() -> address: nonpayable\n\n@external\ndef do_stuff():\n    Foo(Foo(msg.sender).bar()).foo()\n```\n\n### Patches\n6b4d8ff185de071252feaa1c319712b2d6577f8d\n\n### Workarounds\nassign contract addresses to variables. the above example would change to\n```vyper\n@external\ndef do_stuff():\n    t: Foo = Foo(msg.sender).bar()\n    t.foo()\n```\n\n### References\n\n### For more information\n","fixed_in":["0.3.4"],"id":"GHSA-4v9q-cgpw-cf38","link":"https://osv.dev/vulnerability/GHSA-4v9q-cgpw-cf38","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629"],"details":"### Background\nDuring the audit of [Lido's Gate Seals](https://github.com/lidofinance/gate-seals) code [statemind](https://statemind.io) team identified a weird behavior of the code that uses `raw_call`: https://github.com/lidofinance/gate-seals/blob/051593e74df01a4131c485b4fda52e691cd4b7d8/contracts/GateSeal.vy#L164 .\n\nConstruction like this:\n```vyper\nsuccess = raw_call(\n    sealable,\n    _abi_encode(SEAL_DURATION_SECONDS, method_id=method_id(\"pauseFor(uint256)\")),\n    revert_on_failure=False\n)\n```\nwas not fully documented: https://docs.vyperlang.org/en/v0.3.7/built-in-functions.html#raw_call .\n\nThe documentation says that: if `max_outsize=0` it should return nothing and then it says that if `revert_on_failure=False` it should return a `success` flag in the tuple of response, but what if `max_outsize=0`  and `revert_on_failure=False`.\n\n<img width=\"715\" alt=\"image\" src=\"https://user-images.githubusercontent.com/22330612/232125364-d2b3bbac-0b4f-40cb-80ff-f55d8eafef44.png\">\n\n So the team started researching what exactly happened in that case, after some research we found that the Vyper compiler generates the wrong bytecode in that case, it generates the sequence:\n```\nCALL // call\nMLOAD // MLOAD is wrong since the CALL result is already stored in the stack\n```\n\n### Impact\nExample of buggy code:\n```vyper\n@external\ndef returnSome(calling: address, a: uint256) -> bool:\n    success: bool = false\n    success = raw_call(\n        calling,\n        _abi_encode(a, method_id=method_id(\"a(uint256)\")),\n        revert_on_failure=False\n        )\n```\n\nany contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`.\n\n### Patches\nFix by @charles-cooper https://github.com/vyperlang/vyper/commit/851f7a1b3aa2a36fd041e3d0ed38f9355a58c8ae\n\n### Workarounds\nThe simple workaround is always to put  `max_outsize>0`.\nWorkaround example https://github.com/lidofinance/gate-seals/pull/5/files\n\n### References\nLido's fix: https://github.com/lidofinance/gate-seals/pull/5/files\n","fixed_in":["0.3.8"],"id":"GHSA-w9g2-3w7p-72g9","link":"https://osv.dev/vulnerability/GHSA-w9g2-3w7p-72g9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629","GHSA-w9g2-3w7p-72g9"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions 0.3.1 through 0.3.7, the Vyper compiler generates the wrong bytecode. Any contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`. A patch is available and, as of time of publication, anticipated to be part of Vyper 0.3.8. As a workaround, one may always put  `max_outsize>0`.","fixed_in":["0.3.8"],"id":"PYSEC-2023-131","link":"https://osv.dev/vulnerability/PYSEC-2023-131","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2022-29255","GHSA-4v9q-cgpw-cf38"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions prior to 0.3.4 when a calling an external contract with no return value, the contract address (including side effects) could be evaluated twice. This may result in incorrect outcomes for contracts. This issue has been addressed in v0.3.4.","fixed_in":["0.3.4"],"id":"PYSEC-2022-43053","link":"https://osv.dev/vulnerability/PYSEC-2022-43053","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.4":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.7","Programming Language :: Python :: 3.8","Programming Language :: Python :: 3.9"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.4/","requires_dist":["asttokens (==2.0.5)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","wheel","cached-property (==1.5.2) ; python_version < \"3.8\"","importlib-metadata ; python_version < \"3.8\"","pytest (<7.0,>=6.2.5) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-instafail (<1.0,>=0.4) ; extra == 'dev'","pytest-xdist (<3.0,>=2.5) ; extra == 'dev'","pytest-split (<1.0,>=0.7.0) ; extra == 'dev'","pytest-rerunfailures (<11,>=10.2) ; extra == 'dev'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'dev'","py-evm (<0.6,>=0.5.0a3) ; extra == 'dev'","web3 (==5.27.0) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==21.9b0) ; extra == 'dev'","click (<8.1.0) ; extra == 'dev'","flake8 (==3.9.2) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.9.3) ; extra == 'dev'","mypy (==0.910) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==21.9b0) ; extra == 'lint'","click (<8.1.0) ; extra == 'lint'","flake8 (==3.9.2) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.9.3) ; extra == 'lint'","mypy (==0.910) ; extra == 'lint'","pytest (<7.0,>=6.2.5) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-instafail (<1.0,>=0.4) ; extra == 'test'","pytest-xdist (<3.0,>=2.5) ; extra == 'test'","pytest-split (<1.0,>=0.7.0) ; extra == 'test'","pytest-rerunfailures (<11,>=10.2) ; extra == 'test'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'test'","py-evm (<0.6,>=0.5.0a3) ; extra == 'test'","web3 (==5.27.0) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.7,<3.11","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.4","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"435fa17130cad4e2ca4db9364bdd5f003e31a2553a9710548370163891eff854","md5":"f3565926774ea828986865cdedab0a37","sha256":"6fcc796bc7e167bc30b9cd50c8572560e7b586268e0d3e46e622495a54b28d41"},"downloads":-1,"filename":"vyper-0.3.4-py3-none-any.whl","has_sig":false,"md5_digest":"f3565926774ea828986865cdedab0a37","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.7,<3.11","size":282063,"upload_time":"2022-07-27T15:48:25","upload_time_iso_8601":"2022-07-27T15:48:25.871845Z","url":"https://files.pythonhosted.org/packages/43/5f/a17130cad4e2ca4db9364bdd5f003e31a2553a9710548370163891eff854/vyper-0.3.4-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"47540fe52bc0c19c1abfd5f9dfee2c3838ffb7cf8a821993cd5f046a2f488c34","md5":"2d3e5441f015068128b9e1c3d2ddb5bd","sha256":"126cb34e31980558474ce57b7054c9c72d33e3d82170b7479e0178b62a0b6dfd"},"downloads":-1,"filename":"vyper-0.3.4.tar.gz","has_sig":false,"md5_digest":"2d3e5441f015068128b9e1c3d2ddb5bd","packagetype":"sdist","python_version":"source","requires_python":">=3.7,<3.11","size":1179082,"upload_time":"2022-07-27T15:48:27","upload_time_iso_8601":"2022-07-27T15:48:27.721376Z","url":"https://files.pythonhosted.org/packages/47/54/0fe52bc0c19c1abfd5f9dfee2c3838ffb7cf8a821993cd5f046a2f488c34/vyper-0.3.4.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629"],"details":"### Background\nDuring the audit of [Lido's Gate Seals](https://github.com/lidofinance/gate-seals) code [statemind](https://statemind.io) team identified a weird behavior of the code that uses `raw_call`: https://github.com/lidofinance/gate-seals/blob/051593e74df01a4131c485b4fda52e691cd4b7d8/contracts/GateSeal.vy#L164 .\n\nConstruction like this:\n```vyper\nsuccess = raw_call(\n    sealable,\n    _abi_encode(SEAL_DURATION_SECONDS, method_id=method_id(\"pauseFor(uint256)\")),\n    revert_on_failure=False\n)\n```\nwas not fully documented: https://docs.vyperlang.org/en/v0.3.7/built-in-functions.html#raw_call .\n\nThe documentation says that: if `max_outsize=0` it should return nothing and then it says that if `revert_on_failure=False` it should return a `success` flag in the tuple of response, but what if `max_outsize=0`  and `revert_on_failure=False`.\n\n<img width=\"715\" alt=\"image\" src=\"https://user-images.githubusercontent.com/22330612/232125364-d2b3bbac-0b4f-40cb-80ff-f55d8eafef44.png\">\n\n So the team started researching what exactly happened in that case, after some research we found that the Vyper compiler generates the wrong bytecode in that case, it generates the sequence:\n```\nCALL // call\nMLOAD // MLOAD is wrong since the CALL result is already stored in the stack\n```\n\n### Impact\nExample of buggy code:\n```vyper\n@external\ndef returnSome(calling: address, a: uint256) -> bool:\n    success: bool = false\n    success = raw_call(\n        calling,\n        _abi_encode(a, method_id=method_id(\"a(uint256)\")),\n        revert_on_failure=False\n        )\n```\n\nany contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`.\n\n### Patches\nFix by @charles-cooper https://github.com/vyperlang/vyper/commit/851f7a1b3aa2a36fd041e3d0ed38f9355a58c8ae\n\n### Workarounds\nThe simple workaround is always to put  `max_outsize>0`.\nWorkaround example https://github.com/lidofinance/gate-seals/pull/5/files\n\n### References\nLido's fix: https://github.com/lidofinance/gate-seals/pull/5/files\n","fixed_in":["0.3.8"],"id":"GHSA-w9g2-3w7p-72g9","link":"https://osv.dev/vulnerability/GHSA-w9g2-3w7p-72g9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629","GHSA-w9g2-3w7p-72g9"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions 0.3.1 through 0.3.7, the Vyper compiler generates the wrong bytecode. Any contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`. A patch is available and, as of time of publication, anticipated to be part of Vyper 0.3.8. As a workaround, one may always put  `max_outsize>0`.","fixed_in":["0.3.8"],"id":"PYSEC-2023-131","link":"https://osv.dev/vulnerability/PYSEC-2023-131","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42443"],"details":"### Impact\nIn certain conditions, the memory used by the builtins `raw_call`, `create_from_blueprint` and `create_copy_of` can be corrupted.\n\n- For `raw_call`, the argument buffer of the call can be corrupted, leading to incorrect `calldata` in the sub-context.\n- For  `create_from_blueprint` and `create_copy_of`, the buffer for the to-be-deployed bytecode can be corrupted, leading to deploying incorrect bytecode.\n\nBelow are the conditions that must be fulfilled for the corruption to happen for each builtin:\n\n#### `raw_call`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `data` argument of the builtin is `msg.data`.\nand\n- The `to`, `value` or `gas` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\n#### `create_copy_of`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to  uninitialized memory (e.g. calling an internal function)\n\n#### `create_from_blueprint`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- Either no constructor parameters are passed to the builtin or `raw_args` is set to True.\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\nNote: When the builtin is being called from an `internal` function `f` from a function `g`, the issue is not present provided that `g` has written to memory before calling `f`.\n \n#### Examples\n\n\n##### `raw_call`\n\nIn the following contract, calling `bar(1,1)` will return:\n\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000001\n```\ninstead of:\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001\n```\n\n```Python\nidentity: constant(address) = 0x0000000000000000000000000000000000000004\n\n@external\ndef foo():\n    pass\n\n@internal\n@view\ndef get_address()->address:\n    a:uint256 = max_value(uint256) # 0xfff...fff\n    return identity\n@external\ndef bar(f:uint256, u:uint256) -> Bytes[100]:\n    a: Bytes[100] = raw_call(self.get_address(), msg.data, max_outsize=100)\n    return a\n```\n\n##### `create_copy_of`\nIn the following contract, after calling `test()`, the code deployed at `self.created_address` does not match the bytecode at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\n@external\ndef test(target: address) -> address:\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_copy_of(target, salt = keccak256(_abi_encode(target)))\n    return self.created_address\n```\n\n##### `create_from_blueprint`\nIn the following contract, after calling `test()`, the init bytecode used to create the contract deployed at the address `self.created_address` will not match the blueprint bytecode stored at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=keccak256(_abi_encode(target)))\n```\n### Patches\nissue tracking in https://github.com/vyperlang/vyper/issues/3609, patched in #3610 \n\n### Workarounds\n\nThe complex expressions that are being passed as kwargs to the builtin should be cached in memory prior to the call to the builtin. For the last example above, it would be:\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    salt: bytes32 = keccak256(_abi_encode(target))\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=salt)\n```\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-c647-pxm2-c52w","link":"https://osv.dev/vulnerability/GHSA-c647-pxm2-c52w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460"],"details":"### Impact\n`_abi_decode()` does not validate input when it is nested in an expression. the following example gets correctly validated (bounds checked):\n```vyper\nx: int128 = _abi_decode(slice(msg.data, 4, 32), int128)\n```\n\nhowever, the following example is not bounds checked\n```vyper\n@external\ndef abi_decode(x: uint256) -> uint256:\n    a: uint256 = convert(_abi_decode(slice(msg.data, 4, 32), (uint8)), uint256) + 1\n    return a  # abi_decode(256) returns: 257\n```\n\nthe issue can be triggered by constructing an example where the output of `_abi_decode` is not internally passed to `make_setter` (an internal codegen routine) or other input validating routine.\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3626\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-cx2q-hfxr-rj97","link":"https://osv.dev/vulnerability/GHSA-cx2q-hfxr-rj97","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460","GHSA-cx2q-hfxr-rj97"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. The `_abi_decode()` function does not validate input when it is nested in an expression. Uses of `_abi_decode()` can be constructed which allow for bounds checking to be bypassed resulting in incorrect results. This issue has not yet been fixed, but a fix is expected in release `0.3.10`. Users are advised to reference pull request #3626.","fixed_in":["0.3.10"],"id":"PYSEC-2023-191","link":"https://osv.dev/vulnerability/PYSEC-2023-191","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.5":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.7","Programming Language :: Python :: 3.8","Programming Language :: Python :: 3.9"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.5/","requires_dist":["asttokens (==2.0.5)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","wheel","cached-property (==1.5.2) ; python_version < \"3.8\"","importlib-metadata ; python_version < \"3.8\"","pytest (<7.0,>=6.2.5) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-instafail (<1.0,>=0.4) ; extra == 'dev'","pytest-xdist (<3.0,>=2.5) ; extra == 'dev'","pytest-split (<1.0,>=0.7.0) ; extra == 'dev'","pytest-rerunfailures (<11,>=10.2) ; extra == 'dev'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'dev'","py-evm (<0.6,>=0.5.0a3) ; extra == 'dev'","web3 (==5.27.0) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==21.9b0) ; extra == 'dev'","click (<8.1.0) ; extra == 'dev'","flake8 (==3.9.2) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.9.3) ; extra == 'dev'","mypy (==0.910) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==21.9b0) ; extra == 'lint'","click (<8.1.0) ; extra == 'lint'","flake8 (==3.9.2) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.9.3) ; extra == 'lint'","mypy (==0.910) ; extra == 'lint'","pytest (<7.0,>=6.2.5) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-instafail (<1.0,>=0.4) ; extra == 'test'","pytest-xdist (<3.0,>=2.5) ; extra == 'test'","pytest-split (<1.0,>=0.7.0) ; extra == 'test'","pytest-rerunfailures (<11,>=10.2) ; extra == 'test'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'test'","py-evm (<0.6,>=0.5.0a3) ; extra == 'test'","web3 (==5.27.0) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.7,<3.11","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.5","yanked":true,"yanked_reason":"bugfix for issue #3034 addressed in v0.3.6"},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"3c624b3ea785471bcd5854742103fe587ae3eb60392254e6ef5d275e1effd069","md5":"7214bf968e943101e67090d511a141e6","sha256":"8a7e27f17e1f7b3296e3d3c4a9293b7702fe0fa7d1686eefd58ac43586fed188"},"downloads":-1,"filename":"vyper-0.3.5-py3-none-any.whl","has_sig":false,"md5_digest":"7214bf968e943101e67090d511a141e6","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.7,<3.11","size":283072,"upload_time":"2022-08-06T00:10:50","upload_time_iso_8601":"2022-08-06T00:10:50.387689Z","url":"https://files.pythonhosted.org/packages/3c/62/4b3ea785471bcd5854742103fe587ae3eb60392254e6ef5d275e1effd069/vyper-0.3.5-py3-none-any.whl","yanked":true,"yanked_reason":"bugfix for issue #3034 addressed in v0.3.6"},{"comment_text":"","digests":{"blake2b_256":"74a66a707a81b47b4bda02b5b0d74627192f896151a28cf9289a18e0a3c8b94a","md5":"ede2bfdd6a5207afc93479f866f038d2","sha256":"95d36e0037d6cb53964cf0fba53729539757fe65f6a55fd0a928c9c647394b6f"},"downloads":-1,"filename":"vyper-0.3.5.tar.gz","has_sig":false,"md5_digest":"ede2bfdd6a5207afc93479f866f038d2","packagetype":"sdist","python_version":"source","requires_python":">=3.7,<3.11","size":1181503,"upload_time":"2022-08-06T00:10:52","upload_time_iso_8601":"2022-08-06T00:10:52.646629Z","url":"https://files.pythonhosted.org/packages/74/a6/6a707a81b47b4bda02b5b0d74627192f896151a28cf9289a18e0a3c8b94a/vyper-0.3.5.tar.gz","yanked":true,"yanked_reason":"bugfix for issue #3034 addressed in v0.3.6"}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629"],"details":"### Background\nDuring the audit of [Lido's Gate Seals](https://github.com/lidofinance/gate-seals) code [statemind](https://statemind.io) team identified a weird behavior of the code that uses `raw_call`: https://github.com/lidofinance/gate-seals/blob/051593e74df01a4131c485b4fda52e691cd4b7d8/contracts/GateSeal.vy#L164 .\n\nConstruction like this:\n```vyper\nsuccess = raw_call(\n    sealable,\n    _abi_encode(SEAL_DURATION_SECONDS, method_id=method_id(\"pauseFor(uint256)\")),\n    revert_on_failure=False\n)\n```\nwas not fully documented: https://docs.vyperlang.org/en/v0.3.7/built-in-functions.html#raw_call .\n\nThe documentation says that: if `max_outsize=0` it should return nothing and then it says that if `revert_on_failure=False` it should return a `success` flag in the tuple of response, but what if `max_outsize=0`  and `revert_on_failure=False`.\n\n<img width=\"715\" alt=\"image\" src=\"https://user-images.githubusercontent.com/22330612/232125364-d2b3bbac-0b4f-40cb-80ff-f55d8eafef44.png\">\n\n So the team started researching what exactly happened in that case, after some research we found that the Vyper compiler generates the wrong bytecode in that case, it generates the sequence:\n```\nCALL // call\nMLOAD // MLOAD is wrong since the CALL result is already stored in the stack\n```\n\n### Impact\nExample of buggy code:\n```vyper\n@external\ndef returnSome(calling: address, a: uint256) -> bool:\n    success: bool = false\n    success = raw_call(\n        calling,\n        _abi_encode(a, method_id=method_id(\"a(uint256)\")),\n        revert_on_failure=False\n        )\n```\n\nany contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`.\n\n### Patches\nFix by @charles-cooper https://github.com/vyperlang/vyper/commit/851f7a1b3aa2a36fd041e3d0ed38f9355a58c8ae\n\n### Workarounds\nThe simple workaround is always to put  `max_outsize>0`.\nWorkaround example https://github.com/lidofinance/gate-seals/pull/5/files\n\n### References\nLido's fix: https://github.com/lidofinance/gate-seals/pull/5/files\n","fixed_in":["0.3.8"],"id":"GHSA-w9g2-3w7p-72g9","link":"https://osv.dev/vulnerability/GHSA-w9g2-3w7p-72g9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629","GHSA-w9g2-3w7p-72g9"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions 0.3.1 through 0.3.7, the Vyper compiler generates the wrong bytecode. Any contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`. A patch is available and, as of time of publication, anticipated to be part of Vyper 0.3.8. As a workaround, one may always put  `max_outsize>0`.","fixed_in":["0.3.8"],"id":"PYSEC-2023-131","link":"https://osv.dev/vulnerability/PYSEC-2023-131","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42443"],"details":"### Impact\nIn certain conditions, the memory used by the builtins `raw_call`, `create_from_blueprint` and `create_copy_of` can be corrupted.\n\n- For `raw_call`, the argument buffer of the call can be corrupted, leading to incorrect `calldata` in the sub-context.\n- For  `create_from_blueprint` and `create_copy_of`, the buffer for the to-be-deployed bytecode can be corrupted, leading to deploying incorrect bytecode.\n\nBelow are the conditions that must be fulfilled for the corruption to happen for each builtin:\n\n#### `raw_call`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `data` argument of the builtin is `msg.data`.\nand\n- The `to`, `value` or `gas` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\n#### `create_copy_of`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to  uninitialized memory (e.g. calling an internal function)\n\n#### `create_from_blueprint`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- Either no constructor parameters are passed to the builtin or `raw_args` is set to True.\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\nNote: When the builtin is being called from an `internal` function `f` from a function `g`, the issue is not present provided that `g` has written to memory before calling `f`.\n \n#### Examples\n\n\n##### `raw_call`\n\nIn the following contract, calling `bar(1,1)` will return:\n\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000001\n```\ninstead of:\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001\n```\n\n```Python\nidentity: constant(address) = 0x0000000000000000000000000000000000000004\n\n@external\ndef foo():\n    pass\n\n@internal\n@view\ndef get_address()->address:\n    a:uint256 = max_value(uint256) # 0xfff...fff\n    return identity\n@external\ndef bar(f:uint256, u:uint256) -> Bytes[100]:\n    a: Bytes[100] = raw_call(self.get_address(), msg.data, max_outsize=100)\n    return a\n```\n\n##### `create_copy_of`\nIn the following contract, after calling `test()`, the code deployed at `self.created_address` does not match the bytecode at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\n@external\ndef test(target: address) -> address:\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_copy_of(target, salt = keccak256(_abi_encode(target)))\n    return self.created_address\n```\n\n##### `create_from_blueprint`\nIn the following contract, after calling `test()`, the init bytecode used to create the contract deployed at the address `self.created_address` will not match the blueprint bytecode stored at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=keccak256(_abi_encode(target)))\n```\n### Patches\nissue tracking in https://github.com/vyperlang/vyper/issues/3609, patched in #3610 \n\n### Workarounds\n\nThe complex expressions that are being passed as kwargs to the builtin should be cached in memory prior to the call to the builtin. For the last example above, it would be:\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    salt: bytes32 = keccak256(_abi_encode(target))\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=salt)\n```\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-c647-pxm2-c52w","link":"https://osv.dev/vulnerability/GHSA-c647-pxm2-c52w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460"],"details":"### Impact\n`_abi_decode()` does not validate input when it is nested in an expression. the following example gets correctly validated (bounds checked):\n```vyper\nx: int128 = _abi_decode(slice(msg.data, 4, 32), int128)\n```\n\nhowever, the following example is not bounds checked\n```vyper\n@external\ndef abi_decode(x: uint256) -> uint256:\n    a: uint256 = convert(_abi_decode(slice(msg.data, 4, 32), (uint8)), uint256) + 1\n    return a  # abi_decode(256) returns: 257\n```\n\nthe issue can be triggered by constructing an example where the output of `_abi_decode` is not internally passed to `make_setter` (an internal codegen routine) or other input validating routine.\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3626\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-cx2q-hfxr-rj97","link":"https://osv.dev/vulnerability/GHSA-cx2q-hfxr-rj97","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460","GHSA-cx2q-hfxr-rj97"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. The `_abi_decode()` function does not validate input when it is nested in an expression. Uses of `_abi_decode()` can be constructed which allow for bounds checking to be bypassed resulting in incorrect results. This issue has not yet been fixed, but a fix is expected in release `0.3.10`. Users are advised to reference pull request #3626.","fixed_in":["0.3.10"],"id":"PYSEC-2023-191","link":"https://osv.dev/vulnerability/PYSEC-2023-191","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.6":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.7","Programming Language :: Python :: 3.8","Programming Language :: Python :: 3.9"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.6/","requires_dist":["asttokens (==2.0.5)","pycryptodome (<4,>=3.5.1)","semantic-version (==2.8.5)","wheel","cached-property (==1.5.2) ; python_version < \"3.8\"","importlib-metadata ; python_version < \"3.8\"","pytest (<7.0,>=6.2.5) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-instafail (<1.0,>=0.4) ; extra == 'dev'","pytest-xdist (<3.0,>=2.5) ; extra == 'dev'","pytest-split (<1.0,>=0.7.0) ; extra == 'dev'","pytest-rerunfailures (<11,>=10.2) ; extra == 'dev'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'dev'","py-evm (<0.6,>=0.5.0a3) ; extra == 'dev'","web3 (==5.27.0) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark-parser (==0.10.0) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==21.9b0) ; extra == 'dev'","click (<8.1.0) ; extra == 'dev'","flake8 (==3.9.2) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.9.3) ; extra == 'dev'","mypy (==0.910) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==21.9b0) ; extra == 'lint'","click (<8.1.0) ; extra == 'lint'","flake8 (==3.9.2) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.9.3) ; extra == 'lint'","mypy (==0.910) ; extra == 'lint'","pytest (<7.0,>=6.2.5) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-instafail (<1.0,>=0.4) ; extra == 'test'","pytest-xdist (<3.0,>=2.5) ; extra == 'test'","pytest-split (<1.0,>=0.7.0) ; extra == 'test'","pytest-rerunfailures (<11,>=10.2) ; extra == 'test'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'test'","py-evm (<0.6,>=0.5.0a3) ; extra == 'test'","web3 (==5.27.0) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark-parser (==0.10.0) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.7,<3.11","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.6","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"0478704d66ce98c91000e318baae3cfdc0a0bd67836dd3c94727713c4ba1f5b1","md5":"5cf31f95f96abae5f9b928b144b607d8","sha256":"d9d18e8eaed281b4f8b5545fa164215d08ed34c2977ec1cce624347707056909"},"downloads":-1,"filename":"vyper-0.3.6-py3-none-any.whl","has_sig":false,"md5_digest":"5cf31f95f96abae5f9b928b144b607d8","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.7,<3.11","size":283099,"upload_time":"2022-08-06T22:20:08","upload_time_iso_8601":"2022-08-06T22:20:08.415991Z","url":"https://files.pythonhosted.org/packages/04/78/704d66ce98c91000e318baae3cfdc0a0bd67836dd3c94727713c4ba1f5b1/vyper-0.3.6-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"46836b71cea893d18021e76ca9dcc186bcb6346bf3577443572ef3286b038709","md5":"746c946fd3d4310f2ec02fdb502d6d8a","sha256":"f23c3ddadb4a857b9bcc3af4b6df7f3a80ac3c4c81f723d1b2e78afa3e0f3ba6"},"downloads":-1,"filename":"vyper-0.3.6.tar.gz","has_sig":false,"md5_digest":"746c946fd3d4310f2ec02fdb502d6d8a","packagetype":"sdist","python_version":"source","requires_python":">=3.7,<3.11","size":1181946,"upload_time":"2022-08-06T22:20:10","upload_time_iso_8601":"2022-08-06T22:20:10.276099Z","url":"https://files.pythonhosted.org/packages/46/83/6b71cea893d18021e76ca9dcc186bcb6346bf3577443572ef3286b038709/vyper-0.3.6.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629"],"details":"### Background\nDuring the audit of [Lido's Gate Seals](https://github.com/lidofinance/gate-seals) code [statemind](https://statemind.io) team identified a weird behavior of the code that uses `raw_call`: https://github.com/lidofinance/gate-seals/blob/051593e74df01a4131c485b4fda52e691cd4b7d8/contracts/GateSeal.vy#L164 .\n\nConstruction like this:\n```vyper\nsuccess = raw_call(\n    sealable,\n    _abi_encode(SEAL_DURATION_SECONDS, method_id=method_id(\"pauseFor(uint256)\")),\n    revert_on_failure=False\n)\n```\nwas not fully documented: https://docs.vyperlang.org/en/v0.3.7/built-in-functions.html#raw_call .\n\nThe documentation says that: if `max_outsize=0` it should return nothing and then it says that if `revert_on_failure=False` it should return a `success` flag in the tuple of response, but what if `max_outsize=0`  and `revert_on_failure=False`.\n\n<img width=\"715\" alt=\"image\" src=\"https://user-images.githubusercontent.com/22330612/232125364-d2b3bbac-0b4f-40cb-80ff-f55d8eafef44.png\">\n\n So the team started researching what exactly happened in that case, after some research we found that the Vyper compiler generates the wrong bytecode in that case, it generates the sequence:\n```\nCALL // call\nMLOAD // MLOAD is wrong since the CALL result is already stored in the stack\n```\n\n### Impact\nExample of buggy code:\n```vyper\n@external\ndef returnSome(calling: address, a: uint256) -> bool:\n    success: bool = false\n    success = raw_call(\n        calling,\n        _abi_encode(a, method_id=method_id(\"a(uint256)\")),\n        revert_on_failure=False\n        )\n```\n\nany contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`.\n\n### Patches\nFix by @charles-cooper https://github.com/vyperlang/vyper/commit/851f7a1b3aa2a36fd041e3d0ed38f9355a58c8ae\n\n### Workarounds\nThe simple workaround is always to put  `max_outsize>0`.\nWorkaround example https://github.com/lidofinance/gate-seals/pull/5/files\n\n### References\nLido's fix: https://github.com/lidofinance/gate-seals/pull/5/files\n","fixed_in":["0.3.8"],"id":"GHSA-w9g2-3w7p-72g9","link":"https://osv.dev/vulnerability/GHSA-w9g2-3w7p-72g9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629","GHSA-w9g2-3w7p-72g9"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions 0.3.1 through 0.3.7, the Vyper compiler generates the wrong bytecode. Any contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`. A patch is available and, as of time of publication, anticipated to be part of Vyper 0.3.8. As a workaround, one may always put  `max_outsize>0`.","fixed_in":["0.3.8"],"id":"PYSEC-2023-131","link":"https://osv.dev/vulnerability/PYSEC-2023-131","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42443"],"details":"### Impact\nIn certain conditions, the memory used by the builtins `raw_call`, `create_from_blueprint` and `create_copy_of` can be corrupted.\n\n- For `raw_call`, the argument buffer of the call can be corrupted, leading to incorrect `calldata` in the sub-context.\n- For  `create_from_blueprint` and `create_copy_of`, the buffer for the to-be-deployed bytecode can be corrupted, leading to deploying incorrect bytecode.\n\nBelow are the conditions that must be fulfilled for the corruption to happen for each builtin:\n\n#### `raw_call`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `data` argument of the builtin is `msg.data`.\nand\n- The `to`, `value` or `gas` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\n#### `create_copy_of`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to  uninitialized memory (e.g. calling an internal function)\n\n#### `create_from_blueprint`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- Either no constructor parameters are passed to the builtin or `raw_args` is set to True.\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\nNote: When the builtin is being called from an `internal` function `f` from a function `g`, the issue is not present provided that `g` has written to memory before calling `f`.\n \n#### Examples\n\n\n##### `raw_call`\n\nIn the following contract, calling `bar(1,1)` will return:\n\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000001\n```\ninstead of:\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001\n```\n\n```Python\nidentity: constant(address) = 0x0000000000000000000000000000000000000004\n\n@external\ndef foo():\n    pass\n\n@internal\n@view\ndef get_address()->address:\n    a:uint256 = max_value(uint256) # 0xfff...fff\n    return identity\n@external\ndef bar(f:uint256, u:uint256) -> Bytes[100]:\n    a: Bytes[100] = raw_call(self.get_address(), msg.data, max_outsize=100)\n    return a\n```\n\n##### `create_copy_of`\nIn the following contract, after calling `test()`, the code deployed at `self.created_address` does not match the bytecode at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\n@external\ndef test(target: address) -> address:\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_copy_of(target, salt = keccak256(_abi_encode(target)))\n    return self.created_address\n```\n\n##### `create_from_blueprint`\nIn the following contract, after calling `test()`, the init bytecode used to create the contract deployed at the address `self.created_address` will not match the blueprint bytecode stored at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=keccak256(_abi_encode(target)))\n```\n### Patches\nissue tracking in https://github.com/vyperlang/vyper/issues/3609, patched in #3610 \n\n### Workarounds\n\nThe complex expressions that are being passed as kwargs to the builtin should be cached in memory prior to the call to the builtin. For the last example above, it would be:\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    salt: bytes32 = keccak256(_abi_encode(target))\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=salt)\n```\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-c647-pxm2-c52w","link":"https://osv.dev/vulnerability/GHSA-c647-pxm2-c52w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460"],"details":"### Impact\n`_abi_decode()` does not validate input when it is nested in an expression. the following example gets correctly validated (bounds checked):\n```vyper\nx: int128 = _abi_decode(slice(msg.data, 4, 32), int128)\n```\n\nhowever, the following example is not bounds checked\n```vyper\n@external\ndef abi_decode(x: uint256) -> uint256:\n    a: uint256 = convert(_abi_decode(slice(msg.data, 4, 32), (uint8)), uint256) + 1\n    return a  # abi_decode(256) returns: 257\n```\n\nthe issue can be triggered by constructing an example where the output of `_abi_decode` is not internally passed to `make_setter` (an internal codegen routine) or other input validating routine.\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3626\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-cx2q-hfxr-rj97","link":"https://osv.dev/vulnerability/GHSA-cx2q-hfxr-rj97","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460","GHSA-cx2q-hfxr-rj97"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. The `_abi_decode()` function does not validate input when it is nested in an expression. Uses of `_abi_decode()` can be constructed which allow for bounds checking to be bypassed resulting in incorrect results. This issue has not yet been fixed, but a fix is expected in release `0.3.10`. Users are advised to reference pull request #3626.","fixed_in":["0.3.10"],"id":"PYSEC-2023-191","link":"https://osv.dev/vulnerability/PYSEC-2023-191","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.7":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.8","Programming Language :: Python :: 3.9"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.7/","requires_dist":["asttokens (==2.0.5)","pycryptodome (<4,>=3.5.1)","semantic-version (<3,>=2.10)","wheel","cached-property (==1.5.2) ; python_version < \"3.8\"","importlib-metadata ; python_version < \"3.8\"","pytest (<7.0,>=6.2.5) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-instafail (<1.0,>=0.4) ; extra == 'dev'","pytest-xdist (<3.0,>=2.5) ; extra == 'dev'","pytest-split (<1.0,>=0.7.0) ; extra == 'dev'","pytest-rerunfailures (<11,>=10.2) ; extra == 'dev'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'dev'","py-evm (<0.6,>=0.5.0a3) ; extra == 'dev'","web3 (==5.27.0) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark (==1.1.2) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","black (==21.9b0) ; extra == 'dev'","click (<8.1.0) ; extra == 'dev'","flake8 (==3.9.2) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.9.3) ; extra == 'dev'","mypy (==0.910) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<4.0,>=3.0) ; extra == 'dev'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<4.0,>=3.0) ; extra == 'docs'","sphinx-rtd-theme (<0.6,>=0.5) ; extra == 'docs'","black (==21.9b0) ; extra == 'lint'","click (<8.1.0) ; extra == 'lint'","flake8 (==3.9.2) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.9.3) ; extra == 'lint'","mypy (==0.910) ; extra == 'lint'","pytest (<7.0,>=6.2.5) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-instafail (<1.0,>=0.4) ; extra == 'test'","pytest-xdist (<3.0,>=2.5) ; extra == 'test'","pytest-split (<1.0,>=0.7.0) ; extra == 'test'","pytest-rerunfailures (<11,>=10.2) ; extra == 'test'","eth-tester[py-evm] (<0.7,>=0.6.0b6) ; extra == 'test'","py-evm (<0.6,>=0.5.0a3) ; extra == 'test'","web3 (==5.27.0) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark (==1.1.2) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'"],"requires_python":">=3.7,<3.11","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.7","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"17a332e5888c8a4ba8fb0e7fab181377986f234642eea421baea9f3e15e0f6ae","md5":"a2ca589ed5d8bff562f5b7fffc355df1","sha256":"9432db96db9d685ce74423b2bf685b0bcefa7bec39589036cd52bb1635fc1800"},"downloads":-1,"filename":"vyper-0.3.7-py3-none-any.whl","has_sig":false,"md5_digest":"a2ca589ed5d8bff562f5b7fffc355df1","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.7,<3.11","size":288387,"upload_time":"2022-09-27T01:22:11","upload_time_iso_8601":"2022-09-27T01:22:11.888821Z","url":"https://files.pythonhosted.org/packages/17/a3/32e5888c8a4ba8fb0e7fab181377986f234642eea421baea9f3e15e0f6ae/vyper-0.3.7-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"4f5cfeaa07d6a27756bc2f4ff4d997d315f164699dee4a93cb7f0963d30a72b1","md5":"199874ac8ee212d94507bbf8ec0d82a4","sha256":"1874eff683b7034ac376547d566d29fd05780bcec9f875c3d9615a9efc82636a"},"downloads":-1,"filename":"vyper-0.3.7.tar.gz","has_sig":false,"md5_digest":"199874ac8ee212d94507bbf8ec0d82a4","packagetype":"sdist","python_version":"source","requires_python":">=3.7,<3.11","size":1185489,"upload_time":"2022-09-27T01:22:13","upload_time_iso_8601":"2022-09-27T01:22:13.707100Z","url":"https://files.pythonhosted.org/packages/4f/5c/feaa07d6a27756bc2f4ff4d997d315f164699dee4a93cb7f0963d30a72b1/vyper-0.3.7.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629"],"details":"### Background\nDuring the audit of [Lido's Gate Seals](https://github.com/lidofinance/gate-seals) code [statemind](https://statemind.io) team identified a weird behavior of the code that uses `raw_call`: https://github.com/lidofinance/gate-seals/blob/051593e74df01a4131c485b4fda52e691cd4b7d8/contracts/GateSeal.vy#L164 .\n\nConstruction like this:\n```vyper\nsuccess = raw_call(\n    sealable,\n    _abi_encode(SEAL_DURATION_SECONDS, method_id=method_id(\"pauseFor(uint256)\")),\n    revert_on_failure=False\n)\n```\nwas not fully documented: https://docs.vyperlang.org/en/v0.3.7/built-in-functions.html#raw_call .\n\nThe documentation says that: if `max_outsize=0` it should return nothing and then it says that if `revert_on_failure=False` it should return a `success` flag in the tuple of response, but what if `max_outsize=0`  and `revert_on_failure=False`.\n\n<img width=\"715\" alt=\"image\" src=\"https://user-images.githubusercontent.com/22330612/232125364-d2b3bbac-0b4f-40cb-80ff-f55d8eafef44.png\">\n\n So the team started researching what exactly happened in that case, after some research we found that the Vyper compiler generates the wrong bytecode in that case, it generates the sequence:\n```\nCALL // call\nMLOAD // MLOAD is wrong since the CALL result is already stored in the stack\n```\n\n### Impact\nExample of buggy code:\n```vyper\n@external\ndef returnSome(calling: address, a: uint256) -> bool:\n    success: bool = false\n    success = raw_call(\n        calling,\n        _abi_encode(a, method_id=method_id(\"a(uint256)\")),\n        revert_on_failure=False\n        )\n```\n\nany contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`.\n\n### Patches\nFix by @charles-cooper https://github.com/vyperlang/vyper/commit/851f7a1b3aa2a36fd041e3d0ed38f9355a58c8ae\n\n### Workarounds\nThe simple workaround is always to put  `max_outsize>0`.\nWorkaround example https://github.com/lidofinance/gate-seals/pull/5/files\n\n### References\nLido's fix: https://github.com/lidofinance/gate-seals/pull/5/files\n","fixed_in":["0.3.8"],"id":"GHSA-w9g2-3w7p-72g9","link":"https://osv.dev/vulnerability/GHSA-w9g2-3w7p-72g9","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837"],"details":"### Impact\nThe storage allocator does not guard against allocation overflows. This can result in vulnerabilities like the following:\n```vyper\nowner: public(address)\ntake_up_some_space: public(uint256[10])\nbuffer: public(uint256[max_value(uint256)])\n\n@external\ndef initialize():\n    self.owner = msg.sender\n\n@external\ndef foo(idx: uint256, data: uint256):\n    self.buffer[idx] = data\n```\nPer @toonvanhove, \"An attacker can overwrite the owner variable by calling this contract with calldata: `0x04bc52f8 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5 ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` (spaces inserted for readability)\n`0x04bc52f8` is the selector for `foo(uint256, uint256)`, and the last argument `fff...fff` is the new value for the owner variable.\"\n\n### Patches\npatched in 0bb7203b584e771b23536ba065a6efda457161bb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-mgv8-gggw-mrg6","link":"https://osv.dev/vulnerability/GHSA-mgv8-gggw-mrg6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058"],"details":"### Impact\n\nDue to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter.\n\nIn the following example, calling `test` returns `354`, meaning that the variable `a` did store `354` a value out of bound for the type `uint8`.\n\n```Vyper\n@external\ndef test() -> uint16:\n    x:uint8 = 255\n    a:uint8 = 0\n    for i in range(x, x+100):\n        a = i\n    return convert(a,uint16)\n```\n\nThe issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable.\n\nthanks to @trocher for reporting\n\n### Patches\n\npatched in 3de1415ee77a9244eb04bdb695e249d3ec9ed868\n\n### Workarounds\n\n ","fixed_in":["0.3.8"],"id":"GHSA-6r8q-pfpv-7cgj","link":"https://osv.dev/vulnerability/GHSA-6r8q-pfpv-7cgj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146"],"details":"### Impact\nduring codegen, the length word of a dynarray is written before the data, which can result in OOB array access in the case where the dynarray is on both the lhs and rhs of an assignment. here is a minimal example producing the issue:\n```vyper\na:DynArray[uint256,3]\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a = [1,2,3]\n    self.a = empty(DynArray[uint256,3])\n    self.a = [self.a[0],self.a[1],self.a[2]]\n    return self.a # return [1,2,3]\n```\n\nand here is an example demonstrating the issue can cause data corruption across call frames:\n\n```vyper\n@external\ndef test() -> DynArray[uint256,3]:\n    self.a()\n    return self.b() # return [1,2,3]\n\n@internal\ndef a():\n    a: uint256 = 0    \n    b: uint256 = 1    \n    c: uint256 = 2    \n    d: uint256 = 3\n\n@internal\ndef b() -> DynArray[uint256,3]:\n    a: DynArray[uint256,3] = empty(DynArray[uint256,3])\n    a = [a[0],a[1],a[2]]\n    return a\n```\n\nexamples involving append and pop:\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = []\n    c.append(c[0])\n```\n\n```vyper\n@internal\ndef foo():\n    c: DynArray[uint256, 1] = [1]\n    c[0] = c.pop()\n```\n\nthe expected behavior in all of the above cases is to revert due to oob array access.\n\n### Patches\npatched in 4f8289a81206f767df1900ac48f485d90fc87edb\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-3p37-3636-q8wv","link":"https://osv.dev/vulnerability/GHSA-3p37-3636-q8wv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059"],"details":"### Impact\n\nInternal calls to internal functions with more than 1 default argument are compiled incorrectly. Depending on the number of arguments\nprovided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible,\ntypechecking is bypassed. In the `bar()` function in the following code, `self.foo(13)` is compiled to\n`self.foo(13,12)` instead of `self.foo(13,1337)`.\n\n```vyper\n@internal\ndef foo(a:uint256 = 12, b:uint256 = 1337):\n    pass\n\n@internal\ndef bar():\n    self.foo(13)\n```\n\nnote that at the time of publication, the ability to pass kwargs to internal functions is an undocumented feature that does not seem to be widely used.\n\n### Patches\npatched in c3e68c302aa6e1429946473769dd1232145822ac\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.8"],"id":"GHSA-ph9x-4vc9-m39g","link":"https://osv.dev/vulnerability/GHSA-ph9x-4vc9-m39g","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32675"],"details":"### Impact\nin contracts with at least one regular nonpayable function, due to the callvalue check being inside of the selector section, it is possible to send funds to the default function by using less than 4 bytes of calldata, even if the default function is marked `nonpayable`. this applies to contracts compiled with vyper<=0.3.7.\n```vyper\n# @version 0.3.7\n\n# implicitly nonpayable\n@external\ndef foo() -> uint256:\n    return 1\n\n# implicitly nonpayable\n@external\ndef __default__():\n    # could receive ether here\n    pass\n```\n\n### Patches\nthis was fixed by the removal of the global calldatasize check in https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520.\n\n### Workarounds\ndon't use nonpayable default functions\n\n","fixed_in":["0.3.8"],"id":"GHSA-vxmm-cwh2-q762","link":"https://osv.dev/vulnerability/GHSA-vxmm-cwh2-q762","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32059","GHSA-ph9x-4vc9-m39g"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, internal calls with default arguments are compiled incorrectly. Depending on the number of arguments provided in the call, the defaults are added not right-to-left, but left-to-right. If the types are incompatible, typechecking is bypassed. The ability to pass kwargs to internal functions is an undocumented feature that is not well known about. The issue is patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-79","link":"https://osv.dev/vulnerability/PYSEC-2023-79","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-31146","GHSA-3p37-3636-q8wv"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, during codegen, the length word of a dynarray is written before the data, which can result in out-of-bounds array access in the case where the dynarray is on both the lhs and rhs of an assignment. The issue can cause data corruption across call frames. The expected behavior is to revert due to out-of-bounds array access. Version 0.3.8 contains a patch for this issue.","fixed_in":["0.3.8"],"id":"PYSEC-2023-77","link":"https://osv.dev/vulnerability/PYSEC-2023-77","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-32058","GHSA-6r8q-pfpv-7cgj"],"details":"Vyper is a Pythonic smart contract language for the Ethereum virtual machine. Prior to version 0.3.8, due to missing overflow check for loop variables, by assigning the iterator of a loop to a variable, it is possible to overflow the type of the latter. The issue seems to happen only in loops of type `for i in range(a, a + N)` as in loops of type `for i in range(start, stop)` and `for i in range(stop)`, the compiler is able to raise a `TypeMismatch` when trying to overflow the variable. The problem has been patched in version 0.3.8.","fixed_in":["0.3.8"],"id":"PYSEC-2023-78","link":"https://osv.dev/vulnerability/PYSEC-2023-78","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30837","GHSA-mgv8-gggw-mrg6"],"details":"Vyper is a pythonic smart contract language for the EVM. The storage allocator does not guard against allocation overflows in versions prior to 0.3.8. An attacker can overwrite the owner variable. This issue was fixed in version 0.3.8.\n","fixed_in":["0.3.8"],"id":"PYSEC-2023-76","link":"https://osv.dev/vulnerability/PYSEC-2023-76","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-30629","GHSA-w9g2-3w7p-72g9"],"details":"Vyper is a Pythonic Smart Contract Language for the ethereum virtual machine. In versions 0.3.1 through 0.3.7, the Vyper compiler generates the wrong bytecode. Any contract that uses the `raw_call` with `revert_on_failure=False` and `max_outsize=0` receives the wrong response from `raw_call`. Depending on the memory garbage, the result can be either `True` or `False`. A patch is available and, as of time of publication, anticipated to be part of Vyper 0.3.8. As a workaround, one may always put  `max_outsize>0`.","fixed_in":["0.3.8"],"id":"PYSEC-2023-131","link":"https://osv.dev/vulnerability/PYSEC-2023-131","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42443"],"details":"### Impact\nIn certain conditions, the memory used by the builtins `raw_call`, `create_from_blueprint` and `create_copy_of` can be corrupted.\n\n- For `raw_call`, the argument buffer of the call can be corrupted, leading to incorrect `calldata` in the sub-context.\n- For  `create_from_blueprint` and `create_copy_of`, the buffer for the to-be-deployed bytecode can be corrupted, leading to deploying incorrect bytecode.\n\nBelow are the conditions that must be fulfilled for the corruption to happen for each builtin:\n\n#### `raw_call`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `data` argument of the builtin is `msg.data`.\nand\n- The `to`, `value` or `gas` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\n#### `create_copy_of`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to  uninitialized memory (e.g. calling an internal function)\n\n#### `create_from_blueprint`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- Either no constructor parameters are passed to the builtin or `raw_args` is set to True.\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\nNote: When the builtin is being called from an `internal` function `f` from a function `g`, the issue is not present provided that `g` has written to memory before calling `f`.\n \n#### Examples\n\n\n##### `raw_call`\n\nIn the following contract, calling `bar(1,1)` will return:\n\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000001\n```\ninstead of:\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001\n```\n\n```Python\nidentity: constant(address) = 0x0000000000000000000000000000000000000004\n\n@external\ndef foo():\n    pass\n\n@internal\n@view\ndef get_address()->address:\n    a:uint256 = max_value(uint256) # 0xfff...fff\n    return identity\n@external\ndef bar(f:uint256, u:uint256) -> Bytes[100]:\n    a: Bytes[100] = raw_call(self.get_address(), msg.data, max_outsize=100)\n    return a\n```\n\n##### `create_copy_of`\nIn the following contract, after calling `test()`, the code deployed at `self.created_address` does not match the bytecode at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\n@external\ndef test(target: address) -> address:\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_copy_of(target, salt = keccak256(_abi_encode(target)))\n    return self.created_address\n```\n\n##### `create_from_blueprint`\nIn the following contract, after calling `test()`, the init bytecode used to create the contract deployed at the address `self.created_address` will not match the blueprint bytecode stored at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=keccak256(_abi_encode(target)))\n```\n### Patches\nissue tracking in https://github.com/vyperlang/vyper/issues/3609, patched in #3610 \n\n### Workarounds\n\nThe complex expressions that are being passed as kwargs to the builtin should be cached in memory prior to the call to the builtin. For the last example above, it would be:\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    salt: bytes32 = keccak256(_abi_encode(target))\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=salt)\n```\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-c647-pxm2-c52w","link":"https://osv.dev/vulnerability/GHSA-c647-pxm2-c52w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460"],"details":"### Impact\n`_abi_decode()` does not validate input when it is nested in an expression. the following example gets correctly validated (bounds checked):\n```vyper\nx: int128 = _abi_decode(slice(msg.data, 4, 32), int128)\n```\n\nhowever, the following example is not bounds checked\n```vyper\n@external\ndef abi_decode(x: uint256) -> uint256:\n    a: uint256 = convert(_abi_decode(slice(msg.data, 4, 32), (uint8)), uint256) + 1\n    return a  # abi_decode(256) returns: 257\n```\n\nthe issue can be triggered by constructing an example where the output of `_abi_decode` is not internally passed to `make_setter` (an internal codegen routine) or other input validating routine.\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3626\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-cx2q-hfxr-rj97","link":"https://osv.dev/vulnerability/GHSA-cx2q-hfxr-rj97","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460","GHSA-cx2q-hfxr-rj97"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. The `_abi_decode()` function does not validate input when it is nested in an expression. Uses of `_abi_decode()` can be constructed which allow for bounds checking to be bypassed resulting in incorrect results. This issue has not yet been fixed, but a fix is expected in release `0.3.10`. Users are advised to reference pull request #3626.","fixed_in":["0.3.10"],"id":"PYSEC-2023-191","link":"https://osv.dev/vulnerability/PYSEC-2023-191","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-46247"],"details":"### Impact\ncontracts containing large arrays might underallocate the number of slots they need. prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`:\n\nhttps://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197\n\nthe intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed. if `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed.\n\nthe following two example contracts can result in overwriting of the variable `vulnerable`:\n```vyper\nlarge_array: address[2**64 + 1]  # type_.size_in_bytes == 32 * (2**64 + 1); math.ceil(type_.size_in_bytes / 32) < 2**64 + 1\nvulnerable: uint256\n\n# writing to self.large_array[2**64] will overwrite self.vulnerable\n```\n```vyper\nlarge_dynarray: DynArray[address, 2**64]  # Dynarray has a length word in front, its size in bytes is 32 * (2**64 + 1)\nvulnerable: uint256\n\n# writing to self.large_dynarray[2**64 - 1] will overwrite self.vulnerable\n```\n\nnote that in the latter case, the risk of `vulnerable` being overwritten is relatively small, since it would cost roughly $1.45 million trillion USD at today's gas prices (gas price 20gwei, ETH ~= $1800) in order to extend the DynArray to its full container size.\n\n### Patches\npatched by v0.3.8, specifically in commit https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb.","fixed_in":["0.3.8"],"id":"GHSA-6m97-7527-mh74","link":"https://osv.dev/vulnerability/GHSA-6m97-7527-mh74","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.8":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.8/","requires_dist":["asttokens (<3,>=2.0.5)","pycryptodome (<4,>=3.5.1)","semantic-version (<3,>=2.10)","importlib-metadata","wheel","pytest (<7.0,>=6.2.5) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-instafail (<1.0,>=0.4) ; extra == 'dev'","pytest-xdist (<3.0,>=2.5) ; extra == 'dev'","pytest-split (<1.0,>=0.7.0) ; extra == 'dev'","pytest-rerunfailures (<11,>=10.2) ; extra == 'dev'","eth-tester[py-evm] (<0.10,>=0.9.0b1) ; extra == 'dev'","py-evm (<0.8,>=0.7.0a1) ; extra == 'dev'","web3 (==6.0.0) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark (==1.1.2) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","eth-stdlib (==0.2.6) ; extra == 'dev'","black (==23.3.0) ; extra == 'dev'","flake8 (==3.9.2) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.9.3) ; extra == 'dev'","mypy (==0.910) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<7.0,>=6.0) ; extra == 'dev'","sphinx-rtd-theme (<1.3,>=1.2) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<7.0,>=6.0) ; extra == 'docs'","sphinx-rtd-theme (<1.3,>=1.2) ; extra == 'docs'","black (==23.3.0) ; extra == 'lint'","flake8 (==3.9.2) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.9.3) ; extra == 'lint'","mypy (==0.910) ; extra == 'lint'","pytest (<7.0,>=6.2.5) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-instafail (<1.0,>=0.4) ; extra == 'test'","pytest-xdist (<3.0,>=2.5) ; extra == 'test'","pytest-split (<1.0,>=0.7.0) ; extra == 'test'","pytest-rerunfailures (<11,>=10.2) ; extra == 'test'","eth-tester[py-evm] (<0.10,>=0.9.0b1) ; extra == 'test'","py-evm (<0.8,>=0.7.0a1) ; extra == 'test'","web3 (==6.0.0) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark (==1.1.2) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'","eth-stdlib (==0.2.6) ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.8","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"dd47199115b2919692bafad602b25e4cadbfbaec615e27d83f3a44c297f8e586","md5":"5dbf1858422c76c000314b1bfcaad253","sha256":"e36d58a271dacc7e1265226a7e9478f078d7251bf3ecd56ecd67a312529c697a"},"downloads":-1,"filename":"vyper-0.3.8-py3-none-any.whl","has_sig":false,"md5_digest":"5dbf1858422c76c000314b1bfcaad253","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":278844,"upload_time":"2023-05-23T15:01:36","upload_time_iso_8601":"2023-05-23T15:01:36.204001Z","url":"https://files.pythonhosted.org/packages/dd/47/199115b2919692bafad602b25e4cadbfbaec615e27d83f3a44c297f8e586/vyper-0.3.8-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"20f96581c7a6411f908c3c422948b43c4cd17dbeae723d55199d5c2733c82b68","md5":"4798f452e1b3dd202fd6ad6bf3ea842e","sha256":"c773132b15d98004f7e68f297a41b149785caf932bad13ebf3afb72da6f8aa7f"},"downloads":-1,"filename":"vyper-0.3.8.tar.gz","has_sig":false,"md5_digest":"4798f452e1b3dd202fd6ad6bf3ea842e","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":1197620,"upload_time":"2023-05-23T15:01:38","upload_time_iso_8601":"2023-05-23T15:01:38.416074Z","url":"https://files.pythonhosted.org/packages/20/f9/6581c7a6411f908c3c422948b43c4cd17dbeae723d55199d5c2733c82b68/vyper-0.3.8.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902","GHSA-f5x6-7qgp-jhf3"],"details":"Vyper is a Pythonic programming language that targets the Ethereum Virtual Machine (EVM). Prior to version 0.3.10, the ecrecover precompile does not fill the output buffer if the signature does not verify. However, the ecrecover builtin will still return whatever is at memory location 0. This means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature. Version 0.3.10 contains a patch for this issue.","fixed_in":["0.3.9"],"id":"PYSEC-2023-133","link":"https://osv.dev/vulnerability/PYSEC-2023-133","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42443"],"details":"### Impact\nIn certain conditions, the memory used by the builtins `raw_call`, `create_from_blueprint` and `create_copy_of` can be corrupted.\n\n- For `raw_call`, the argument buffer of the call can be corrupted, leading to incorrect `calldata` in the sub-context.\n- For  `create_from_blueprint` and `create_copy_of`, the buffer for the to-be-deployed bytecode can be corrupted, leading to deploying incorrect bytecode.\n\nBelow are the conditions that must be fulfilled for the corruption to happen for each builtin:\n\n#### `raw_call`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `data` argument of the builtin is `msg.data`.\nand\n- The `to`, `value` or `gas` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\n#### `create_copy_of`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to  uninitialized memory (e.g. calling an internal function)\n\n#### `create_from_blueprint`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- Either no constructor parameters are passed to the builtin or `raw_args` is set to True.\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\nNote: When the builtin is being called from an `internal` function `f` from a function `g`, the issue is not present provided that `g` has written to memory before calling `f`.\n \n#### Examples\n\n\n##### `raw_call`\n\nIn the following contract, calling `bar(1,1)` will return:\n\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000001\n```\ninstead of:\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001\n```\n\n```Python\nidentity: constant(address) = 0x0000000000000000000000000000000000000004\n\n@external\ndef foo():\n    pass\n\n@internal\n@view\ndef get_address()->address:\n    a:uint256 = max_value(uint256) # 0xfff...fff\n    return identity\n@external\ndef bar(f:uint256, u:uint256) -> Bytes[100]:\n    a: Bytes[100] = raw_call(self.get_address(), msg.data, max_outsize=100)\n    return a\n```\n\n##### `create_copy_of`\nIn the following contract, after calling `test()`, the code deployed at `self.created_address` does not match the bytecode at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\n@external\ndef test(target: address) -> address:\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_copy_of(target, salt = keccak256(_abi_encode(target)))\n    return self.created_address\n```\n\n##### `create_from_blueprint`\nIn the following contract, after calling `test()`, the init bytecode used to create the contract deployed at the address `self.created_address` will not match the blueprint bytecode stored at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=keccak256(_abi_encode(target)))\n```\n### Patches\nissue tracking in https://github.com/vyperlang/vyper/issues/3609, patched in #3610 \n\n### Workarounds\n\nThe complex expressions that are being passed as kwargs to the builtin should be cached in memory prior to the call to the builtin. For the last example above, it would be:\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    salt: bytes32 = keccak256(_abi_encode(target))\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=salt)\n```\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-c647-pxm2-c52w","link":"https://osv.dev/vulnerability/GHSA-c647-pxm2-c52w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460"],"details":"### Impact\n`_abi_decode()` does not validate input when it is nested in an expression. the following example gets correctly validated (bounds checked):\n```vyper\nx: int128 = _abi_decode(slice(msg.data, 4, 32), int128)\n```\n\nhowever, the following example is not bounds checked\n```vyper\n@external\ndef abi_decode(x: uint256) -> uint256:\n    a: uint256 = convert(_abi_decode(slice(msg.data, 4, 32), (uint8)), uint256) + 1\n    return a  # abi_decode(256) returns: 257\n```\n\nthe issue can be triggered by constructing an example where the output of `_abi_decode` is not internally passed to `make_setter` (an internal codegen routine) or other input validating routine.\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3626\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-cx2q-hfxr-rj97","link":"https://osv.dev/vulnerability/GHSA-cx2q-hfxr-rj97","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460","GHSA-cx2q-hfxr-rj97"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. The `_abi_decode()` function does not validate input when it is nested in an expression. Uses of `_abi_decode()` can be constructed which allow for bounds checking to be bypassed resulting in incorrect results. This issue has not yet been fixed, but a fix is expected in release `0.3.10`. Users are advised to reference pull request #3626.","fixed_in":["0.3.10"],"id":"PYSEC-2023-191","link":"https://osv.dev/vulnerability/PYSEC-2023-191","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.3.9":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.3.9/","requires_dist":["asttokens (<3,>=2.0.5)","pycryptodome (<4,>=3.5.1)","semantic-version (<3,>=2.10)","importlib-metadata","wheel","pytest (<7.0,>=6.2.5) ; extra == 'dev'","pytest-cov (<3.0,>=2.10) ; extra == 'dev'","pytest-instafail (<1.0,>=0.4) ; extra == 'dev'","pytest-xdist (<3.0,>=2.5) ; extra == 'dev'","pytest-split (<1.0,>=0.7.0) ; extra == 'dev'","pytest-rerunfailures (<11,>=10.2) ; extra == 'dev'","eth-tester[py-evm] (<0.10,>=0.9.0b1) ; extra == 'dev'","py-evm (<0.8,>=0.7.0a1) ; extra == 'dev'","web3 (==6.0.0) ; extra == 'dev'","tox (<4.0,>=3.15) ; extra == 'dev'","lark (==1.1.2) ; extra == 'dev'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'dev'","eth-stdlib (==0.2.6) ; extra == 'dev'","black (==23.3.0) ; extra == 'dev'","flake8 (==3.9.2) ; extra == 'dev'","flake8-bugbear (==20.1.4) ; extra == 'dev'","flake8-use-fstring (==1.1) ; extra == 'dev'","isort (==5.9.3) ; extra == 'dev'","mypy (==0.910) ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx (<7.0,>=6.0) ; extra == 'dev'","sphinx-rtd-theme (<1.3,>=1.2) ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx (<7.0,>=6.0) ; extra == 'docs'","sphinx-rtd-theme (<1.3,>=1.2) ; extra == 'docs'","black (==23.3.0) ; extra == 'lint'","flake8 (==3.9.2) ; extra == 'lint'","flake8-bugbear (==20.1.4) ; extra == 'lint'","flake8-use-fstring (==1.1) ; extra == 'lint'","isort (==5.9.3) ; extra == 'lint'","mypy (==0.910) ; extra == 'lint'","pytest (<7.0,>=6.2.5) ; extra == 'test'","pytest-cov (<3.0,>=2.10) ; extra == 'test'","pytest-instafail (<1.0,>=0.4) ; extra == 'test'","pytest-xdist (<3.0,>=2.5) ; extra == 'test'","pytest-split (<1.0,>=0.7.0) ; extra == 'test'","pytest-rerunfailures (<11,>=10.2) ; extra == 'test'","eth-tester[py-evm] (<0.10,>=0.9.0b1) ; extra == 'test'","py-evm (<0.8,>=0.7.0a1) ; extra == 'test'","web3 (==6.0.0) ; extra == 'test'","tox (<4.0,>=3.15) ; extra == 'test'","lark (==1.1.2) ; extra == 'test'","hypothesis[lark] (<6.0,>=5.37.1) ; extra == 'test'","eth-stdlib (==0.2.6) ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.3.9","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"999098786f7811d234516f1c9e0221de5ec4f52957882ed948f489db8e27f5e9","md5":"936bfe01170d3d8ed62c335838635de6","sha256":"eed86456068ddbf5329de831fb51c4e2741ac786d75bd86df925d1d0569ce8e9"},"downloads":-1,"filename":"vyper-0.3.9-py3-none-any.whl","has_sig":false,"md5_digest":"936bfe01170d3d8ed62c335838635de6","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":278723,"upload_time":"2023-05-29T15:36:54","upload_time_iso_8601":"2023-05-29T15:36:54.507484Z","url":"https://files.pythonhosted.org/packages/99/90/98786f7811d234516f1c9e0221de5ec4f52957882ed948f489db8e27f5e9/vyper-0.3.9-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"7813a843e7fefd7fa97cf1cf20ba2164b6c155b1b4575ca56ef01f5cf4f71e74","md5":"c5d23c870dd1059cb574f3fea31b5edc","sha256":"e140521f8a91060b32f953bd5f3a2c59e74ceb9475953a3d9a5d82f794fd3800"},"downloads":-1,"filename":"vyper-0.3.9.tar.gz","has_sig":false,"md5_digest":"c5d23c870dd1059cb574f3fea31b5edc","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":1197718,"upload_time":"2023-05-29T15:36:56","upload_time_iso_8601":"2023-05-29T15:36:56.521238Z","url":"https://files.pythonhosted.org/packages/78/13/a843e7fefd7fa97cf1cf20ba2164b6c155b1b4575ca56ef01f5cf4f71e74/vyper-0.3.9.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-37902"],"details":"### Impact\nthe ecrecover precompile does not fill the output buffer if the signature does not verify, see https://github.com/ethereum/go-ethereum/blob/b058cf454b3bdc7e770e2b3cec83a0bcb48f55ee/core/vm/contracts.go#L188. however, the ecrecover builtin will still return whatever is at memory location 0.\n\nthis means that the if the compiler has been convinced to write to the 0 memory location with specially crafted data (generally, this can happen with a hashmap access or immutable read) just before the ecrecover, a signature check might pass on an invalid signature.\n\nA contract search was performed. Most uses of `ecrecover` are used for erc2612-style permit implementations, which typically look like:\n\n```vyper\n    assert _owner != empty(address)\n    assert block.timestamp <= _deadline\n                  \n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(   \n            b\"\\x19\\x01\",\n            self.DOMAIN_SEPARATOR,\n            keccak256(_abi_encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\n        )         \n    )             \n    assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\n```\n\nin this case, the immutable `PERMIT_TYPEHASH` is loaded into `ecrecover`'s output buffer right before `ecrecover()`, and so the output of `ecrecover()` here when the signature is invalid will be the value of `PERMIT_TYPEHASH`. in this case, since `PERMIT_TYPEHASH` is not a valid address, it will never compare `==` to `_owner`, and so the behaviour is exactly the same as if `ecrecover()` returned 0 in this case.\n\nin general, a contract could have unexpected behavior (i.e. mistakenly pass this style of signature check) if an immutable representing a real address (ex. `OWNER`) was read right before the `ecrecover` operation.\n\n### Patches\nv0.3.10 (with 019a37ab98ff53f04fecfadf602b6cd5ac748f7f and #3586)\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-f5x6-7qgp-jhf3","link":"https://osv.dev/vulnerability/GHSA-f5x6-7qgp-jhf3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-39363","GHSA-5824-cm3x-3c38"],"details":"Vyer is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). In versions 0.2.15, 0.2.16 and 0.3.0, named re-entrancy locks are allocated incorrectly. Each function using a named re-entrancy lock gets a unique lock regardless of the key, allowing cross-function re-entrancy in contracts compiled with the susceptible versions. A specific set of conditions is required to result in misbehavior of affected contracts, specifically: a `.vy` contract compiled with `vyper` versions `0.2.15`, `0.2.16`, or `0.3.0`; a primary function that utilizes the `@nonreentrant` decorator with a specific `key` and does not strictly follow the check-effects-interaction pattern (i.e. contains an external call to an untrusted party before storage updates); and a secondary function that utilizes the same `key` and would be affected by the improper state caused by the primary function. Version 0.3.1 contains a fix for this issue.","fixed_in":[],"id":"PYSEC-2023-142","link":"https://osv.dev/vulnerability/PYSEC-2023-142","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052"],"details":"### Impact\nThe order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order.\n• For `uint256_addmod(a,b,c)` and `uint256_mulmod(a,b,c)`, the order is `c,a,b`.\n• For `ecadd(a,b)` and `ecmul(a,b)`, the order is `b,a`.\n\nNote that this behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. \n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3583\n\n### Workarounds\nWhen using builtins from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-4hg4-9mf5-wxxq","link":"https://osv.dev/vulnerability/GHSA-4hg4-9mf5-wxxq","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015","GHSA-g2xh-c426-v8mf"],"details":"Vyper is a Pythonic Smart Contract Language. For the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right. `unsafe_add, unsafe_sub, unsafe_mul, unsafe_div, pow_mod256, |, &, ^ (bitwise operators), bitwise_or (deprecated), bitwise_and (deprecated), bitwise_xor (deprecated), raw_call, <, >, <=, >=, ==, !=, in, not in (when lhs and rhs are enums)`. This behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect: state modifying external call , state modifying internal call, `raw_call`, `pop()` when used on a Dynamic Array stored in the storage, `create_minimal_proxy_to`, `create_copy_of`, `create_from_blueprint`. This issue has not yet been patched. Users are advised to make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-167","link":"https://osv.dev/vulnerability/PYSEC-2023-167","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-41052","GHSA-4hg4-9mf5-wxxq"],"details":"Vyper is a Pythonic Smart Contract Language. In affected versions the order of evaluation of the arguments of the builtin functions `uint256_addmod`, `uint256_mulmod`, `ecadd` and `ecmul` does not follow source order. This behaviour is problematic when the evaluation of one of the arguments produces side effects that other arguments depend on. A patch is currently being developed on pull request #3583. When using builtins from the list above, users should make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.","fixed_in":["0.3.10rc1"],"id":"PYSEC-2023-168","link":"https://osv.dev/vulnerability/PYSEC-2023-168","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42441"],"details":"### Impact\n\nLocks of the type `@nonreentrant(\"\")` or `@nonreentrant('')` do not produce reentrancy checks at runtime.\n\n```Vyper\n@nonreentrant(\"\") # unprotected\n@external\ndef bar():\n    pass\n\n@nonreentrant(\"lock\") # protected\n@external\ndef foo():\n    pass\n```\n### Patches\n\nPatched in #3605\n\n### Workarounds\n\nThe lock name should be a non-empty string.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-3hg2-r75x-g69m","link":"https://osv.dev/vulnerability/GHSA-3hg2-r75x-g69m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42443"],"details":"### Impact\nIn certain conditions, the memory used by the builtins `raw_call`, `create_from_blueprint` and `create_copy_of` can be corrupted.\n\n- For `raw_call`, the argument buffer of the call can be corrupted, leading to incorrect `calldata` in the sub-context.\n- For  `create_from_blueprint` and `create_copy_of`, the buffer for the to-be-deployed bytecode can be corrupted, leading to deploying incorrect bytecode.\n\nBelow are the conditions that must be fulfilled for the corruption to happen for each builtin:\n\n#### `raw_call`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `data` argument of the builtin is `msg.data`.\nand\n- The `to`, `value` or `gas` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\n#### `create_copy_of`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to  uninitialized memory (e.g. calling an internal function)\n\n#### `create_from_blueprint`\n- memory is not fully initialized, ex. all parameters to an external function live in calldata\nand\n- Either no constructor parameters are passed to the builtin or `raw_args` is set to True.\nand\n- The `value` or `salt` passed to the builtin is some complex expression that results in writing to uninitialized memory (e.g. calling an internal function)\n\nNote: When the builtin is being called from an `internal` function `f` from a function `g`, the issue is not present provided that `g` has written to memory before calling `f`.\n \n#### Examples\n\n\n##### `raw_call`\n\nIn the following contract, calling `bar(1,1)` will return:\n\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000001\n```\ninstead of:\n``` Python\nae42e95100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001\n```\n\n```Python\nidentity: constant(address) = 0x0000000000000000000000000000000000000004\n\n@external\ndef foo():\n    pass\n\n@internal\n@view\ndef get_address()->address:\n    a:uint256 = max_value(uint256) # 0xfff...fff\n    return identity\n@external\ndef bar(f:uint256, u:uint256) -> Bytes[100]:\n    a: Bytes[100] = raw_call(self.get_address(), msg.data, max_outsize=100)\n    return a\n```\n\n##### `create_copy_of`\nIn the following contract, after calling `test()`, the code deployed at `self.created_address` does not match the bytecode at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\n@external\ndef test(target: address) -> address:\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_copy_of(target, salt = keccak256(_abi_encode(target)))\n    return self.created_address\n```\n\n##### `create_from_blueprint`\nIn the following contract, after calling `test()`, the init bytecode used to create the contract deployed at the address `self.created_address` will not match the blueprint bytecode stored at `target`.\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    # The expression in salt= is complex and will require to store to memory\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=keccak256(_abi_encode(target)))\n```\n### Patches\nissue tracking in https://github.com/vyperlang/vyper/issues/3609, patched in #3610 \n\n### Workarounds\n\nThe complex expressions that are being passed as kwargs to the builtin should be cached in memory prior to the call to the builtin. For the last example above, it would be:\n\n``` Vyper\ncreated_address: public(address)\n\nsalt: constant(bytes32) = keccak256(\"kebab\")\n\n@external\n@payable\ndef test(target: address):\n    salt: bytes32 = keccak256(_abi_encode(target))\n    self.created_address = create_from_blueprint(target, code_offset=0, salt=salt)\n```\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-c647-pxm2-c52w","link":"https://osv.dev/vulnerability/GHSA-c647-pxm2-c52w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460"],"details":"### Impact\n`_abi_decode()` does not validate input when it is nested in an expression. the following example gets correctly validated (bounds checked):\n```vyper\nx: int128 = _abi_decode(slice(msg.data, 4, 32), int128)\n```\n\nhowever, the following example is not bounds checked\n```vyper\n@external\ndef abi_decode(x: uint256) -> uint256:\n    a: uint256 = convert(_abi_decode(slice(msg.data, 4, 32), (uint8)), uint256) + 1\n    return a  # abi_decode(256) returns: 257\n```\n\nthe issue can be triggered by constructing an example where the output of `_abi_decode` is not internally passed to `make_setter` (an internal codegen routine) or other input validating routine.\n\n### Patches\nhttps://github.com/vyperlang/vyper/pull/3626\n\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.3.10"],"id":"GHSA-cx2q-hfxr-rj97","link":"https://osv.dev/vulnerability/GHSA-cx2q-hfxr-rj97","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-42460","GHSA-cx2q-hfxr-rj97"],"details":"Vyper is a Pythonic Smart Contract Language for the EVM. The `_abi_decode()` function does not validate input when it is nested in an expression. Uses of `_abi_decode()` can be constructed which allow for bounds checking to be bypassed resulting in incorrect results. This issue has not yet been fixed, but a fix is expected in release `0.3.10`. Users are advised to reference pull request #3626.","fixed_in":["0.3.10"],"id":"PYSEC-2023-191","link":"https://osv.dev/vulnerability/PYSEC-2023-191","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419","GHSA-2q8v-3gqq-4f8p"],"details":"Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. The `concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function). A contract search was performed and no vulnerable contracts were found in production. The buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing. However, certainly not all usages of concat will result in overwritten valid data as we require it to be in an internal function and close to the return statement where other memory allocations don't occur. This issue has been addressed in 0.4.0.","fixed_in":["0.4.0b1"],"id":"PYSEC-2024-103","link":"https://osv.dev/vulnerability/PYSEC-2024-103","source":"osv","summary":null,"withdrawn":null}]},"0.4.0":{"info":{"author":"Vyper Team","author_email":null,"bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11","Programming Language :: Python :: 3.12"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":null,"maintainer_email":null,"name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":["dev","lint","test"],"release_url":"https://pypi.org/project/vyper/0.4.0/","requires_dist":["cbor2<6,>=5.4.6","asttokens<3,>=2.0.5","pycryptodome<4,>=3.5.1","packaging<24,>=23.1","importlib-metadata","wheel","ipython; extra == \"dev\"","pre-commit; extra == \"dev\"","pyinstaller; extra == \"dev\"","twine; extra == \"dev\"","pytest<9.0,>=8.0; extra == \"dev\"","pytest-cov<5.0,>=4.1; extra == \"dev\"","pytest-instafail<1.0,>=0.4; extra == \"dev\"","pytest-xdist<3.4,>=3.0; extra == \"dev\"","pytest-split<1.0,>=0.7.0; extra == \"dev\"","eth-abi<6.0.0,>=5.0.0; extra == \"dev\"","py-evm<0.11,>=0.10.1b1; extra == \"dev\"","lark==1.1.9; extra == \"dev\"","hypothesis[lark]<7.0,>=6.0; extra == \"dev\"","eth-stdlib==0.2.7; extra == \"dev\"","eth-account==0.12.2; extra == \"dev\"","setuptools; extra == \"dev\"","hexbytes>=1.2; extra == \"dev\"","pyrevm>=0.3.2; extra == \"dev\"","black==23.12.0; extra == \"dev\"","flake8==6.1.0; extra == \"dev\"","flake8-bugbear==23.12.2; extra == \"dev\"","flake8-use-fstring==1.4; extra == \"dev\"","isort==5.13.2; extra == \"dev\"","mypy==1.5; extra == \"dev\"","black==23.12.0; extra == \"lint\"","flake8==6.1.0; extra == \"lint\"","flake8-bugbear==23.12.2; extra == \"lint\"","flake8-use-fstring==1.4; extra == \"lint\"","isort==5.13.2; extra == \"lint\"","mypy==1.5; extra == \"lint\"","pytest<9.0,>=8.0; extra == \"test\"","pytest-cov<5.0,>=4.1; extra == \"test\"","pytest-instafail<1.0,>=0.4; extra == \"test\"","pytest-xdist<3.4,>=3.0; extra == \"test\"","pytest-split<1.0,>=0.7.0; extra == \"test\"","eth-abi<6.0.0,>=5.0.0; extra == \"test\"","py-evm<0.11,>=0.10.1b1; extra == \"test\"","lark==1.1.9; extra == \"test\"","hypothesis[lark]<7.0,>=6.0; extra == \"test\"","eth-stdlib==0.2.7; extra == \"test\"","eth-account==0.12.2; extra == \"test\"","setuptools; extra == \"test\"","hexbytes>=1.2; extra == \"test\"","pyrevm>=0.3.2; extra == \"test\""],"requires_python":"<4,>=3.10","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"370b7c14ae8aec83187a67d8c13a4fdff9bc4d72d9ef822ec7ce026b301a00cb","md5":"e0443bf14aa8924539ba4120bc5d8517","sha256":"22d7e1eca229e95a909dc971ff5b1685c8379404e3fc3b7b84dbc59b5de1c262"},"downloads":-1,"filename":"vyper-0.4.0-py3-none-any.whl","has_sig":false,"md5_digest":"e0443bf14aa8924539ba4120bc5d8517","packagetype":"bdist_wheel","python_version":"py3","requires_python":"<4,>=3.10","size":338856,"upload_time":"2024-06-20T17:00:41","upload_time_iso_8601":"2024-06-20T17:00:41.592217Z","url":"https://files.pythonhosted.org/packages/37/0b/7c14ae8aec83187a67d8c13a4fdff9bc4d72d9ef822ec7ce026b301a00cb/vyper-0.4.0-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"2b09befae43f33161cf817590337f5ea12e8849e401eaaca9eeea22852ae90d1","md5":"5b66b4315875acefed315b76a2765e0c","sha256":"9687145c6a0bf42de52e92202ce9a913648d3c657ac8e5cfb9b35a100dc47e34"},"downloads":-1,"filename":"vyper-0.4.0.tar.gz","has_sig":false,"md5_digest":"5b66b4315875acefed315b76a2765e0c","packagetype":"sdist","python_version":"source","requires_python":"<4,>=3.10","size":672136,"upload_time":"2024-06-20T17:00:44","upload_time_iso_8601":"2024-06-20T17:00:44.269306Z","url":"https://files.pythonhosted.org/packages/2b/09/befae43f33161cf817590337f5ea12e8849e401eaaca9eeea22852ae90d1/vyper-0.4.0.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null}]},"0.4.0b1":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0b1/","requires_dist":["cbor2 <6,>=5.4.6","asttokens <3,>=2.0.5","pycryptodome <4,>=3.5.1","packaging <24,>=23.1","importlib-metadata","wheel","pytest <7.0,>=6.2.5 ; extra == 'dev'","pytest-cov <3.0,>=2.10 ; extra == 'dev'","pytest-instafail <1.0,>=0.4 ; extra == 'dev'","pytest-xdist <3.0,>=2.5 ; extra == 'dev'","pytest-split <1.0,>=0.7.0 ; extra == 'dev'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'dev'","py-evm <0.8,>=0.7.0a1 ; extra == 'dev'","web3 ==6.0.0 ; extra == 'dev'","tox <4.0,>=3.15 ; extra == 'dev'","lark ==1.1.2 ; extra == 'dev'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'dev'","eth-stdlib ==0.2.6 ; extra == 'dev'","black ==23.12.0 ; extra == 'dev'","flake8 ==6.1.0 ; extra == 'dev'","flake8-bugbear ==23.12.2 ; extra == 'dev'","flake8-use-fstring ==1.4 ; extra == 'dev'","isort ==5.13.2 ; extra == 'dev'","mypy ==1.5 ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx <7.0,>=6.0 ; extra == 'dev'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx <7.0,>=6.0 ; extra == 'docs'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'docs'","black ==23.12.0 ; extra == 'lint'","flake8 ==6.1.0 ; extra == 'lint'","flake8-bugbear ==23.12.2 ; extra == 'lint'","flake8-use-fstring ==1.4 ; extra == 'lint'","isort ==5.13.2 ; extra == 'lint'","mypy ==1.5 ; extra == 'lint'","pytest <7.0,>=6.2.5 ; extra == 'test'","pytest-cov <3.0,>=2.10 ; extra == 'test'","pytest-instafail <1.0,>=0.4 ; extra == 'test'","pytest-xdist <3.0,>=2.5 ; extra == 'test'","pytest-split <1.0,>=0.7.0 ; extra == 'test'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'test'","py-evm <0.8,>=0.7.0a1 ; extra == 'test'","web3 ==6.0.0 ; extra == 'test'","tox <4.0,>=3.15 ; extra == 'test'","lark ==1.1.2 ; extra == 'test'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'test'","eth-stdlib ==0.2.6 ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0b1","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"e77e26d8c667cc5452cab57491612c4ab21092e92f241777a5a51e1467bb8828","md5":"c1b3c3c01440587263b0f87c2067d7ab","sha256":"8bbaa5c73bc1dfc7d560fcf0f28ef1efc1acceacf6cfff23c52eb5aee2c31a93"},"downloads":-1,"filename":"vyper-0.4.0b1-py3-none-any.whl","has_sig":false,"md5_digest":"c1b3c3c01440587263b0f87c2067d7ab","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":305479,"upload_time":"2024-02-26T19:45:44","upload_time_iso_8601":"2024-02-26T19:45:44.404167Z","url":"https://files.pythonhosted.org/packages/e7/7e/26d8c667cc5452cab57491612c4ab21092e92f241777a5a51e1467bb8828/vyper-0.4.0b1-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"1d5ee3b4ad2a98a4c3be10196f80e7c82f2ba7d5fa06e20c269ba2635131b3fe","md5":"77d28ee4ecbfd4f5c0bc02b3418ac6af","sha256":"76eb06a9d1b7f1b2101a703ace2624fdeb244431a0396aff5d5cccb5503fc629"},"downloads":-1,"filename":"vyper-0.4.0b1.tar.gz","has_sig":false,"md5_digest":"77d28ee4ecbfd4f5c0bc02b3418ac6af","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":1279509,"upload_time":"2024-02-26T19:45:46","upload_time_iso_8601":"2024-02-26T19:45:46.190264Z","url":"https://files.pythonhosted.org/packages/1d/5e/e3b4ad2a98a4c3be10196f80e7c82f2ba7d5fa06e20c269ba2635131b3fe/vyper-0.4.0b1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.0b2":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0b2/","requires_dist":["cbor2 <6,>=5.4.6","asttokens <3,>=2.0.5","pycryptodome <4,>=3.5.1","packaging <24,>=23.1","importlib-metadata","wheel","pytest <7.0,>=6.2.5 ; extra == 'dev'","pytest-cov <3.0,>=2.10 ; extra == 'dev'","pytest-instafail <1.0,>=0.4 ; extra == 'dev'","pytest-xdist <3.0,>=2.5 ; extra == 'dev'","pytest-split <1.0,>=0.7.0 ; extra == 'dev'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'dev'","eth-abi <5.0.0,>=4.0.0 ; extra == 'dev'","py-evm <0.8,>=0.7.0a1 ; extra == 'dev'","web3 ==6.0.0 ; extra == 'dev'","tox <4.0,>=3.15 ; extra == 'dev'","lark ==1.1.2 ; extra == 'dev'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'dev'","eth-stdlib ==0.2.6 ; extra == 'dev'","black ==23.12.0 ; extra == 'dev'","flake8 ==6.1.0 ; extra == 'dev'","flake8-bugbear ==23.12.2 ; extra == 'dev'","flake8-use-fstring ==1.4 ; extra == 'dev'","isort ==5.13.2 ; extra == 'dev'","mypy ==1.5 ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx <7.0,>=6.0 ; extra == 'dev'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx <7.0,>=6.0 ; extra == 'docs'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'docs'","black ==23.12.0 ; extra == 'lint'","flake8 ==6.1.0 ; extra == 'lint'","flake8-bugbear ==23.12.2 ; extra == 'lint'","flake8-use-fstring ==1.4 ; extra == 'lint'","isort ==5.13.2 ; extra == 'lint'","mypy ==1.5 ; extra == 'lint'","pytest <7.0,>=6.2.5 ; extra == 'test'","pytest-cov <3.0,>=2.10 ; extra == 'test'","pytest-instafail <1.0,>=0.4 ; extra == 'test'","pytest-xdist <3.0,>=2.5 ; extra == 'test'","pytest-split <1.0,>=0.7.0 ; extra == 'test'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'test'","eth-abi <5.0.0,>=4.0.0 ; extra == 'test'","py-evm <0.8,>=0.7.0a1 ; extra == 'test'","web3 ==6.0.0 ; extra == 'test'","tox <4.0,>=3.15 ; extra == 'test'","lark ==1.1.2 ; extra == 'test'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'test'","eth-stdlib ==0.2.6 ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0b2","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"3b6b653dc61d7136a78da5720226de53f2bf9ed3f9b9e7376424191a62d941de","md5":"1eb28e0459855fc0c03c3048d3faff0b","sha256":"54cbcd24989c8b4b824326e03e5f4977a69feae8cf65a930553c5510996660fe"},"downloads":-1,"filename":"vyper-0.4.0b2-py3-none-any.whl","has_sig":false,"md5_digest":"1eb28e0459855fc0c03c3048d3faff0b","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":305688,"upload_time":"2024-03-05T19:02:50","upload_time_iso_8601":"2024-03-05T19:02:50.456820Z","url":"https://files.pythonhosted.org/packages/3b/6b/653dc61d7136a78da5720226de53f2bf9ed3f9b9e7376424191a62d941de/vyper-0.4.0b2-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"d8ab15f4845084a9220aa1ec45df2990656ea9347511416919a0cf326a046274","md5":"ecc0e4e2b236f717e4d015f689b0f5fa","sha256":"0769ad887adf466781ee5410b5b83f0120241496be9a4b35873e9bcd09405084"},"downloads":-1,"filename":"vyper-0.4.0b2.tar.gz","has_sig":false,"md5_digest":"ecc0e4e2b236f717e4d015f689b0f5fa","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":1282332,"upload_time":"2024-03-05T19:02:52","upload_time_iso_8601":"2024-03-05T19:02:52.629194Z","url":"https://files.pythonhosted.org/packages/d8/ab/15f4845084a9220aa1ec45df2990656ea9347511416919a0cf326a046274/vyper-0.4.0b2.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.0b3":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0b3/","requires_dist":["cbor2 <6,>=5.4.6","asttokens <3,>=2.0.5","pycryptodome <4,>=3.5.1","packaging <24,>=23.1","importlib-metadata","wheel","pytest <7.0,>=6.2.5 ; extra == 'dev'","pytest-cov <3.0,>=2.10 ; extra == 'dev'","pytest-instafail <1.0,>=0.4 ; extra == 'dev'","pytest-xdist <3.0,>=2.5 ; extra == 'dev'","pytest-split <1.0,>=0.7.0 ; extra == 'dev'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'dev'","eth-abi <5.0.0,>=4.0.0 ; extra == 'dev'","py-evm <0.8,>=0.7.0a1 ; extra == 'dev'","web3 ==6.0.0 ; extra == 'dev'","tox <4.0,>=3.15 ; extra == 'dev'","lark ==1.1.9 ; extra == 'dev'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'dev'","eth-stdlib ==0.2.6 ; extra == 'dev'","black ==23.12.0 ; extra == 'dev'","flake8 ==6.1.0 ; extra == 'dev'","flake8-bugbear ==23.12.2 ; extra == 'dev'","flake8-use-fstring ==1.4 ; extra == 'dev'","isort ==5.13.2 ; extra == 'dev'","mypy ==1.5 ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx <7.0,>=6.0 ; extra == 'dev'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx <7.0,>=6.0 ; extra == 'docs'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'docs'","black ==23.12.0 ; extra == 'lint'","flake8 ==6.1.0 ; extra == 'lint'","flake8-bugbear ==23.12.2 ; extra == 'lint'","flake8-use-fstring ==1.4 ; extra == 'lint'","isort ==5.13.2 ; extra == 'lint'","mypy ==1.5 ; extra == 'lint'","pytest <7.0,>=6.2.5 ; extra == 'test'","pytest-cov <3.0,>=2.10 ; extra == 'test'","pytest-instafail <1.0,>=0.4 ; extra == 'test'","pytest-xdist <3.0,>=2.5 ; extra == 'test'","pytest-split <1.0,>=0.7.0 ; extra == 'test'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'test'","eth-abi <5.0.0,>=4.0.0 ; extra == 'test'","py-evm <0.8,>=0.7.0a1 ; extra == 'test'","web3 ==6.0.0 ; extra == 'test'","tox <4.0,>=3.15 ; extra == 'test'","lark ==1.1.9 ; extra == 'test'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'test'","eth-stdlib ==0.2.6 ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0b3","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"3a6bd5c41db42c1faefb8ecbcc906961956e7e6b4187e9a787d7e1ab2e911ee0","md5":"0f170a403964570aea622cddfad0b55b","sha256":"d0f95f8dedc911c98b46029b17054f7acbab28ba1d2e12d53e917a4eba05b957"},"downloads":-1,"filename":"vyper-0.4.0b3-py3-none-any.whl","has_sig":false,"md5_digest":"0f170a403964570aea622cddfad0b55b","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":306757,"upload_time":"2024-03-06T20:54:11","upload_time_iso_8601":"2024-03-06T20:54:11.842648Z","url":"https://files.pythonhosted.org/packages/3a/6b/d5c41db42c1faefb8ecbcc906961956e7e6b4187e9a787d7e1ab2e911ee0/vyper-0.4.0b3-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"10264f64c928d6e01926f988ca18e9f0a600aa1104b967c526daf8798a4948a2","md5":"56a781a7fcdcb971b0d5f023468f5cfc","sha256":"870af9bfba36f732cc249f151dadc48a8616391e382250f110dc6d46d0d42822"},"downloads":-1,"filename":"vyper-0.4.0b3.tar.gz","has_sig":false,"md5_digest":"56a781a7fcdcb971b0d5f023468f5cfc","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":1284765,"upload_time":"2024-03-06T20:54:14","upload_time_iso_8601":"2024-03-06T20:54:14.018253Z","url":"https://files.pythonhosted.org/packages/10/26/4f64c928d6e01926f988ca18e9f0a600aa1104b967c526daf8798a4948a2/vyper-0.4.0b3.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.0b4":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0b4/","requires_dist":["cbor2 <6,>=5.4.6","asttokens <3,>=2.0.5","pycryptodome <4,>=3.5.1","packaging <24,>=23.1","importlib-metadata","wheel","pytest <7.0,>=6.2.5 ; extra == 'dev'","pytest-cov <3.0,>=2.10 ; extra == 'dev'","pytest-instafail <1.0,>=0.4 ; extra == 'dev'","pytest-xdist <3.0,>=2.5 ; extra == 'dev'","pytest-split <1.0,>=0.7.0 ; extra == 'dev'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'dev'","eth-abi <5.0.0,>=4.0.0 ; extra == 'dev'","py-evm <0.8,>=0.7.0a1 ; extra == 'dev'","web3 ==6.0.0 ; extra == 'dev'","tox <4.0,>=3.15 ; extra == 'dev'","lark ==1.1.9 ; extra == 'dev'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'dev'","eth-stdlib ==0.2.6 ; extra == 'dev'","black ==23.12.0 ; extra == 'dev'","flake8 ==6.1.0 ; extra == 'dev'","flake8-bugbear ==23.12.2 ; extra == 'dev'","flake8-use-fstring ==1.4 ; extra == 'dev'","isort ==5.13.2 ; extra == 'dev'","mypy ==1.5 ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx <7.0,>=6.0 ; extra == 'dev'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx <7.0,>=6.0 ; extra == 'docs'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'docs'","black ==23.12.0 ; extra == 'lint'","flake8 ==6.1.0 ; extra == 'lint'","flake8-bugbear ==23.12.2 ; extra == 'lint'","flake8-use-fstring ==1.4 ; extra == 'lint'","isort ==5.13.2 ; extra == 'lint'","mypy ==1.5 ; extra == 'lint'","pytest <7.0,>=6.2.5 ; extra == 'test'","pytest-cov <3.0,>=2.10 ; extra == 'test'","pytest-instafail <1.0,>=0.4 ; extra == 'test'","pytest-xdist <3.0,>=2.5 ; extra == 'test'","pytest-split <1.0,>=0.7.0 ; extra == 'test'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'test'","eth-abi <5.0.0,>=4.0.0 ; extra == 'test'","py-evm <0.8,>=0.7.0a1 ; extra == 'test'","web3 ==6.0.0 ; extra == 'test'","tox <4.0,>=3.15 ; extra == 'test'","lark ==1.1.9 ; extra == 'test'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'test'","eth-stdlib ==0.2.6 ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0b4","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"6c8c838eea8416d4af711d6909dfe3637f42e89398ee4b05df9dd567a9ebc838","md5":"3568276f7e89e9d4f1efd00ae91e69f1","sha256":"1879a16d5c6da93ddbaaecdd959050590c578c5cc2c2702ebfe06f1201b8012f"},"downloads":-1,"filename":"vyper-0.4.0b4-py3-none-any.whl","has_sig":false,"md5_digest":"3568276f7e89e9d4f1efd00ae91e69f1","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":306503,"upload_time":"2024-03-08T05:14:18","upload_time_iso_8601":"2024-03-08T05:14:18.578639Z","url":"https://files.pythonhosted.org/packages/6c/8c/838eea8416d4af711d6909dfe3637f42e89398ee4b05df9dd567a9ebc838/vyper-0.4.0b4-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"4ebbb696165114484653840045f0a0f2a0ef3fabb49cc62ad5f3839e7dcde55d","md5":"ac4fa6947d6af620a0f7249b0bf06690","sha256":"0b26dd9a5815d43173f54bc0d07024cd8af2ba6ccd967a30a26d22705d1922a7"},"downloads":-1,"filename":"vyper-0.4.0b4.tar.gz","has_sig":false,"md5_digest":"ac4fa6947d6af620a0f7249b0bf06690","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":619127,"upload_time":"2024-03-08T05:14:21","upload_time_iso_8601":"2024-03-08T05:14:21.659840Z","url":"https://files.pythonhosted.org/packages/4e/bb/b696165114484653840045f0a0f2a0ef3fabb49cc62ad5f3839e7dcde55d/vyper-0.4.0b4.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.0b5":{"info":{"author":"Vyper Team","author_email":"","bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11"],"description_content_type":"text/markdown","docs_url":null,"download_url":"","downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":"","maintainer_email":"","name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0b5/","requires_dist":["cbor2 <6,>=5.4.6","asttokens <3,>=2.0.5","pycryptodome <4,>=3.5.1","packaging <24,>=23.1","importlib-metadata","wheel","pytest <7.0,>=6.2.5 ; extra == 'dev'","pytest-cov <3.0,>=2.10 ; extra == 'dev'","pytest-instafail <1.0,>=0.4 ; extra == 'dev'","pytest-xdist <3.0,>=2.5 ; extra == 'dev'","pytest-split <1.0,>=0.7.0 ; extra == 'dev'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'dev'","eth-abi <5.0.0,>=4.0.0 ; extra == 'dev'","py-evm <0.8,>=0.7.0a1 ; extra == 'dev'","web3 ==6.0.0 ; extra == 'dev'","tox <4.0,>=3.15 ; extra == 'dev'","lark ==1.1.9 ; extra == 'dev'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'dev'","eth-stdlib ==0.2.6 ; extra == 'dev'","black ==23.12.0 ; extra == 'dev'","flake8 ==6.1.0 ; extra == 'dev'","flake8-bugbear ==23.12.2 ; extra == 'dev'","flake8-use-fstring ==1.4 ; extra == 'dev'","isort ==5.13.2 ; extra == 'dev'","mypy ==1.5 ; extra == 'dev'","recommonmark ; extra == 'dev'","sphinx <7.0,>=6.0 ; extra == 'dev'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'dev'","ipython ; extra == 'dev'","pre-commit ; extra == 'dev'","pyinstaller ; extra == 'dev'","twine ; extra == 'dev'","recommonmark ; extra == 'docs'","sphinx <7.0,>=6.0 ; extra == 'docs'","sphinx-rtd-theme <1.3,>=1.2 ; extra == 'docs'","black ==23.12.0 ; extra == 'lint'","flake8 ==6.1.0 ; extra == 'lint'","flake8-bugbear ==23.12.2 ; extra == 'lint'","flake8-use-fstring ==1.4 ; extra == 'lint'","isort ==5.13.2 ; extra == 'lint'","mypy ==1.5 ; extra == 'lint'","pytest <7.0,>=6.2.5 ; extra == 'test'","pytest-cov <3.0,>=2.10 ; extra == 'test'","pytest-instafail <1.0,>=0.4 ; extra == 'test'","pytest-xdist <3.0,>=2.5 ; extra == 'test'","pytest-split <1.0,>=0.7.0 ; extra == 'test'","eth-tester[py-evm] <0.10,>=0.9.0b1 ; extra == 'test'","eth-abi <5.0.0,>=4.0.0 ; extra == 'test'","py-evm <0.8,>=0.7.0a1 ; extra == 'test'","web3 ==6.0.0 ; extra == 'test'","tox <4.0,>=3.15 ; extra == 'test'","lark ==1.1.9 ; extra == 'test'","hypothesis[lark] <6.0,>=5.37.1 ; extra == 'test'","eth-stdlib ==0.2.6 ; extra == 'test'"],"requires_python":">=3.10,<4","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0b5","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"a9b5a8cd35dbe82130e73e9a5a1259c662e1f5fc2ee9a8bd344c1af2735a8335","md5":"a83ee231779b7b2cc7735964fd1835d8","sha256":"e31ebefc4a55f80b2f3a52f0647a9809ff4d09d1bac3f2e8670b72befffb5093"},"downloads":-1,"filename":"vyper-0.4.0b5-py3-none-any.whl","has_sig":false,"md5_digest":"a83ee231779b7b2cc7735964fd1835d8","packagetype":"bdist_wheel","python_version":"py3","requires_python":">=3.10,<4","size":307765,"upload_time":"2024-03-12T15:42:16","upload_time_iso_8601":"2024-03-12T15:42:16.610665Z","url":"https://files.pythonhosted.org/packages/a9/b5/a8cd35dbe82130e73e9a5a1259c662e1f5fc2ee9a8bd344c1af2735a8335/vyper-0.4.0b5-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"3be60afbd488246e6d2dff3b19c0a1908f39ec2d7ab4361282f54342ef400890","md5":"cf3c6a648e484babe90c3e2662406c0d","sha256":"86a26ddf9a52e69f90f0f32ddbf3400d210dec6e499c73d00a8ef64e23a7b7a2"},"downloads":-1,"filename":"vyper-0.4.0b5.tar.gz","has_sig":false,"md5_digest":"cf3c6a648e484babe90c3e2662406c0d","packagetype":"sdist","python_version":"source","requires_python":">=3.10,<4","size":624557,"upload_time":"2024-03-12T15:42:19","upload_time_iso_8601":"2024-03-12T15:42:19.111543Z","url":"https://files.pythonhosted.org/packages/3b/e6/0afbd488246e6d2dff3b19c0a1908f39ec2d7ab4361282f54342ef400890/vyper-0.4.0b5.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24561"],"details":"## Summary\n\n[The bounds check for slices](https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457) does not account for the ability for `start + length` to overflow when the values aren't literals. \n\nIf a `slice()` function uses a non-literal argument for the `start`  or `length` variable, this creates the ability for an attacker to overflow the bounds check. \n\nThis issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the `length` slot of the respective array.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\ntracking in issue https://github.com/vyperlang/vyper/issues/3756.\npatched in https://github.com/vyperlang/vyper/pull/3818.\n\n## Details\nHere the flow for `storage` is supposed, but it is generalizable also for the other locations.\n\nWhen calling `slice()` on a storage value, there are compile time bounds checks if the `start` and `length` values are literals, but of course this cannot happen if they are passed values:\n\n```python\nif not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal < 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal > arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n```\n\nAt runtime, we perform the following equivalent check, but the runtime check does not account for overflows:\n```python\n[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n```\n\nThe storage `slice()` function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the `start`  or `length` value, they can force an overflow and access an unrelated storage slot.\n\nIn most cases, this will mean they have the ability to forcibly return `0` for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.\n\n## POC: OOB access\n\nFor simplicity, take the following Vyper contract, which takes an argument to determine where in a `Bytes[64]` bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.\n\n```python\n# @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -> Bytes[64]:\n    return slice(self.x, start, 64)\n```\n\nWe can use the following manual storage to demonstrate the vulnerability:\n```json\n{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n```\n\nIf we run the following test, passing `max - 63` as the `start` value, we will overflow the bounds check, but access the storage slot at `1 + (2**256 - 63) / 32`, which is what was set in the above storage layout:\n```solidity\nfunction test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n```\n\nThe result is that we return the secret value from storage:\n```\nLogs:\n0x0000...00002a\n```\n## POC: `length` corruption\n`OOG` exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the `length` slot is set with the original input value.\n\n```python\nd: public(Bytes[256])\n\t\n@external\ndef test():\n\tx : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n\tself.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n\t# s : Bytes[256] = slice(self.d, 1, x)\n\tassert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n```\nThe corruption of `length` can be then used to read dirty memory:\n```python\n@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n```\n\n## Impact\n\nThe built-in `slice()` method can be used for OOB accesses or the corruption of the `length` slot.","fixed_in":["0.4.0"],"id":"GHSA-9x7f-gwxq-6f2c","link":"https://osv.dev/vulnerability/GHSA-9x7f-gwxq-6f2c","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.0b6":{"info":{"author":"Vyper Team","author_email":null,"bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11","Programming Language :: Python :: 3.12"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":null,"maintainer_email":null,"name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0b6/","requires_dist":["cbor2<6,>=5.4.6","asttokens<3,>=2.0.5","pycryptodome<4,>=3.5.1","packaging<24,>=23.1","importlib-metadata","wheel","ipython; extra == \"dev\"","pre-commit; extra == \"dev\"","pyinstaller; extra == \"dev\"","twine; extra == \"dev\"","pytest<9.0,>=8.0; extra == \"dev\"","pytest-cov<5.0,>=4.1; extra == \"dev\"","pytest-instafail<1.0,>=0.4; extra == \"dev\"","pytest-xdist<3.4,>=3.0; extra == \"dev\"","pytest-split<1.0,>=0.7.0; extra == \"dev\"","eth-tester[py-evm]<0.11,>=0.10.0b4; extra == \"dev\"","eth-abi<5.0.0,>=4.0.0; extra == \"dev\"","py-evm<0.11,>=0.10.0b4; extra == \"dev\"","web3==6.0.0; extra == \"dev\"","lark==1.1.9; extra == \"dev\"","hypothesis[lark]<7.0,>=6.0; extra == \"dev\"","eth-stdlib==0.2.7; extra == \"dev\"","setuptools; extra == \"dev\"","hexbytes>=1.2; extra == \"dev\"","black==23.12.0; extra == \"dev\"","flake8==6.1.0; extra == \"dev\"","flake8-bugbear==23.12.2; extra == \"dev\"","flake8-use-fstring==1.4; extra == \"dev\"","isort==5.13.2; extra == \"dev\"","mypy==1.5; extra == \"dev\"","black==23.12.0; extra == \"lint\"","flake8==6.1.0; extra == \"lint\"","flake8-bugbear==23.12.2; extra == \"lint\"","flake8-use-fstring==1.4; extra == \"lint\"","isort==5.13.2; extra == \"lint\"","mypy==1.5; extra == \"lint\"","pytest<9.0,>=8.0; extra == \"test\"","pytest-cov<5.0,>=4.1; extra == \"test\"","pytest-instafail<1.0,>=0.4; extra == \"test\"","pytest-xdist<3.4,>=3.0; extra == \"test\"","pytest-split<1.0,>=0.7.0; extra == \"test\"","eth-tester[py-evm]<0.11,>=0.10.0b4; extra == \"test\"","eth-abi<5.0.0,>=4.0.0; extra == \"test\"","py-evm<0.11,>=0.10.0b4; extra == \"test\"","web3==6.0.0; extra == \"test\"","lark==1.1.9; extra == \"test\"","hypothesis[lark]<7.0,>=6.0; extra == \"test\"","eth-stdlib==0.2.7; extra == \"test\"","setuptools; extra == \"test\"","hexbytes>=1.2; extra == \"test\""],"requires_python":"<4,>=3.10","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0b6","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"1d6835cb2c6eb7ba0ac22550850b3913d8e6ae12015d1d0d472994379237901e","md5":"0b9e41043626d8ee1e0e43a97c95c1c4","sha256":"44822915fa7e28dd1d6f9acc81639848ec3c642ea6d1610545fcd351a747f7ed"},"downloads":-1,"filename":"vyper-0.4.0b6-py3-none-any.whl","has_sig":false,"md5_digest":"0b9e41043626d8ee1e0e43a97c95c1c4","packagetype":"bdist_wheel","python_version":"py3","requires_python":"<4,>=3.10","size":314340,"upload_time":"2024-04-06T17:26:06","upload_time_iso_8601":"2024-04-06T17:26:06.672614Z","url":"https://files.pythonhosted.org/packages/1d/68/35cb2c6eb7ba0ac22550850b3913d8e6ae12015d1d0d472994379237901e/vyper-0.4.0b6-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"0d6f4306799f357154c6da07c211b52ad14309ae994a60c2e979147ffc88bc8b","md5":"74709944a1ebb25a37ef6f2ec88dfa31","sha256":"b5c0d8e9ca19ad120d64465b97593d97782272cd6af6f66b08ff32517902d8eb"},"downloads":-1,"filename":"vyper-0.4.0b6.tar.gz","has_sig":false,"md5_digest":"74709944a1ebb25a37ef6f2ec88dfa31","packagetype":"sdist","python_version":"source","requires_python":"<4,>=3.10","size":636021,"upload_time":"2024-04-06T17:26:08","upload_time_iso_8601":"2024-04-06T17:26:08.864277Z","url":"https://files.pythonhosted.org/packages/0d/6f/4306799f357154c6da07c211b52ad14309ae994a60c2e979147ffc88bc8b/vyper-0.4.0b6.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.0rc1":{"info":{"author":"Vyper Team","author_email":null,"bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11","Programming Language :: Python :: 3.12"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":null,"maintainer_email":null,"name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0rc1/","requires_dist":["cbor2<6,>=5.4.6","asttokens<3,>=2.0.5","pycryptodome<4,>=3.5.1","packaging<24,>=23.1","importlib-metadata","wheel","ipython; extra == \"dev\"","pre-commit; extra == \"dev\"","pyinstaller; extra == \"dev\"","twine; extra == \"dev\"","pytest<9.0,>=8.0; extra == \"dev\"","pytest-cov<5.0,>=4.1; extra == \"dev\"","pytest-instafail<1.0,>=0.4; extra == \"dev\"","pytest-xdist<3.4,>=3.0; extra == \"dev\"","pytest-split<1.0,>=0.7.0; extra == \"dev\"","eth-tester[py-evm]<0.11,>=0.10.0b4; extra == \"dev\"","eth-abi<5.0.0,>=4.0.0; extra == \"dev\"","py-evm<0.11,>=0.10.0b4; extra == \"dev\"","web3==6.0.0; extra == \"dev\"","lark==1.1.9; extra == \"dev\"","hypothesis[lark]<7.0,>=6.0; extra == \"dev\"","eth-stdlib==0.2.7; extra == \"dev\"","setuptools; extra == \"dev\"","hexbytes>=1.2; extra == \"dev\"","black==23.12.0; extra == \"dev\"","flake8==6.1.0; extra == \"dev\"","flake8-bugbear==23.12.2; extra == \"dev\"","flake8-use-fstring==1.4; extra == \"dev\"","isort==5.13.2; extra == \"dev\"","mypy==1.5; extra == \"dev\"","black==23.12.0; extra == \"lint\"","flake8==6.1.0; extra == \"lint\"","flake8-bugbear==23.12.2; extra == \"lint\"","flake8-use-fstring==1.4; extra == \"lint\"","isort==5.13.2; extra == \"lint\"","mypy==1.5; extra == \"lint\"","pytest<9.0,>=8.0; extra == \"test\"","pytest-cov<5.0,>=4.1; extra == \"test\"","pytest-instafail<1.0,>=0.4; extra == \"test\"","pytest-xdist<3.4,>=3.0; extra == \"test\"","pytest-split<1.0,>=0.7.0; extra == \"test\"","eth-tester[py-evm]<0.11,>=0.10.0b4; extra == \"test\"","eth-abi<5.0.0,>=4.0.0; extra == \"test\"","py-evm<0.11,>=0.10.0b4; extra == \"test\"","web3==6.0.0; extra == \"test\"","lark==1.1.9; extra == \"test\"","hypothesis[lark]<7.0,>=6.0; extra == \"test\"","eth-stdlib==0.2.7; extra == \"test\"","setuptools; extra == \"test\"","hexbytes>=1.2; extra == \"test\""],"requires_python":"<4,>=3.10","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0rc1","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"2a43664de838efb9065e4a8042d7b7d62eb3e9d47588c7dbde11b8a5a10b0e3f","md5":"45cfeb345fefa077cff838381b01951a","sha256":"36eb35ff76e442ce42f476271833737ba5dcd42ee99124201617c62726f86bf2"},"downloads":-1,"filename":"vyper-0.4.0rc1-py3-none-any.whl","has_sig":false,"md5_digest":"45cfeb345fefa077cff838381b01951a","packagetype":"bdist_wheel","python_version":"py3","requires_python":"<4,>=3.10","size":315011,"upload_time":"2024-04-10T17:15:58","upload_time_iso_8601":"2024-04-10T17:15:58.850902Z","url":"https://files.pythonhosted.org/packages/2a/43/664de838efb9065e4a8042d7b7d62eb3e9d47588c7dbde11b8a5a10b0e3f/vyper-0.4.0rc1-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"d4552a5b5075f2f443a1f5205c5addeb7043765389df0bb9f8ac2ec197565fc7","md5":"4a1d74a450a7b02315151c670681ee9e","sha256":"e03865a8b373c64b1bf7281da66624883791a1f0533e4ab2241c54dea0db2725"},"downloads":-1,"filename":"vyper-0.4.0rc1.tar.gz","has_sig":false,"md5_digest":"4a1d74a450a7b02315151c670681ee9e","packagetype":"sdist","python_version":"source","requires_python":"<4,>=3.10","size":638222,"upload_time":"2024-04-10T17:16:01","upload_time_iso_8601":"2024-04-10T17:16:01.859127Z","url":"https://files.pythonhosted.org/packages/d4/55/2a5b5075f2f443a1f5205c5addeb7043765389df0bb9f8ac2ec197565fc7/vyper-0.4.0rc1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.0rc2":{"info":{"author":"Vyper Team","author_email":null,"bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11","Programming Language :: Python :: 3.12"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":null,"maintainer_email":null,"name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0rc2/","requires_dist":["cbor2<6,>=5.4.6","asttokens<3,>=2.0.5","pycryptodome<4,>=3.5.1","packaging<24,>=23.1","importlib-metadata","wheel","ipython; extra == \"dev\"","pre-commit; extra == \"dev\"","pyinstaller; extra == \"dev\"","twine; extra == \"dev\"","pytest<9.0,>=8.0; extra == \"dev\"","pytest-cov<5.0,>=4.1; extra == \"dev\"","pytest-instafail<1.0,>=0.4; extra == \"dev\"","pytest-xdist<3.4,>=3.0; extra == \"dev\"","pytest-split<1.0,>=0.7.0; extra == \"dev\"","eth-tester[py-evm]<0.11,>=0.10.0b4; extra == \"dev\"","eth-abi<5.0.0,>=4.0.0; extra == \"dev\"","py-evm<0.11,>=0.10.0b4; extra == \"dev\"","web3==6.0.0; extra == \"dev\"","lark==1.1.9; extra == \"dev\"","hypothesis[lark]<7.0,>=6.0; extra == \"dev\"","eth-stdlib==0.2.7; extra == \"dev\"","setuptools; extra == \"dev\"","hexbytes>=1.2; extra == \"dev\"","black==23.12.0; extra == \"dev\"","flake8==6.1.0; extra == \"dev\"","flake8-bugbear==23.12.2; extra == \"dev\"","flake8-use-fstring==1.4; extra == \"dev\"","isort==5.13.2; extra == \"dev\"","mypy==1.5; extra == \"dev\"","black==23.12.0; extra == \"lint\"","flake8==6.1.0; extra == \"lint\"","flake8-bugbear==23.12.2; extra == \"lint\"","flake8-use-fstring==1.4; extra == \"lint\"","isort==5.13.2; extra == \"lint\"","mypy==1.5; extra == \"lint\"","pytest<9.0,>=8.0; extra == \"test\"","pytest-cov<5.0,>=4.1; extra == \"test\"","pytest-instafail<1.0,>=0.4; extra == \"test\"","pytest-xdist<3.4,>=3.0; extra == \"test\"","pytest-split<1.0,>=0.7.0; extra == \"test\"","eth-tester[py-evm]<0.11,>=0.10.0b4; extra == \"test\"","eth-abi<5.0.0,>=4.0.0; extra == \"test\"","py-evm<0.11,>=0.10.0b4; extra == \"test\"","web3==6.0.0; extra == \"test\"","lark==1.1.9; extra == \"test\"","hypothesis[lark]<7.0,>=6.0; extra == \"test\"","eth-stdlib==0.2.7; extra == \"test\"","setuptools; extra == \"test\"","hexbytes>=1.2; extra == \"test\""],"requires_python":"<4,>=3.10","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0rc2","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"c3d0f2bdb85a62491e544d0dd0d6beedad9d97003af919c039305a2381dafdcc","md5":"bde3377a5fd96d8419f0977bf7e920de","sha256":"2c4306bb80163558116e31daddc1283570348da941f9a58e6d711afcb807733b"},"downloads":-1,"filename":"vyper-0.4.0rc2-py3-none-any.whl","has_sig":false,"md5_digest":"bde3377a5fd96d8419f0977bf7e920de","packagetype":"bdist_wheel","python_version":"py3","requires_python":"<4,>=3.10","size":315627,"upload_time":"2024-04-14T02:52:30","upload_time_iso_8601":"2024-04-14T02:52:30.248889Z","url":"https://files.pythonhosted.org/packages/c3/d0/f2bdb85a62491e544d0dd0d6beedad9d97003af919c039305a2381dafdcc/vyper-0.4.0rc2-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"a1a0e6b8290a5743ac83695cfc932b016ddce981b0fa48cba85c5779b1730598","md5":"84468be4f0dcb1d6d178b44784b63dd0","sha256":"c6d676f589d88a5ad23e2320913bbf865f96f1e6a5afc39188fdc1b2add4ec6f"},"downloads":-1,"filename":"vyper-0.4.0rc2.tar.gz","has_sig":false,"md5_digest":"84468be4f0dcb1d6d178b44784b63dd0","packagetype":"sdist","python_version":"source","requires_python":"<4,>=3.10","size":640830,"upload_time":"2024-04-14T02:52:32","upload_time_iso_8601":"2024-04-14T02:52:32.540353Z","url":"https://files.pythonhosted.org/packages/a1/a0/e6b8290a5743ac83695cfc932b016ddce981b0fa48cba85c5779b1730598/vyper-0.4.0rc2.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32481"],"details":"### Summary\n\nWhen looping over a `range` of the form `range(start, start + N)`, if `start` is negative, the execution will always revert.\n \n### Details\n\nThis issue is caused by an incorrect assertion inserted by the code generation of the range (`stmt.parse_For_range()`):\n\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/codegen/stmt.py#L286-L287\n\nThis assertion was introduced in https://github.com/vyperlang/vyper/commit/3de1415ee77a9244eb04bdb695e249d3ec9ed868 to fix https://github.com/advisories/GHSA-6r8q-pfpv-7cgj. The issue arises when `start` is signed, instead of using `sle`, `le` is used and `start` is interpreted as an unsigned integer for the comparison. If it is a negative number, its 255th bit is set to `1` and is hence interpreted as a very large unsigned integer making the assertion always fail. \n### PoC\n\n```Vyper\n@external\ndef foo():\n    x:int256 = min_value(int256)\n    # revert when it should not since we have the following assertion that fails:\n    # [assert, [le, min_value(int256), max_value(int256) + 1 - 10]],\n    for i in range(x, x + 10):\n        pass\n```\n\n### Patches\n\npatched in v0.4.0, specifically, https://github.com/vyperlang/vyper/pull/3679 disallows this form of `range()`.\n\n### Impact\n\nAny contract having a `range(start, start + N)` where `start` is a signed integer with the possibility for `start` to be negative is affected. If a call goes through the loop while supplying a negative `start` the execution will revert.","fixed_in":["0.4.0"],"id":"GHSA-ppx5-q359-pvwj","link":"https://osv.dev/vulnerability/GHSA-ppx5-q359-pvwj","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.0rc3":{"info":{"author":"Vyper Team","author_email":null,"bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11","Programming Language :: Python :: 3.12"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":null,"maintainer_email":null,"name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0rc3/","requires_dist":["cbor2<6,>=5.4.6","asttokens<3,>=2.0.5","pycryptodome<4,>=3.5.1","packaging<24,>=23.1","importlib-metadata","wheel","ipython; extra == \"dev\"","pre-commit; extra == \"dev\"","pyinstaller; extra == \"dev\"","twine; extra == \"dev\"","pytest<9.0,>=8.0; extra == \"dev\"","pytest-cov<5.0,>=4.1; extra == \"dev\"","pytest-instafail<1.0,>=0.4; extra == \"dev\"","pytest-xdist<3.4,>=3.0; extra == \"dev\"","pytest-split<1.0,>=0.7.0; extra == \"dev\"","eth-abi<6.0.0,>=5.0.0; extra == \"dev\"","py-evm<0.11,>=0.10.1b1; extra == \"dev\"","lark==1.1.9; extra == \"dev\"","hypothesis[lark]<7.0,>=6.0; extra == \"dev\"","eth-stdlib==0.2.7; extra == \"dev\"","eth-account==0.12.2; extra == \"dev\"","setuptools; extra == \"dev\"","hexbytes>=1.2; extra == \"dev\"","pyrevm>=0.3.2; extra == \"dev\"","black==23.12.0; extra == \"dev\"","flake8==6.1.0; extra == \"dev\"","flake8-bugbear==23.12.2; extra == \"dev\"","flake8-use-fstring==1.4; extra == \"dev\"","isort==5.13.2; extra == \"dev\"","mypy==1.5; extra == \"dev\"","black==23.12.0; extra == \"lint\"","flake8==6.1.0; extra == \"lint\"","flake8-bugbear==23.12.2; extra == \"lint\"","flake8-use-fstring==1.4; extra == \"lint\"","isort==5.13.2; extra == \"lint\"","mypy==1.5; extra == \"lint\"","pytest<9.0,>=8.0; extra == \"test\"","pytest-cov<5.0,>=4.1; extra == \"test\"","pytest-instafail<1.0,>=0.4; extra == \"test\"","pytest-xdist<3.4,>=3.0; extra == \"test\"","pytest-split<1.0,>=0.7.0; extra == \"test\"","eth-abi<6.0.0,>=5.0.0; extra == \"test\"","py-evm<0.11,>=0.10.1b1; extra == \"test\"","lark==1.1.9; extra == \"test\"","hypothesis[lark]<7.0,>=6.0; extra == \"test\"","eth-stdlib==0.2.7; extra == \"test\"","eth-account==0.12.2; extra == \"test\"","setuptools; extra == \"test\"","hexbytes>=1.2; extra == \"test\"","pyrevm>=0.3.2; extra == \"test\""],"requires_python":"<4,>=3.10","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0rc3","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"85f540c505bd51539c43ac5254838d09603e9ce2a2a3ae07e9d4c79f82649ff2","md5":"21cab8a1cbb20a64b7f4b3c529f8d9b5","sha256":"8e6c9e1fe1e28fc17b47fc4b92af8f0758d21faecca77cc2fbed685ddbc4bd41"},"downloads":-1,"filename":"vyper-0.4.0rc3-py3-none-any.whl","has_sig":false,"md5_digest":"21cab8a1cbb20a64b7f4b3c529f8d9b5","packagetype":"bdist_wheel","python_version":"py3","requires_python":"<4,>=3.10","size":331318,"upload_time":"2024-05-08T16:11:19","upload_time_iso_8601":"2024-05-08T16:11:19.344847Z","url":"https://files.pythonhosted.org/packages/85/f5/40c505bd51539c43ac5254838d09603e9ce2a2a3ae07e9d4c79f82649ff2/vyper-0.4.0rc3-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"e83b2cad7ebb57b6b63b59db142cedcb494954ca65acba681c50c273c6e93252","md5":"8c89cab26771e547bbd280f0429a9545","sha256":"eabfc2f02feab9af1be4a10426a64ff4ea3e90b83ec26958dc77915e1dd50493"},"downloads":-1,"filename":"vyper-0.4.0rc3.tar.gz","has_sig":false,"md5_digest":"8c89cab26771e547bbd280f0429a9545","packagetype":"sdist","python_version":"source","requires_python":"<4,>=3.10","size":658647,"upload_time":"2024-05-08T16:11:21","upload_time_iso_8601":"2024-05-08T16:11:21.449612Z","url":"https://files.pythonhosted.org/packages/e8/3b/2cad7ebb57b6b63b59db142cedcb494954ca65acba681c50c273c6e93252/vyper-0.4.0rc3.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.0rc4":{"info":{"author":"Vyper Team","author_email":null,"bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11","Programming Language :: Python :: 3.12"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":null,"maintainer_email":null,"name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0rc4/","requires_dist":["cbor2<6,>=5.4.6","asttokens<3,>=2.0.5","pycryptodome<4,>=3.5.1","packaging<24,>=23.1","importlib-metadata","wheel","ipython; extra == \"dev\"","pre-commit; extra == \"dev\"","pyinstaller; extra == \"dev\"","twine; extra == \"dev\"","pytest<9.0,>=8.0; extra == \"dev\"","pytest-cov<5.0,>=4.1; extra == \"dev\"","pytest-instafail<1.0,>=0.4; extra == \"dev\"","pytest-xdist<3.4,>=3.0; extra == \"dev\"","pytest-split<1.0,>=0.7.0; extra == \"dev\"","eth-abi<6.0.0,>=5.0.0; extra == \"dev\"","py-evm<0.11,>=0.10.1b1; extra == \"dev\"","lark==1.1.9; extra == \"dev\"","hypothesis[lark]<7.0,>=6.0; extra == \"dev\"","eth-stdlib==0.2.7; extra == \"dev\"","eth-account==0.12.2; extra == \"dev\"","setuptools; extra == \"dev\"","hexbytes>=1.2; extra == \"dev\"","pyrevm>=0.3.2; extra == \"dev\"","black==23.12.0; extra == \"dev\"","flake8==6.1.0; extra == \"dev\"","flake8-bugbear==23.12.2; extra == \"dev\"","flake8-use-fstring==1.4; extra == \"dev\"","isort==5.13.2; extra == \"dev\"","mypy==1.5; extra == \"dev\"","black==23.12.0; extra == \"lint\"","flake8==6.1.0; extra == \"lint\"","flake8-bugbear==23.12.2; extra == \"lint\"","flake8-use-fstring==1.4; extra == \"lint\"","isort==5.13.2; extra == \"lint\"","mypy==1.5; extra == \"lint\"","pytest<9.0,>=8.0; extra == \"test\"","pytest-cov<5.0,>=4.1; extra == \"test\"","pytest-instafail<1.0,>=0.4; extra == \"test\"","pytest-xdist<3.4,>=3.0; extra == \"test\"","pytest-split<1.0,>=0.7.0; extra == \"test\"","eth-abi<6.0.0,>=5.0.0; extra == \"test\"","py-evm<0.11,>=0.10.1b1; extra == \"test\"","lark==1.1.9; extra == \"test\"","hypothesis[lark]<7.0,>=6.0; extra == \"test\"","eth-stdlib==0.2.7; extra == \"test\"","eth-account==0.12.2; extra == \"test\"","setuptools; extra == \"test\"","hexbytes>=1.2; extra == \"test\"","pyrevm>=0.3.2; extra == \"test\""],"requires_python":"<4,>=3.10","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0rc4","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"e82b034ed601e489ef63f42e784da5fa72766d2a8b22d073c83fe1532a30f298","md5":"c5c0a3c82add03a537f789731dc4c995","sha256":"5c7ea9b4431f0372a96be21211cc6f8bfbd5b90765099b9b03256436687ce93e"},"downloads":-1,"filename":"vyper-0.4.0rc4-py3-none-any.whl","has_sig":false,"md5_digest":"c5c0a3c82add03a537f789731dc4c995","packagetype":"bdist_wheel","python_version":"py3","requires_python":"<4,>=3.10","size":332261,"upload_time":"2024-05-15T17:18:01","upload_time_iso_8601":"2024-05-15T17:18:01.082179Z","url":"https://files.pythonhosted.org/packages/e8/2b/034ed601e489ef63f42e784da5fa72766d2a8b22d073c83fe1532a30f298/vyper-0.4.0rc4-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"22b66dcd973e4486680f703142bb764f0d66080f4e3f3ec20b32153b64d76250","md5":"cadd0171e294c18deec68e9d6c5bc5cd","sha256":"f9debf76c80643201119d4621afbeb87b6450d35176d501abbbb80308e4de69d"},"downloads":-1,"filename":"vyper-0.4.0rc4.tar.gz","has_sig":false,"md5_digest":"cadd0171e294c18deec68e9d6c5bc5cd","packagetype":"sdist","python_version":"source","requires_python":"<4,>=3.10","size":660132,"upload_time":"2024-05-15T17:18:03","upload_time_iso_8601":"2024-05-15T17:18:03.770546Z","url":"https://files.pythonhosted.org/packages/22/b6/6dcd973e4486680f703142bb764f0d66080f4e3f3ec20b32153b64d76250/vyper-0.4.0rc4.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.0rc5":{"info":{"author":"Vyper Team","author_email":null,"bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11","Programming Language :: Python :: 3.12"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":null,"maintainer_email":null,"name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0rc5/","requires_dist":["cbor2<6,>=5.4.6","asttokens<3,>=2.0.5","pycryptodome<4,>=3.5.1","packaging<24,>=23.1","importlib-metadata","wheel","ipython; extra == \"dev\"","pre-commit; extra == \"dev\"","pyinstaller; extra == \"dev\"","twine; extra == \"dev\"","pytest<9.0,>=8.0; extra == \"dev\"","pytest-cov<5.0,>=4.1; extra == \"dev\"","pytest-instafail<1.0,>=0.4; extra == \"dev\"","pytest-xdist<3.4,>=3.0; extra == \"dev\"","pytest-split<1.0,>=0.7.0; extra == \"dev\"","eth-abi<6.0.0,>=5.0.0; extra == \"dev\"","py-evm<0.11,>=0.10.1b1; extra == \"dev\"","lark==1.1.9; extra == \"dev\"","hypothesis[lark]<7.0,>=6.0; extra == \"dev\"","eth-stdlib==0.2.7; extra == \"dev\"","eth-account==0.12.2; extra == \"dev\"","setuptools; extra == \"dev\"","hexbytes>=1.2; extra == \"dev\"","pyrevm>=0.3.2; extra == \"dev\"","black==23.12.0; extra == \"dev\"","flake8==6.1.0; extra == \"dev\"","flake8-bugbear==23.12.2; extra == \"dev\"","flake8-use-fstring==1.4; extra == \"dev\"","isort==5.13.2; extra == \"dev\"","mypy==1.5; extra == \"dev\"","black==23.12.0; extra == \"lint\"","flake8==6.1.0; extra == \"lint\"","flake8-bugbear==23.12.2; extra == \"lint\"","flake8-use-fstring==1.4; extra == \"lint\"","isort==5.13.2; extra == \"lint\"","mypy==1.5; extra == \"lint\"","pytest<9.0,>=8.0; extra == \"test\"","pytest-cov<5.0,>=4.1; extra == \"test\"","pytest-instafail<1.0,>=0.4; extra == \"test\"","pytest-xdist<3.4,>=3.0; extra == \"test\"","pytest-split<1.0,>=0.7.0; extra == \"test\"","eth-abi<6.0.0,>=5.0.0; extra == \"test\"","py-evm<0.11,>=0.10.1b1; extra == \"test\"","lark==1.1.9; extra == \"test\"","hypothesis[lark]<7.0,>=6.0; extra == \"test\"","eth-stdlib==0.2.7; extra == \"test\"","eth-account==0.12.2; extra == \"test\"","setuptools; extra == \"test\"","hexbytes>=1.2; extra == \"test\"","pyrevm>=0.3.2; extra == \"test\""],"requires_python":"<4,>=3.10","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0rc5","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"90d7c94f6c64340230f14f33c5b04c857ec5958fc195fa2bb9fd03ad7b4d2583","md5":"8625db2426b50a60a922689f03f0dc6b","sha256":"149a9bcce3a9f2778ee3775cb15eb48e1c12ed645d7e2fb45cb578a7abc39f90"},"downloads":-1,"filename":"vyper-0.4.0rc5-py3-none-any.whl","has_sig":false,"md5_digest":"8625db2426b50a60a922689f03f0dc6b","packagetype":"bdist_wheel","python_version":"py3","requires_python":"<4,>=3.10","size":332306,"upload_time":"2024-05-16T14:28:47","upload_time_iso_8601":"2024-05-16T14:28:47.939929Z","url":"https://files.pythonhosted.org/packages/90/d7/c94f6c64340230f14f33c5b04c857ec5958fc195fa2bb9fd03ad7b4d2583/vyper-0.4.0rc5-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"5a7fdecd3edf3d3bfd1686277dc590c9d656f25627ac4ea12dd3aa873eb3d149","md5":"ff465604f3a5bbea5c5b1bf6445572c8","sha256":"f75042339f00bfdd416970df81bde79ec100d4dfe53a03afafb56514fd4eb186"},"downloads":-1,"filename":"vyper-0.4.0rc5.tar.gz","has_sig":false,"md5_digest":"ff465604f3a5bbea5c5b1bf6445572c8","packagetype":"sdist","python_version":"source","requires_python":"<4,>=3.10","size":660154,"upload_time":"2024-05-16T14:28:51","upload_time_iso_8601":"2024-05-16T14:28:51.162549Z","url":"https://files.pythonhosted.org/packages/5a/7f/decd3edf3d3bfd1686277dc590c9d656f25627ac4ea12dd3aa873eb3d149/vyper-0.4.0rc5.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.0rc6":{"info":{"author":"Vyper Team","author_email":null,"bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11","Programming Language :: Python :: 3.12"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":null,"maintainer_email":null,"name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":null,"release_url":"https://pypi.org/project/vyper/0.4.0rc6/","requires_dist":["cbor2<6,>=5.4.6","asttokens<3,>=2.0.5","pycryptodome<4,>=3.5.1","packaging<24,>=23.1","importlib-metadata","wheel","ipython; extra == \"dev\"","pre-commit; extra == \"dev\"","pyinstaller; extra == \"dev\"","twine; extra == \"dev\"","pytest<9.0,>=8.0; extra == \"dev\"","pytest-cov<5.0,>=4.1; extra == \"dev\"","pytest-instafail<1.0,>=0.4; extra == \"dev\"","pytest-xdist<3.4,>=3.0; extra == \"dev\"","pytest-split<1.0,>=0.7.0; extra == \"dev\"","eth-abi<6.0.0,>=5.0.0; extra == \"dev\"","py-evm<0.11,>=0.10.1b1; extra == \"dev\"","lark==1.1.9; extra == \"dev\"","hypothesis[lark]<7.0,>=6.0; extra == \"dev\"","eth-stdlib==0.2.7; extra == \"dev\"","eth-account==0.12.2; extra == \"dev\"","setuptools; extra == \"dev\"","hexbytes>=1.2; extra == \"dev\"","pyrevm>=0.3.2; extra == \"dev\"","black==23.12.0; extra == \"dev\"","flake8==6.1.0; extra == \"dev\"","flake8-bugbear==23.12.2; extra == \"dev\"","flake8-use-fstring==1.4; extra == \"dev\"","isort==5.13.2; extra == \"dev\"","mypy==1.5; extra == \"dev\"","black==23.12.0; extra == \"lint\"","flake8==6.1.0; extra == \"lint\"","flake8-bugbear==23.12.2; extra == \"lint\"","flake8-use-fstring==1.4; extra == \"lint\"","isort==5.13.2; extra == \"lint\"","mypy==1.5; extra == \"lint\"","pytest<9.0,>=8.0; extra == \"test\"","pytest-cov<5.0,>=4.1; extra == \"test\"","pytest-instafail<1.0,>=0.4; extra == \"test\"","pytest-xdist<3.4,>=3.0; extra == \"test\"","pytest-split<1.0,>=0.7.0; extra == \"test\"","eth-abi<6.0.0,>=5.0.0; extra == \"test\"","py-evm<0.11,>=0.10.1b1; extra == \"test\"","lark==1.1.9; extra == \"test\"","hypothesis[lark]<7.0,>=6.0; extra == \"test\"","eth-stdlib==0.2.7; extra == \"test\"","eth-account==0.12.2; extra == \"test\"","setuptools; extra == \"test\"","hexbytes>=1.2; extra == \"test\"","pyrevm>=0.3.2; extra == \"test\""],"requires_python":"<4,>=3.10","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.0rc6","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"a1cd43c55a377cfd7d2513b696f3c1fd9c7e6a5fe467a3163dd0b2364fe13f42","md5":"cc9a0d62bb02e1ff9d9cf8dcda2092b3","sha256":"ac421c84aa32e7fd66bf2b2457c11ab05f96c89f7a4d724d137f7b870bfe9a85"},"downloads":-1,"filename":"vyper-0.4.0rc6-py3-none-any.whl","has_sig":false,"md5_digest":"cc9a0d62bb02e1ff9d9cf8dcda2092b3","packagetype":"bdist_wheel","python_version":"py3","requires_python":"<4,>=3.10","size":336738,"upload_time":"2024-05-30T22:54:32","upload_time_iso_8601":"2024-05-30T22:54:32.807605Z","url":"https://files.pythonhosted.org/packages/a1/cd/43c55a377cfd7d2513b696f3c1fd9c7e6a5fe467a3163dd0b2364fe13f42/vyper-0.4.0rc6-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"ee8ee08aef5d79fe39b2e500632628286130dc9bebd110fbeae2a9dc17c9d861","md5":"f750d169945665ba1ff529f70e61dc8c","sha256":"1237877638a12e621588f0e717b9658b5ddef4dfa7b8143276963b17dd9414d0"},"downloads":-1,"filename":"vyper-0.4.0rc6.tar.gz","has_sig":false,"md5_digest":"f750d169945665ba1ff529f70e61dc8c","packagetype":"sdist","python_version":"source","requires_python":"<4,>=3.10","size":655480,"upload_time":"2024-05-30T22:54:35","upload_time_iso_8601":"2024-05-30T22:54:35.259679Z","url":"https://files.pythonhosted.org/packages/ee/8e/e08aef5d79fe39b2e500632628286130dc9bebd110fbeae2a9dc17c9d861/vyper-0.4.0rc6.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[{"aliases":["CVE-2024-32645"],"details":"### Summary\nIncorrect values can be logged when `raw_log` builtin is called with memory or storage arguments to be used as topics.\n\nA contract search was performed and no vulnerable contracts were found in production. In particular, no uses of `raw_log()` were found at all in production; it is apparently not a well-known function.\n\n### Details\nThe `build_IR` function of the `RawLog` class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.\n\n### PoC\n```vyper\nx: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n```\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3977.\n\n### Impact\nIncorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.\n","fixed_in":["0.4.0"],"id":"GHSA-xchq-w5r3-4wg3","link":"https://osv.dev/vulnerability/GHSA-xchq-w5r3-4wg3","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32649"],"details":"### Summary\nUsing the `sqrt` builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nIt can be seen that the `build_IR` function of the `sqrt` builtin doesn't cache the argument to the stack: \nhttps://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nWith at least Vyper version `0.2.15+commit.6e7dba7` the following contract:\n```vyper\nc: uint256\n\n@internal\ndef some_decimal() -> decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -> uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n```\npasses the following test:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n```\n \n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.","fixed_in":["0.4.0"],"id":"GHSA-5jrj-52x8-m64h","link":"https://osv.dev/vulnerability/GHSA-5jrj-52x8-m64h","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32647"],"details":"### Summary\nUsing the `create_from_blueprint` builtin can result in a double eval vulnerability when `raw_args=True` and the `args` argument has side-effects. \n\nA contract search was performed and no vulnerable contracts were found in production. In particular, the `raw_args` variant of `create_from_blueprint` was not found to be used in production.\n\n### Details\nIt can be seen that the `_build_create_IR` function of the `create_from_blueprint` builtin doesn't cache the mentioned `args` argument to the stack: https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\n\nAs such, it can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nThe vulnerability is demonstrated in the following `boa` test:\n``` vyper\nsrc1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -> Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n```\nThe output of `c2.deployed()` is `2` although `create_` was called only once and the value was initialized to `0`.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is `low`.\n","fixed_in":["0.4.0"],"id":"GHSA-3whq-64q2-qfj6","link":"https://osv.dev/vulnerability/GHSA-3whq-64q2-qfj6","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-32646"],"details":"### Summary\nUsing the `slice` builtin can result in a double eval vulnerability when the buffer argument is either `msg.data`, `self.code` or `<address>.code` and either the `start` or `length` arguments have side-effects.\n\nA contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since `0.3.4` since the unique symbol fence was introduced (https://github.com/vyperlang/vyper/pull/2914).\n\n### Details\nIt can be seen that the `_build_adhoc_slice_node` function of the `slice` builtin doesn't cache the mentioned arguments to the stack: https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\n\nAs such, they can be evaluated multiple times (instead of retrieving the value from the stack).\n\n### PoC\nwith Vyper version `0.3.3+commit.48e326f` the call to `foo` passes the `asserts`:\n```vyper\nl: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -> uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3976.\n\n### Impact\nNo vulnerable production contracts were found.\n","fixed_in":["0.4.0"],"id":"GHSA-r56x-j438-vw5m","link":"https://osv.dev/vulnerability/GHSA-r56x-j438-vw5m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24563"],"details":"### Summary\nArrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an `int` as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. `-2**255 + 5`) quantities combined with large enough arrays (at least `2**255` in length) can pass the bounds checker, resulting in unexpected behavior.\n\nA contract search was performed, and no production contracts were found to be impacted.\n\n### Details\nThe typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from `0.3.10`:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\n\nAs can be seen, the validation is performed against `IntegerT.any()`.\n\n### PoC\nIf the array is sufficiently large, it can be indexed with a negative value:\n```python\narr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n```\nFor signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\nhttps://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3817.\n\n### Impact\nThere are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.\n\n1. If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.\n\n2. If a contract has an invariant in the form `assert index < x` where both `index` and `x` are signed integers, the developer might suppose that no elements on indexes `y | y >= x` are accessible. However, by using negative indexes this can be bypassed.\n\nThe contract search found no production contracts impacted by these two classes of issues.","fixed_in":["0.4.0"],"id":"GHSA-52xq-j7v9-v4v2","link":"https://osv.dev/vulnerability/GHSA-52xq-j7v9-v4v2","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24560"],"details":"## Summary\n\nWhen calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking `RETURNDATASIZE` for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's `length`. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.\n\nThis advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.\n\n## Details\n\nWhen arguments are packed for an external call, we create a buffer of size `max(args, return_data) + 32`. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past `RETURNDATASIZE`.\n\n```python\nif fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n```\n\nWhen data is returned, we unpack the return data by starting at byte 0. We check that `RETURNDATASIZE` is greater than the minimum allowed for the returned type:\n```python\nif not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n```\n\nThis check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that `RETURNDATASIZE` is as large as the `length` word of the dynamic type. \n\nAs a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as `length` includes a size that is larger than the actual `RETURNDATASIZE`, the return data read from the buffer will overrun the actual return data size and read from the input buffer.\n\n## Proof of Concept\n\nThis contract calls an external contract with two arguments. As the call is made, the buffer includes:\n- byte 28: method_id\n- byte 32: first argument (0)\n- byte 64: second argument (hash)\n\nThe return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.\n\n```python\ninterface Zero:\n    def sneaky(a: uint256, b: bytes32) -> Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -> Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n```\nOn the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:\n```solidity\nfunction sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n```\n\nThe return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.\n\nSince these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.\n\nIf we run the following Foundry test, we can see that this does in fact happen:\n```solidity\nfunction test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n```\n\n```md\nLogs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.\n\n## Impact\n\nMalicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.","fixed_in":["0.4.0"],"id":"GHSA-gp3w-2v2m-p686","link":"https://osv.dev/vulnerability/GHSA-gp3w-2v2m-p686","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-26149"],"details":"## Summary\n\nIf an excessively large value is specified as the starting index for an array in `_abi_decode`, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within `_abi_decode`. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of `abi_decode` on the same input.\n\n## Proof of Concept\n\n```vyper\nevent Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n```\n\nSending the following calldata results in `Pwn` being emitted. \n\n```\n0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n```\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/3925, https://github.com/vyperlang/vyper/pull/4091, https://github.com/vyperlang/vyper/pull/4144, https://github.com/vyperlang/vyper/pull/4060.","fixed_in":["0.4.0"],"id":"GHSA-9p8r-4xp4-gw5w","link":"https://osv.dev/vulnerability/GHSA-9p8r-4xp4-gw5w","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24567"],"details":"### Summary\nVyper compiler allows passing a value in builtin `raw_call` even if the call is a `delegatecall` or a `staticcall`. But in the context of `delegatecall` and `staticcall` the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the `value=` argument.\n\nA contract search was performed and no vulnerable contracts were found in production.\n\n### Details\nThe IR for `raw_call` is built in the `RawCall` class:\nhttps://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\n\nHowever, the compiler doesn't validate that if either `delegatecall` or `staticall` are provided as kwargs, that `value` wasn't set. For example, the following compiles without errors:\n```python\nraw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n```\n\n### Impact\nIf the semantics of the EVM are unknown to the developer, he could suspect that by specifying the `value` kwarg, exactly the given amount will be sent along to the target. However in fact, no `value` will be sent.\n\nHere is an example of an potentially problematic implementation of multicall utilizing the `raw_call` built-in:\n```python\nvalue_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n```\n\n### Patches\nFixed in https://github.com/vyperlang/vyper/pull/3755\n### Workarounds\n_Is there a way for users to fix or remediate the vulnerability without upgrading?_\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":["0.4.0"],"id":"GHSA-x2c2-q32w-4w6m","link":"https://osv.dev/vulnerability/GHSA-x2c2-q32w-4w6m","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24559"],"details":"### Summary\nThere is an error in the stack management when compiling the `IR` for `sha3_64`. Concretely, the `height` variable is miscalculated.\nThe vulnerability can't be triggered without writing the `IR` by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the `fang` binary directly (this binary used to be called `vyper-ir` prior to v0.3.4).\n\n### Details\nTo compile `sha3_64`, the `arg[0]` and `arg[1]` have to be compiled:\nhttps://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\n\nAs can be seen, after compiling the 0th arg, the `height` variable isn't increased. If new `withargs` are defined in the inner scope, they are manipulated correctly, because both their `height` is off and also the global `height` is off and thus their placement on the stack is computed correctly.\n\n`sha3_64` is used for retrieval in mappings. No flow that would cache the `key` was found, the issue shouldn't be possible to trigger when compiling the compiler-generated `IR`.\n\n### PoC\nSuppose the following hand-written IR:\n```lisp\n(with _loc\n\t(with val 1 \n\t\t(with key 2 \n\t\t\t(sha3_64 val key))) \n\t\t\t\t(seq \n\t\t\t\t\t(sstore _loc \n\t\t\t\t\t(with x (sload _loc) \n\t\t\t\t\t\t(with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n```\nafter compilation:\n```\nthe generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n```\n\nIt can be seen that the second `DUP` will dup the item on the top of the stack which is incorrect.\n\n### Patches\nPatched in https://github.com/vyperlang/vyper/pull/4063.\n\n### Impact\nVersions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.\n","fixed_in":["0.4.0"],"id":"GHSA-6845-xw22-ffxv","link":"https://osv.dev/vulnerability/GHSA-6845-xw22-ffxv","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2023-40015"],"details":"### Impact\n\nFor the following (probably non-exhaustive) list of expressions, the compiler evaluates the arguments from right to left instead of left to right.\n\n```\n- unsafe_add\n- unsafe_sub\n- unsafe_mul\n- unsafe_div\n- pow_mod256\n- |, &, ^ (bitwise operators)\n- bitwise_or (deprecated)\n- bitwise_and (deprecated)\n- bitwise_xor (deprecated)\n- raw_call\n- <, >, <=, >=, ==, !=\n- in, not in (when lhs and rhs are enums)\n```\n\nThis behaviour becomes a problem when the evaluation of one of the arguments produces side effects that other arguments depend on. The following expressions can produce side-effect:\n\n- state modifying external call \n- state modifying internal call\n- `raw_call`\n- `pop()` when used on a Dynamic Array stored in the storage\n- `create_minimal_proxy_to`\n- `create_copy_of`\n- `create_from_blueprint`\n\nFor example:\n\n```Vyper\nf:uint256\n\n@internal\ndef side_effect() -> uint256:\n    self.f = 12\n    return 1\n\n@external\ndef foo() -> uint256:\n    return unsafe_add(self.f,self.side_effect()) # returns 13 instead of 1\n```\n\n```Vyper\na:DynArray[uint256, 12]\n@external\ndef bar() -> bool:\n    self.a = [1,2,3]\n    return len(self.a) == self.a.pop() # return false instead of true\n```\n\n### Patches\nnot yet patched, will address in a future release. tracking in https://github.com/vyperlang/vyper/issues/3604.\n\n### Workarounds\n\nWhen using expressions from the list above, make sure that the arguments of the expression do not produce side effects or, if one does, that no other argument is dependent on those side effects.\n\n### References\n_Are there any links users can visit to find out more?_\n","fixed_in":[],"id":"GHSA-g2xh-c426-v8mf","link":"https://osv.dev/vulnerability/GHSA-g2xh-c426-v8mf","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-22419"],"details":" ### Summary\n`concat` built-in can write over the bounds of the memory buffer that was allocated for it and thus overwrite existing valid data. The root cause is that the `build_IR` for `concat` doesn't properly adhere to the API of copy functions (for `>=0.3.2` the `copy_bytes` function).\n\nA contract search was performed and no vulnerable contracts were found in production.\n\nTracked in issue https://github.com/vyperlang/vyper/issues/3737\n\n### Details\nThe `build_IR` allocates a new internal variable for the concatenation: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L534-L550\n\nNotice that the buffer is allocated for the `maxlen` + 1 word to actually hold the length of the array.\n\nLater the `copy_bytes` function is used to copy the actual source arguments to the destination: https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/builtins/functions.py#L569-L572\n\nThe `dst_data` is defined via:\n- `data ptr` - to skip the 1 word that holds the length\n- `offset`  - to skip the source arguments that were already written to the buffer\n  - the `offset` is increased via: `[\"set\", ofst, [\"add\", ofst, arglen]]`, ie it is increased by the length of the source argument\n\nNow, the `copy_bytes` function has multiple control flow paths, the following ones are of interest:\n1) https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L270-L273\n2)  https://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L301-L320\n\nNote that the function itself contains the following note: \nhttps://github.com/vyperlang/vyper/blob/3b310d5292c4d1448e673d7b3adb223f9353260e/vyper/codegen/core.py#L245-L247\n\nThat is we can ask for a copy of `1B` yet a whole word is copied.\n\nConsider the first interesting path -  if the `dst_data`'s distance to the end of the concat data buffer is `< 32B`, the `copy_op = STORE(dst, LOAD(src))` from `copy_bytes` will result in buffer overflow as it essentially will `mstore` to `dst_data` the `mload` of the source (mload will load whole word and the distance of the `dst_data` to the word boundary is `<32B`).\n\nFrom the two mentioned paths in `copy_bytes` it can be seen that both sources from memory and storage can cause the corruption.\n\n### PoC\nThe main attack vector that was found was when the `concat` is inside an `internal` function.  Suppose we have an `external` function that calls `internal` one. In such case the address space is divided such that the memory for the internal function is in _lower_  portion of the adr space. As such the buffer overflow can overwrite _valid_ data of the caller.\n\nHere is a simple example:\n```python\n#@version ^0.3.9\n\n@internal\ndef bar() -> uint256:\n    sss: String[2] = concat(\"a\", \"b\") \n    return 1\n\n\n@external\ndef foo() -> int256:\n    a: int256 = -1\n    b: uint256 = self.bar()\n    return a \n```\n\n`foo` should clearly return `-1`, but it returns `452312848583266388373324160190187140051835877600158453279131187530910662655`\n\n`-1` was used intentionally due to its bit structure but the value here is fairly irelevant. In this example during the second iteration of the for loop in the `build_IR` `mload` to `dst+1` will be executed (because len('a') == 1), thus the function will write `1B` over the bounds of the buffer. The string 'b' is stored such that its right-most byte is a zero byte. So a zero byte will be written over the bounds.  So when `-1` is considered it's left-most B will be overwritten to all 0. Therefore it can be seen: `452312848583266388373324160190187140051835877600158453279131187530910662655 == (2**248-1)` will output `True`.\n\n#### IR\nIf we look at the contract's IR (vyper --no optimize -f ir), we see:\n```\n# Line 30\n                          /* a: int256 = -1 */ [mstore, 320, -1 <-1>],\n```\nAnd for the second iteration of the loop in concat:\n```\n len,\n                        [mload, arg],\n                        [seq,\n                          [with,\n                            src,\n                            [add, arg, 32],\n                            [with,\n                              dst,\n                              [add, [add, 256 <concat destination>, 32], concat_ofst],\n                              [mstore, dst, [mload, src]]]],\n                          [set, concat_ofst, [add, concat_ofst, len]]]]],\n                    [mstore, 256 <concat destination>, concat_ofst],\n                    256 <concat destination>]],\n```\nSo the address of the `int` is 320. \n\nThe `dst` is defined as: `[add, [add, 256 <concat destination>, 32], concat_ofst],`.\nIn the second iteration the `concat_ofst` will be 1 because `len('a)==1` so `256+32+1 = 289`. Now this address will be `mstored` to - so the last mstored B will have the address `289+32=320` which clearly overlaps with the address of the `int a`.\n\n#### PoC 2\nDue to how `immutables` are handled, they can be corrupted too:\n```python\n#@version ^0.3.9\n\ni: immutable(int256)\n\n@external\ndef __init__():\n    i = -1\n    s: String[2] = concat(\"a\", \"b\")\n\n@external\ndef foo() -> int256:\n    return i\n```\n\nOutput of calling `foo()` = `452312848583266388373324160190187140051835877600158453279131187530910662655`.\n\n### Impact\nThe buffer overflow can result in the change of semantics of the contract. The overflow is length-dependent and thus it might go unnoticed during contract testing.\n\nHowever, certainly not all usages of `concat` will result in overwritten valid data as we require it to be in an `internal` function and close to the `return` statement where other memory allocations don't occur. \n\n### Concluding remarks\nThe bug based on the fast path in `copy_bytes` was likely introduced in: `548d35d720fb6fd8efbdc0ce525bed259a73f0b9`. `git bisect` was used between v0.3.1 and v0.3.2, `forge test` was run and the test asserted that the function indeed returns -1.\n\nFor the general case, `0.3.0` and `0.3.1` are also affected.","fixed_in":["0.4.0"],"id":"GHSA-2q8v-3gqq-4f8p","link":"https://osv.dev/vulnerability/GHSA-2q8v-3gqq-4f8p","source":"osv","summary":null,"withdrawn":null},{"aliases":["CVE-2024-24564"],"details":"### Summary\n\nWhen using the built-in `extract32(b, start)`, if the `start` index provided has for side effect to update `b`, the byte array to extract `32` bytes from, it could be that some dirty memory is read and returned by `extract32`.\n\nAs of v0.4.0 (specifically, commit https://github.com/vyperlang/vyper/commit/3d9c537142fb99b2672f21e2057f5f202cde194f), the compiler will panic instead of generating bytecode.\n\n### Details\n\nBefore evaluating `start`, the function `Extract32.build_IR` caches only:\n\n- The pointer in memory/storage to `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L916-L918\n- The length of `b`: https://github.com/vyperlang/vyper/blob/10564dcc37756f3d3684b7a91fd8f4325a38c4d8/vyper/builtins/functions.py#L920-L922\n\nbut do not cache the actual content of `b`. This means that if the evaluation of `start` changes `b`'s content and length, an outdated length will be used with the new content when extracting 32 bytes from `b`.\n\n### PoC\n\nCalling the function `foo` of the following contract returns `b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'` meaning that `extract32` accessed some dirty memory.\n\n```Vyper\nvar:Bytes[96]\n\n@internal\ndef bar() -> uint256:\n    self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'\n    self.var = b''\n    return 3\n\n@external\ndef foo() -> bytes32:\n    self.var = b'abcdefghijklmnopqrstuvwxyz123456789'\n    return extract32(self.var, self.bar(), output_type=bytes32)\n    # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'\n```\n\n### Impact\n\nFor contracts that are affected, it means that calling `extract32` returns dirty memory bytes instead of some expected output.","fixed_in":["0.4.0"],"id":"GHSA-4hwq-4cpm-8vmx","link":"https://osv.dev/vulnerability/GHSA-4hwq-4cpm-8vmx","source":"osv","summary":null,"withdrawn":null}]},"0.4.1b1":{"info":{"author":"Vyper Team","author_email":null,"bugtrack_url":null,"classifiers":["Intended Audience :: Developers","License :: OSI Approved :: Apache Software License","Programming Language :: Python :: 3.10","Programming Language :: Python :: 3.11","Programming Language :: Python :: 3.12"],"description_content_type":"text/markdown","docs_url":null,"download_url":null,"downloads":{"last_day":-1,"last_month":-1,"last_week":-1},"dynamic":null,"home_page":"https://github.com/vyperlang/vyper","keywords":"ethereum evm smart contract language","license":"Apache License 2.0","maintainer":null,"maintainer_email":null,"name":"vyper","package_url":"https://pypi.org/project/vyper/","platform":null,"project_url":"https://pypi.org/project/vyper/","project_urls":{"Homepage":"https://github.com/vyperlang/vyper"},"provides_extra":["dev","lint","test"],"release_url":"https://pypi.org/project/vyper/0.4.1b1/","requires_dist":["cbor2<6,>=5.4.6","asttokens<3,>=2.0.5","pycryptodome<4,>=3.5.1","packaging<24,>=23.1","importlib-metadata","wheel","ipython; extra == \"dev\"","pre-commit; extra == \"dev\"","pyinstaller; extra == \"dev\"","twine; extra == \"dev\"","pytest<9.0,>=8.0; extra == \"dev\"","pytest-cov<5.0,>=4.1; extra == \"dev\"","pytest-instafail<1.0,>=0.4; extra == \"dev\"","pytest-xdist<3.4,>=3.0; extra == \"dev\"","pytest-split<1.0,>=0.7.0; extra == \"dev\"","eth-abi<6.0.0,>=5.0.0; extra == \"dev\"","py-evm<0.11,>=0.10.1b1; extra == \"dev\"","lark==1.1.9; extra == \"dev\"","hypothesis[lark]<7.0,>=6.0; extra == \"dev\"","eth-stdlib==0.2.7; extra == \"dev\"","eth-account==0.12.2; extra == \"dev\"","setuptools; extra == \"dev\"","hexbytes>=1.2; extra == \"dev\"","pyrevm>=0.3.2; extra == \"dev\"","black==23.12.0; extra == \"dev\"","flake8==6.1.0; extra == \"dev\"","flake8-bugbear==23.12.2; extra == \"dev\"","flake8-use-fstring==1.4; extra == \"dev\"","isort==5.13.2; extra == \"dev\"","mypy==1.5; extra == \"dev\"","black==23.12.0; extra == \"lint\"","flake8==6.1.0; extra == \"lint\"","flake8-bugbear==23.12.2; extra == \"lint\"","flake8-use-fstring==1.4; extra == \"lint\"","isort==5.13.2; extra == \"lint\"","mypy==1.5; extra == \"lint\"","pytest<9.0,>=8.0; extra == \"test\"","pytest-cov<5.0,>=4.1; extra == \"test\"","pytest-instafail<1.0,>=0.4; extra == \"test\"","pytest-xdist<3.4,>=3.0; extra == \"test\"","pytest-split<1.0,>=0.7.0; extra == \"test\"","eth-abi<6.0.0,>=5.0.0; extra == \"test\"","py-evm<0.11,>=0.10.1b1; extra == \"test\"","lark==1.1.9; extra == \"test\"","hypothesis[lark]<7.0,>=6.0; extra == \"test\"","eth-stdlib==0.2.7; extra == \"test\"","eth-account==0.12.2; extra == \"test\"","setuptools; extra == \"test\"","hexbytes>=1.2; extra == \"test\"","pyrevm>=0.3.2; extra == \"test\""],"requires_python":"<4,>=3.10","summary":"Vyper: the Pythonic Programming Language for the EVM","version":"0.4.1b1","yanked":false,"yanked_reason":null},"last_serial":25493007,"urls":[{"comment_text":"","digests":{"blake2b_256":"a422ae35329c80e70677644ab76af2f91ef6b888e67a2f89e938b1c17251c7be","md5":"0f0ae9c87aefc386ad2180f05fa5dbee","sha256":"143d34d46ee36fa6311b2dcecfe0079307382191bab8b0e75da52158f82db293"},"downloads":-1,"filename":"vyper-0.4.1b1-py3-none-any.whl","has_sig":false,"md5_digest":"0f0ae9c87aefc386ad2180f05fa5dbee","packagetype":"bdist_wheel","python_version":"py3","requires_python":"<4,>=3.10","size":344092,"upload_time":"2024-10-15T17:06:24","upload_time_iso_8601":"2024-10-15T17:06:24.165503Z","url":"https://files.pythonhosted.org/packages/a4/22/ae35329c80e70677644ab76af2f91ef6b888e67a2f89e938b1c17251c7be/vyper-0.4.1b1-py3-none-any.whl","yanked":false,"yanked_reason":null},{"comment_text":"","digests":{"blake2b_256":"5bdeb3940566337cc1e65d2fa95550931496bef440b6581c35ec007664082a26","md5":"97c2c11c98750377fc3a12c3986cbdcb","sha256":"5dce5f122bb6b5d8807bbb50d74b41f3efeb195d959a5109e0ed136486dc2a21"},"downloads":-1,"filename":"vyper-0.4.1b1.tar.gz","has_sig":false,"md5_digest":"97c2c11c98750377fc3a12c3986cbdcb","packagetype":"sdist","python_version":"source","requires_python":"<4,>=3.10","size":682073,"upload_time":"2024-10-15T17:06:25","upload_time_iso_8601":"2024-10-15T17:06:25.785630Z","url":"https://files.pythonhosted.org/packages/5b/de/b3940566337cc1e65d2fa95550931496bef440b6581c35ec007664082a26/vyper-0.4.1b1.tar.gz","yanked":false,"yanked_reason":null}],"vulnerabilities":[]}}